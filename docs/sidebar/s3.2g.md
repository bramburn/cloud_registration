Based on Sprint 3.2's focus on integrating a basic 3D point cloud viewer with rendering capabilities and camera controls, I'll provide you with a comprehensive implementation guide using Qt6 OpenGL widgets and point cloud parsing libraries.

## Core Architecture Overview

Sprint 3.2 requires three main components: a 3D viewer widget using OpenGL, point cloud data parsers for LAS/E57 files, and camera control systems. Here's the complete implementation:

## Point Cloud Viewer Widget Implementation

**PointCloudViewerWidget.h**
```cpp
#pragma once

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

namespace SceneRegistration {

struct PointCloudData {
    std::vector points;
    std::vector colors;
    QVector3D boundingBoxMin;
    QVector3D boundingBoxMax;
    
    void clear() {
        points.clear();
        colors.clear();
        boundingBoxMin = QVector3D();
        boundingBoxMax = QVector3D();
    }
    
    bool isEmpty() const {
        return points.empty();
    }
    
    size_t pointCount() const {
        return points.size();
    }
};

class Camera3D {
public:
    Camera3D();
    
    void setViewport(int width, int height);
    void frameData(const QVector3D& min, const QVector3D& max);
    
    // Camera controls
    void orbit(float deltaX, float deltaY);
    void pan(float deltaX, float deltaY);
    void zoom(float delta);
    void resetView();
    
    // Matrix access
    QMatrix4x4 viewMatrix() const;
    QMatrix4x4 projectionMatrix() const;
    QMatrix4x4 viewProjectionMatrix() const;
    
private:
    void updateViewMatrix();
    
    QVector3D m_position;
    QVector3D m_target;
    QVector3D m_up;
    float m_distance;
    float m_azimuth;
    float m_elevation;
    
    QMatrix4x4 m_viewMatrix;
    QMatrix4x4 m_projectionMatrix;
    
    int m_viewportWidth;
    int m_viewportHeight;
    float m_fov;
    float m_nearPlane;
    float m_farPlane;
};

class PointCloudViewerWidget : public QOpenGLWidget, protected QOpenGLFunctions {
    Q_OBJECT

public:
    explicit PointCloudViewerWidget(QWidget* parent = nullptr);
    ~PointCloudViewerWidget();

    // Point cloud data management
    void setPointCloudData(const PointCloudData& data);
    void clearPointCloud();
    void addPointCloudData(const PointCloudData& additionalData);
    
    // Rendering settings
    void setPointSize(float size);
    void setBackgroundColor(const QColor& color);
    void setShowGrid(bool show);
    void setShowAxes(bool show);
    
    // Camera access
    Camera3D* camera() { return m_camera.get(); }
    
    // Status
    bool hasData() const { return !m_pointCloudData.isEmpty(); }
    size_t pointCount() const { return m_pointCloudData.pointCount(); }

signals:
    void pointCloudLoaded(size_t pointCount);
    void renderingError(const QString& error);

protected:
    // QOpenGLWidget overrides
    void initializeGL() override;
    void paintGL() override;
    void resizeGL(int width, int height) override;
    
    // Mouse and keyboard events
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    void setupShaders();
    void setupBuffers();
    void updatePointCloudBuffers();
    void renderPointCloud();
    void renderGrid();
    void renderAxes();
    
    void handleOpenGLError(const QString& operation);
    
    // OpenGL resources
    std::unique_ptr m_pointCloudShader;
    std::unique_ptr m_gridShader;
    std::unique_ptr m_axesShader;
    
    QOpenGLVertexArrayObject m_pointCloudVAO;
    QOpenGLBuffer m_pointCloudVBO;
    QOpenGLBuffer m_colorVBO;
    
    QOpenGLVertexArrayObject m_gridVAO;
    QOpenGLBuffer m_gridVBO;
    
    QOpenGLVertexArrayObject m_axesVAO;
    QOpenGLBuffer m_axesVBO;
    QOpenGLBuffer m_axesColorVBO;
    
    // Camera and interaction
    std::unique_ptr m_camera;
    QPoint m_lastMousePos;
    Qt::MouseButton m_activeMouseButton;
    
    // Rendering state
    PointCloudData m_pointCloudData;
    float m_pointSize;
    QColor m_backgroundColor;
    bool m_showGrid;
    bool m_showAxes;
    bool m_buffersNeedUpdate;
    
    // Grid and axes data
    std::vector m_gridVertices;
    std::vector m_axesVertices;
    std::vector m_axesColors;
};

} // namespace SceneRegistration
```

**PointCloudViewerWidget.cpp**
```cpp
#include "PointCloudViewerWidget.h"
#include 
#include 
#include 
#include 
#include 

namespace SceneRegistration {

// Camera3D Implementation
Camera3D::Camera3D()
    : m_position(0, 0, 10)
    , m_target(0, 0, 0)
    , m_up(0, 1, 0)
    , m_distance(10.0f)
    , m_azimuth(0.0f)
    , m_elevation(0.0f)
    , m_viewportWidth(800)
    , m_viewportHeight(600)
    , m_fov(45.0f)
    , m_nearPlane(0.1f)
    , m_farPlane(1000.0f)
{
    updateViewMatrix();
}

void Camera3D::setViewport(int width, int height) {
    m_viewportWidth = width;
    m_viewportHeight = height;
    
    float aspect = static_cast(width) / static_cast(height);
    m_projectionMatrix.setToIdentity();
    m_projectionMatrix.perspective(m_fov, aspect, m_nearPlane, m_farPlane);
}

void Camera3D::frameData(const QVector3D& min, const QVector3D& max) {
    m_target = (min + max) * 0.5f;
    
    QVector3D size = max - min;
    float maxDimension = qMax(qMax(size.x(), size.y()), size.z());
    m_distance = maxDimension * 2.0f;
    
    // Update near/far planes based on data size
    m_nearPlane = maxDimension * 0.001f;
    m_farPlane = maxDimension * 10.0f;
    
    m_azimuth = 45.0f;
    m_elevation = 30.0f;
    
    updateViewMatrix();
    setViewport(m_viewportWidth, m_viewportHeight);
}

void Camera3D::orbit(float deltaX, float deltaY) {
    m_azimuth += deltaX * 0.5f;
    m_elevation += deltaY * 0.5f;
    
    // Clamp elevation to prevent gimbal lock
    m_elevation = qBound(-89.0f, m_elevation, 89.0f);
    
    updateViewMatrix();
}

void Camera3D::pan(float deltaX, float deltaY) {
    QVector3D right = QVector3D::crossProduct(m_target - m_position, m_up).normalized();
    QVector3D up = QVector3D::crossProduct(right, m_target - m_position).normalized();
    
    float panSpeed = m_distance * 0.001f;
    QVector3D offset = (right * deltaX + up * deltaY) * panSpeed;
    
    m_target += offset;
    updateViewMatrix();
}

void Camera3D::zoom(float delta) {
    m_distance *= (1.0f + delta * 0.1f);
    m_distance = qMax(0.1f, m_distance);
    updateViewMatrix();
}

void Camera3D::updateViewMatrix() {
    float azimuthRad = qDegreesToRadians(m_azimuth);
    float elevationRad = qDegreesToRadians(m_elevation);
    
    QVector3D offset(
        m_distance * cos(elevationRad) * cos(azimuthRad),
        m_distance * sin(elevationRad),
        m_distance * cos(elevationRad) * sin(azimuthRad)
    );
    
    m_position = m_target + offset;
    
    m_viewMatrix.setToIdentity();
    m_viewMatrix.lookAt(m_position, m_target, m_up);
}

QMatrix4x4 Camera3D::viewMatrix() const {
    return m_viewMatrix;
}

QMatrix4x4 Camera3D::projectionMatrix() const {
    return m_projectionMatrix;
}

QMatrix4x4 Camera3D::viewProjectionMatrix() const {
    return m_projectionMatrix * m_viewMatrix;
}

// PointCloudViewerWidget Implementation
PointCloudViewerWidget::PointCloudViewerWidget(QWidget* parent)
    : QOpenGLWidget(parent)
    , m_camera(std::make_unique())
    , m_activeMouseButton(Qt::NoButton)
    , m_pointSize(2.0f)
    , m_backgroundColor(QColor(30, 30, 30))
    , m_showGrid(true)
    , m_showAxes(true)
    , m_buffersNeedUpdate(false)
{
    setFocusPolicy(Qt::StrongFocus);
    setMouseTracking(true);
}

PointCloudViewerWidget::~PointCloudViewerWidget() {
    makeCurrent();
    // OpenGL resources are automatically cleaned up
    doneCurrent();
}

void PointCloudViewerWidget::initializeGL() {
    initializeOpenGLFunctions();
    
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_PROGRAM_POINT_SIZE);
    
    setupShaders();
    setupBuffers();
    
    // Setup grid
    const float gridSize = 10.0f;
    const int gridLines = 21;
    const float step = gridSize * 2.0f / (gridLines - 1);
    
    m_gridVertices.clear();
    for (int i = 0; i ();
    
    const char* vertexShaderSource = R"(
        #version 330 core
        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 color;
        
        uniform mat4 mvpMatrix;
        uniform float pointSize;
        
        out vec3 fragColor;
        
        void main() {
            gl_Position = mvpMatrix * vec4(position, 1.0);
            gl_PointSize = pointSize;
            fragColor = color;
        }
    )";
    
    const char* fragmentShaderSource = R"(
        #version 330 core
        in vec3 fragColor;
        out vec4 color;
        
        void main() {
            // Create circular points
            vec2 coord = gl_PointCoord - vec2(0.5);
            if (length(coord) > 0.5)
                discard;
            
            color = vec4(fragColor, 1.0);
        }
    )";
    
    if (!m_pointCloudShader->addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource)) {
        handleOpenGLError("Failed to compile point cloud vertex shader");
        return;
    }
    
    if (!m_pointCloudShader->addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource)) {
        handleOpenGLError("Failed to compile point cloud fragment shader");
        return;
    }
    
    if (!m_pointCloudShader->link()) {
        handleOpenGLError("Failed to link point cloud shader program");
        return;
    }
    
    // Grid/Axes shader (simpler)
    m_gridShader = std::make_unique();
    
    const char* simpleVertexShader = R"(
        #version 330 core
        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 color;
        
        uniform mat4 mvpMatrix;
        
        out vec3 fragColor;
        
        void main() {
            gl_Position = mvpMatrix * vec4(position, 1.0);
            fragColor = color;
        }
    )";
    
    const char* simpleFragmentShader = R"(
        #version 330 core
        in vec3 fragColor;
        out vec4 color;
        
        void main() {
            color = vec4(fragColor, 1.0);
        }
    )";
    
    m_gridShader->addShaderFromSourceCode(QOpenGLShader::Vertex, simpleVertexShader);
    m_gridShader->addShaderFromSourceCode(QOpenGLShader::Fragment, simpleFragmentShader);
    m_gridShader->link();
    
    // Axes shader is the same as grid shader
    m_axesShader = std::make_unique();
    m_axesShader->addShaderFromSourceCode(QOpenGLShader::Vertex, simpleVertexShader);
    m_axesShader->addShaderFromSourceCode(QOpenGLShader::Fragment, simpleFragmentShader);
    m_axesShader->link();
}

void PointCloudViewerWidget::setupBuffers() {
    // Point cloud VAO/VBO
    m_pointCloudVAO.create();
    m_pointCloudVBO.create();
    m_colorVBO.create();
    
    // Grid VAO/VBO
    m_gridVAO.create();
    m_gridVBO.create();
    
    // Axes VAO/VBO
    m_axesVAO.create();
    m_axesVBO.create();
    m_axesColorVBO.create();
}

void PointCloudViewerWidget::paintGL() {
    glClearColor(m_backgroundColor.redF(), m_backgroundColor.greenF(), 
                 m_backgroundColor.blueF(), 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    if (m_buffersNeedUpdate) {
        updatePointCloudBuffers();
        m_buffersNeedUpdate = false;
    }
    
    QMatrix4x4 mvpMatrix = m_camera->viewProjectionMatrix();
    
    // Render grid
    if (m_showGrid) {
        renderGrid();
    }
    
    // Render axes
    if (m_showAxes) {
        renderAxes();
    }
    
    // Render point cloud
    if (!m_pointCloudData.isEmpty()) {
        renderPointCloud();
    }
}

void PointCloudViewerWidget::renderPointCloud() {
    if (!m_pointCloudShader || m_pointCloudData.isEmpty()) return;
    
    m_pointCloudShader->bind();
    m_pointCloudVAO.bind();
    
    QMatrix4x4 mvpMatrix = m_camera->viewProjectionMatrix();
    m_pointCloudShader->setUniformValue("mvpMatrix", mvpMatrix);
    m_pointCloudShader->setUniformValue("pointSize", m_pointSize);
    
    glDrawArrays(GL_POINTS, 0, static_cast(m_pointCloudData.pointCount()));
    
    m_pointCloudVAO.release();
    m_pointCloudShader->release();
}

void PointCloudViewerWidget::setPointCloudData(const PointCloudData& data) {
    m_pointCloudData = data;
    m_buffersNeedUpdate = true;
    
    if (!data.isEmpty()) {
        m_camera->frameData(data.boundingBoxMin, data.boundingBoxMax);
        emit pointCloudLoaded(data.pointCount());
    }
    
    update();
}

void PointCloudViewerWidget::updatePointCloudBuffers() {
    if (m_pointCloudData.isEmpty()) return;
    
    m_pointCloudVAO.bind();
    
    // Update position buffer
    m_pointCloudVBO.bind();
    m_pointCloudVBO.allocate(m_pointCloudData.points.data(), 
                            static_cast(m_pointCloudData.points.size() * sizeof(QVector3D)));
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
    glEnableVertexAttribArray(0);
    
    // Update color buffer
    m_colorVBO.bind();
    m_colorVBO.allocate(m_pointCloudData.colors.data(), 
                       static_cast(m_pointCloudData.colors.size() * sizeof(QVector3D)));
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
    glEnableVertexAttribArray(1);
    
    m_pointCloudVAO.release();
}

void PointCloudViewerWidget::mousePressEvent(QMouseEvent* event) {
    m_lastMousePos = event->pos();
    m_activeMouseButton = event->button();
    setFocus();
}

void PointCloudViewerWidget::mouseMoveEvent(QMouseEvent* event) {
    if (m_activeMouseButton == Qt::NoButton) return;
    
    QPoint delta = event->pos() - m_lastMousePos;
    m_lastMousePos = event->pos();
    
    switch (m_activeMouseButton) {
    case Qt::LeftButton:
        // Orbit
        m_camera->orbit(delta.x(), -delta.y());
        break;
    case Qt::RightButton:
    case Qt::MiddleButton:
        // Pan
        m_camera->pan(-delta.x(), delta.y());
        break;
    default:
        break;
    }
    
    update();
}

void PointCloudViewerWidget::wheelEvent(QWheelEvent* event) {
    float delta = event->angleDelta().y() / 120.0f;
    m_camera->zoom(-delta * 0.1f);
    update();
}

void PointCloudViewerWidget::resizeGL(int width, int height) {
    m_camera->setViewport(width, height);
}

void PointCloudViewerWidget::handleOpenGLError(const QString& operation) {
    GLenum error = glGetError();
    if (error != GL_NO_ERROR) {
        QString errorMsg = QString("%1: OpenGL Error %2").arg(operation).arg(error);
        qWarning() 
#include 
#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"

namespace SceneRegistration {

class LASParser;
class E57Parser;

struct LoadProgress {
    QString fileName;
    size_t pointsLoaded;
    size_t totalPoints;
    bool isComplete;
    QString error;
};

class PointCloudLoadManager : public QObject {
    Q_OBJECT

public:
    explicit PointCloudLoadManager(QObject* parent = nullptr);
    ~PointCloudLoadManager();

    // Load single scan
    void loadScanAsync(int scanId, const QString& filePath);
    
    // Load multiple scans (for cluster viewing)
    void loadScansAsync(const QList& scanIds, const QStringList& filePaths);
    
    // Cancel current loading operation
    void cancelLoading();
    
    // Status
    bool isLoading() const { return m_isLoading; }

signals:
    void pointCloudLoaded(const PointCloudData& data);
    void loadingProgress(const LoadProgress& progress);
    void loadingError(const QString& error);
    void loadingCancelled();

private slots:
    void onLoadingFinished();

private:
    PointCloudData loadSingleFile(const QString& filePath);
    PointCloudData loadMultipleFiles(const QStringList& filePaths);
    
    std::unique_ptr m_lasParser;
    std::unique_ptr m_e57Parser;
    
    QFutureWatcher* m_futureWatcher;
    bool m_isLoading;
};

} // namespace SceneRegistration
```

## LAS File Parser Implementation

**LASParser.h**
```cpp
#pragma once

#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"

namespace SceneRegistration {

struct LASHeader {
    char fileSignature[4];
    uint16_t fileSourceId;
    uint16_t globalEncoding;
    uint32_t numberOfPointRecords;
    uint8_t pointDataRecordFormat;
    uint16_t pointDataRecordLength;
    double xScaleFactor, yScaleFactor, zScaleFactor;
    double xOffset, yOffset, zOffset;
    double maxX, minX, maxY, minY, maxZ, minZ;
    
    bool isValid() const {
        return fileSignature[0] == 'L' && fileSignature[1] == 'A' && 
               fileSignature[2] == 'S' && fileSignature[3] == 'F';
    }
};

class LASParser {
public:
    LASParser();
    ~LASParser();
    
    PointCloudData parseFile(const QString& filePath);
    bool isValidLASFile(const QString& filePath);
    
    // Progress callback
    void setProgressCallback(std::function callback) {
        m_progressCallback = callback;
    }

private:
    bool readHeader(std::ifstream& file, LASHeader& header);
    QVector3D readPoint(std::ifstream& file, const LASHeader& header, uint8_t format);
    QVector3D generateDefaultColor(const QVector3D& point);
    
    std::function m_progressCallback;
    static constexpr size_t PROGRESS_UPDATE_INTERVAL = 100000;
};

} // namespace SceneRegistration
```

**LASParser.cpp**
```cpp
#include "LASParser.h"
#include 
#include 
#include 

namespace SceneRegistration {

LASParser::LASParser() = default;
LASParser::~LASParser() = default;

PointCloudData LASParser::parseFile(const QString& filePath) {
    PointCloudData data;
    
    if (!isValidLASFile(filePath)) {
        qWarning() (&header.pointDataRecordFormat), 1);
    
    file.seekg(98); // Point data record length
    file.read(reinterpret_cast(&header.pointDataRecordLength), 2);
    
    file.seekg(107); // Number of point records
    file.read(reinterpret_cast(&header.numberOfPointRecords), 4);
    
    // Scale factors and offsets
    file.seekg(131);
    file.read(reinterpret_cast(&header.xScaleFactor), 8);
    file.read(reinterpret_cast(&header.yScaleFactor), 8);
    file.read(reinterpret_cast(&header.zScaleFactor), 8);
    file.read(reinterpret_cast(&header.xOffset), 8);
    file.read(reinterpret_cast(&header.yOffset), 8);
    file.read(reinterpret_cast(&header.zOffset), 8);
    
    // Bounding box
    file.read(reinterpret_cast(&header.maxX), 8);
    file.read(reinterpret_cast(&header.minX), 8);
    file.read(reinterpret_cast(&header.maxY), 8);
    file.read(reinterpret_cast(&header.minY), 8);
    file.read(reinterpret_cast(&header.maxZ), 8);
    file.read(reinterpret_cast(&header.minZ), 8);
    
    return true;
}

QVector3D LASParser::readPoint(std::ifstream& file, const LASHeader& header, uint8_t format) {
    // Read X, Y, Z coordinates (first 12 bytes for most formats)
    int32_t x, y, z;
    file.read(reinterpret_cast(&x), 4);
    file.read(reinterpret_cast(&y), 4);
    file.read(reinterpret_cast(&z), 4);
    
    if (file.fail()) {
        return QVector3D();
    }
    
    // Convert to real coordinates
    double realX = x * header.xScaleFactor + header.xOffset;
    double realY = y * header.yScaleFactor + header.yOffset;
    double realZ = z * header.zScaleFactor + header.zOffset;
    
    // Skip remaining point data based on format
    size_t remainingBytes = header.pointDataRecordLength - 12;
    file.seekg(remainingBytes, std::ios::cur);
    
    return QVector3D(static_cast(realX), 
                     static_cast(realY), 
                     static_cast(realZ));
}

QVector3D LASParser::generateDefaultColor(const QVector3D& point) {
    // Generate height-based color gradient
    static float minHeight = std::numeric_limits::max();
    static float maxHeight = std::numeric_limits::lowest();
    
    minHeight = std::min(minHeight, point.y());
    maxHeight = std::max(maxHeight, point.y());
    
    if (maxHeight > minHeight) {
        float normalized = (point.y() - minHeight) / (maxHeight - minHeight);
        return QVector3D(normalized, 1.0f - normalized, 0.5f);
    }
    
    return QVector3D(0.7f, 0.7f, 0.7f); // Default gray
}

bool LASParser::isValidLASFile(const QString& filePath) {
    QFileInfo fileInfo(filePath);
    if (!fileInfo.exists() || !fileInfo.isReadable()) {
        return false;
    }
    
    std::ifstream file(filePath.toStdString(), std::ios::binary);
    if (!file.is_open()) {
        return false;
    }
    
    char signature[4];
    file.read(signature, 4);
    
    return signature[0] == 'L' && signature[1] == 'A' && 
           signature[2] == 'S' && signature[3] == 'F';
}

} // namespace SceneRegistration
```

## E57 Parser Implementation

**E57Parser.h**
```cpp
#pragma once

#include 
#include 
#include "PointCloudViewerWidget.h"

// Forward declarations for E57 library
namespace e57 { 
    class ImageFile; 
    class StructureNode;
    class CompressedVectorNode;
}

namespace SceneRegistration {

class E57Parser {
public:
    E57Parser();
    ~E57Parser();
    
    PointCloudData parseFile(const QString& filePath);
    bool isValidE57File(const QString& filePath);
    
    // Progress callback
    void setProgressCallback(std::function callback) {
        m_progressCallback = callback;
    }

private:
    PointCloudData parseSingleScan(e57::StructureNode& scanNode);
    QVector3D calculateBounds(const std::vector& points, 
                             QVector3D& minBounds, QVector3D& maxBounds);
    
    std::function m_progressCallback;
    static constexpr size_t PROGRESS_UPDATE_INTERVAL = 50000;
    static constexpr size_t MAX_POINTS_PER_READ = 100000;
};

} // namespace SceneRegistration
```

## Main Window Integration

**MainWindow.cpp (Integration Code)**
```cpp
#include "MainWindow.h"
#include "PointCloudViewerWidget.h"
#include "PointCloudLoadManager.h"
#include 
#include 
#include 
#include 
#include 
#include 

void MainWindow::setupPointCloudViewer() {
    // Create the 3D viewer widget
    m_pointCloudViewer = new PointCloudViewerWidget(this);
    
    // Create load manager
    m_loadManager = std::make_unique(this);
    
    // Connect signals
    connect(m_loadManager.get(), &PointCloudLoadManager::pointCloudLoaded,
            m_pointCloudViewer, &PointCloudViewerWidget::setPointCloudData);
    
    connect(m_loadManager.get(), &PointCloudLoadManager::loadingProgress,
            this, &MainWindow::onLoadingProgress);
    
    connect(m_loadManager.get(), &PointCloudLoadManager::loadingError,
            this, &MainWindow::onLoadingError);
    
    connect(m_pointCloudViewer, &PointCloudViewerWidget::pointCloudLoaded,
            this, &MainWindow::onPointCloudDisplayed);
    
    // Setup layout
    QWidget* centralWidget = new QWidget;
    setCentralWidget(centralWidget);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(centralWidget);
    
    // Create splitter for sidebar and viewer
    QSplitter* splitter = new QSplitter(Qt::Horizontal);
    splitter->addWidget(m_sidebarWidget);
    splitter->addWidget(m_pointCloudViewer);
    splitter->setStretchFactor(0, 0); // Sidebar fixed
    splitter->setStretchFactor(1, 1); // Viewer stretches
    
    mainLayout->addWidget(splitter);
    
    // Setup status bar for loading progress
    m_progressBar = new QProgressBar;
    m_progressBar->setVisible(false);
    statusBar()->addPermanentWidget(m_progressBar);
    
    m_statusLabel = new QLabel("Ready");
    statusBar()->addWidget(m_statusLabel);
}

void MainWindow::onViewPointCloudAction(int scanId) {
    // Get scan file path from database
    QString filePath = m_projectManager->getScanFilePath(scanId);
    
    if (filePath.isEmpty()) {
        showError("Cannot load scan", "File path not found in database");
        return;
    }
    
    // Start loading
    m_statusLabel->setText("Loading point cloud...");
    m_progressBar->setVisible(true);
    m_progressBar->setRange(0, 100);
    
    m_loadManager->loadScanAsync(scanId, filePath);
}

void MainWindow::onViewClusterPointClouds(int clusterId) {
    // Get all scan file paths in cluster
    auto scanPaths = m_projectManager->getClusterScanPaths(clusterId);
    
    if (scanPaths.isEmpty()) {
        showError("Cannot load cluster", "No scans found in cluster");
        return;
    }
    
    m_statusLabel->setText(QString("Loading %1 scans...").arg(scanPaths.size()));
    m_progressBar->setVisible(true);
    m_progressBar->setRange(0, 100);
    
    QList scanIds;
    QStringList filePaths;
    for (const auto& [scanId, filePath] : scanPaths) {
        scanIds.append(scanId);
        filePaths.append(filePath);
    }
    
    m_loadManager->loadScansAsync(scanIds, filePaths);
}

void MainWindow::onLoadingProgress(const LoadProgress& progress) {
    if (progress.totalPoints > 0) {
        int percentage = static_cast((progress.pointsLoaded * 100) / progress.totalPoints);
        m_progressBar->setValue(percentage);
        
        m_statusLabel->setText(QString("Loading %1: %2/%3 points")
                              .arg(progress.fileName)
                              .arg(progress.pointsLoaded)
                              .arg(progress.totalPoints));
    }
    
    if (progress.isComplete) {
        m_progressBar->setVisible(false);
        m_statusLabel->setText("Point cloud loaded successfully");
    }
}

void MainWindow::onPointCloudDisplayed(size_t pointCount) {
    m_statusLabel->setText(QString("Displaying %1 points").arg(pointCount));
    
    // Update viewer settings panel if exists
    if (m_viewerSettingsPanel) {
        m_viewerSettingsPanel->updatePointCount(pointCount);
    }
}
```

## CMakeLists.txt Configuration

```cmake
# Find required packages
find_package(Qt6 REQUIRED COMPONENTS Core Widgets OpenGL OpenGLWidgets)
find_package(OpenGL REQUIRED)

# Optional: Find point cloud libraries
find_package(PkgConfig QUIET)
if(PkgConfig_FOUND)
    pkg_check_modules(E57FORMAT QUIET e57format)
endif()

# Main library
add_library(scene_registration_lib
    src/PointCloudViewerWidget.cpp
    src/PointCloudLoadManager.cpp
    src/LASParser.cpp
    src/E57Parser.cpp
    src/MainWindow.cpp
    # ... other source files
)

target_link_libraries(scene_registration_lib
    PUBLIC
    Qt6::Core
    Qt6::Widgets
    Qt6::OpenGL
    Qt6::OpenGLWidgets
    OpenGL::GL
)

# Link E57 library if available
if(E57FORMAT_FOUND)
    target_link_libraries(scene_registration_lib PRIVATE ${E57FORMAT_LIBRARIES})
    target_include_directories(scene_registration_lib PRIVATE ${E57FORMAT_INCLUDE_DIRS})
    target_compile_definitions(scene_registration_lib PRIVATE HAVE_E57FORMAT)
endif()

target_include_directories(scene_registration_lib
    PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)
```

## Test Implementation

**test_point_cloud_viewer.cpp**
```cpp
#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"
#include "LASParser.h"

using namespace SceneRegistration;

class PointCloudViewerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup OpenGL context for testing
        surface = std::make_unique();
        surface->create();
        
        context = std::make_unique();
        context->create();
        context->makeCurrent(surface.get());
        
        viewer = std::make_unique();
    }
    
    void TearDown() override {
        viewer.reset();
        context.reset();
        surface.reset();
    }
    
    PointCloudData createTestPointCloud() {
        PointCloudData data;
        
        // Create a simple cube of points
        for (float x = -1.0f; x  surface;
    std::unique_ptr context;
    std::unique_ptr viewer;
};

TEST_F(PointCloudViewerTest, LoadPointCloudData) {
    // Test Case S3.2.1: Load and display point cloud data
    PointCloudData testData = createTestPointCloud();
    
    EXPECT_FALSE(viewer->hasData());
    
    viewer->setPointCloudData(testData);
    
    EXPECT_TRUE(viewer->hasData());
    EXPECT_EQ(viewer->pointCount(), testData.pointCount());
}

TEST_F(PointCloudViewerTest, CameraControls) {
    // Test Case S3.2.4: Camera control functionality
    Camera3D* camera = viewer->camera();
    
    QMatrix4x4 initialView = camera->viewMatrix();
    
    // Test orbit
    camera->orbit(10.0f, 5.0f);
    EXPECT_NE(camera->viewMatrix(), initialView);
    
    // Test zoom
    camera->zoom(0.1f);
    EXPECT_NE(camera->viewMatrix(), initialView);
    
    // Test pan
    camera->pan(5.0f, 5.0f);
    EXPECT_NE(camera->viewMatrix(), initialView);
}

TEST_F(PointCloudViewerTest, ClearPointCloud) {
    // Test Case S3.2.5: Clear viewer functionality
    PointCloudData testData = createTestPointCloud();
    viewer->setPointCloudData(testData);
    
    EXPECT_TRUE(viewer->hasData());
    
    viewer->clearPointCloud();
    
    EXPECT_FALSE(viewer->hasData());
    EXPECT_EQ(viewer->pointCount(), 0);
}
```

## Key API Information

**Qt6 OpenGL APIs:**
- `QOpenGLWidget`: Main widget for OpenGL rendering
- `QOpenGLShaderProgram`: Shader compilation and linking
- `QOpenGLBuffer` and `QOpenGLVertexArrayObject`: Vertex data management
- `QMatrix4x4`: 3D transformations and camera matrices

**Point Cloud Libraries:**
- **libE57Format**: For reading E57 files with full point data
- **LASlib** or custom parser: For reading LAS files efficiently
- **PCL (Point Cloud Library)**: Alternative comprehensive solution

**Performance Considerations:**
- Use vertex buffer objects (VBO) for efficient GPU memory usage
- Implement level-of-detail (LOD) for large point clouds
- Use instanced rendering for repeated geometry
- Consider point cloud decimation for real-time interaction

## Usage Example

```cpp
// Initialize viewer in main window
PointCloudViewerWidget* viewer = new PointCloudViewerWidget(this);

// Load point cloud data
PointCloudLoadManager loadManager;
connect(&loadManager, &PointCloudLoadManager::pointCloudLoaded,
        viewer, &PointCloudViewerWidget::setPointCloudData);

// Load a LAS file
loadManager.loadScanAsync(1, "/path/to/scan.las");

// Configure viewer settings
viewer->setPointSize(3.0f);
viewer->setShowGrid(true);
viewer->setBackgroundColor(QColor(50, 50, 50));
```

This implementation provides a complete 3D point cloud viewer with OpenGL rendering, camera controls, and support for both LAS and E57 file formats, meeting all Sprint 3.2 requirements for your FARO scene registration software.

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/35208055/79c9d349-d7cd-4af4-bde4-d49529903f20/paste.txt
[2] https://forum.qt.io/topic/156629/checking-installation-and-properly-using-qt6-3-2-platform-plug-in
[3] https://docs.rs/e57-to-las/latest/e57_to_las/fn.convert_file.html
[4] https://stackoverflow.com/questions/77582742/error-while-building-qt6-from-source-using-x86-64-w64-mingw32
[5] https://www.theseus.fi/bitstream/10024/512372/2/Puuronen_Miina.pdf
[6] https://github.com/kuanyingchou/point-cloud-viewer
[7] https://www.scribd.com/document/868522330/Introducing-Qt-6-Learn-To-Build-Fun-Apps-Games-For-Mobile-Desktop-In-C-1st-Ed-Ben-Coepp-download
[8] https://content.e-bookshelf.de/media/reading/L-17398284-e437f75f51.pdf
[9] https://www.qtcentre.org/threads/71044-Show-large-3D-point-clouds-and-meshes-in-a-QML-QtQuick2-application
[10] https://community.khronos.org/t/point-cloud-rendering-artifacts/107260
[11] https://answers.ros.org/question/295527/how-to-control-camera-distance-using-librviz-in-custom-qt-gui/

Based on Sprint 3.2's focus on integrating a basic 3D point cloud viewer with rendering capabilities and camera controls, I'll provide you with a comprehensive implementation guide using Qt6 OpenGL widgets and point cloud parsing libraries.

## Core Architecture Overview

Sprint 3.2 requires three main components: a 3D viewer widget using OpenGL, point cloud data parsers for LAS/E57 files, and camera control systems. Here's the complete implementation:

## Point Cloud Viewer Widget Implementation

**PointCloudViewerWidget.h**
```cpp
#pragma once

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

namespace SceneRegistration {

struct PointCloudData {
    std::vector points;
    std::vector colors;
    QVector3D boundingBoxMin;
    QVector3D boundingBoxMax;
    
    void clear() {
        points.clear();
        colors.clear();
        boundingBoxMin = QVector3D();
        boundingBoxMax = QVector3D();
    }
    
    bool isEmpty() const {
        return points.empty();
    }
    
    size_t pointCount() const {
        return points.size();
    }
};

class Camera3D {
public:
    Camera3D();
    
    void setViewport(int width, int height);
    void frameData(const QVector3D& min, const QVector3D& max);
    
    // Camera controls
    void orbit(float deltaX, float deltaY);
    void pan(float deltaX, float deltaY);
    void zoom(float delta);
    void resetView();
    
    // Matrix access
    QMatrix4x4 viewMatrix() const;
    QMatrix4x4 projectionMatrix() const;
    QMatrix4x4 viewProjectionMatrix() const;
    
private:
    void updateViewMatrix();
    
    QVector3D m_position;
    QVector3D m_target;
    QVector3D m_up;
    float m_distance;
    float m_azimuth;
    float m_elevation;
    
    QMatrix4x4 m_viewMatrix;
    QMatrix4x4 m_projectionMatrix;
    
    int m_viewportWidth;
    int m_viewportHeight;
    float m_fov;
    float m_nearPlane;
    float m_farPlane;
};

class PointCloudViewerWidget : public QOpenGLWidget, protected QOpenGLFunctions {
    Q_OBJECT

public:
    explicit PointCloudViewerWidget(QWidget* parent = nullptr);
    ~PointCloudViewerWidget();

    // Point cloud data management
    void setPointCloudData(const PointCloudData& data);
    void clearPointCloud();
    void addPointCloudData(const PointCloudData& additionalData);
    
    // Rendering settings
    void setPointSize(float size);
    void setBackgroundColor(const QColor& color);
    void setShowGrid(bool show);
    void setShowAxes(bool show);
    
    // Camera access
    Camera3D* camera() { return m_camera.get(); }
    
    // Status
    bool hasData() const { return !m_pointCloudData.isEmpty(); }
    size_t pointCount() const { return m_pointCloudData.pointCount(); }

signals:
    void pointCloudLoaded(size_t pointCount);
    void renderingError(const QString& error);

protected:
    // QOpenGLWidget overrides
    void initializeGL() override;
    void paintGL() override;
    void resizeGL(int width, int height) override;
    
    // Mouse and keyboard events
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    void setupShaders();
    void setupBuffers();
    void updatePointCloudBuffers();
    void renderPointCloud();
    void renderGrid();
    void renderAxes();
    
    void handleOpenGLError(const QString& operation);
    
    // OpenGL resources
    std::unique_ptr m_pointCloudShader;
    std::unique_ptr m_gridShader;
    std::unique_ptr m_axesShader;
    
    QOpenGLVertexArrayObject m_pointCloudVAO;
    QOpenGLBuffer m_pointCloudVBO;
    QOpenGLBuffer m_colorVBO;
    
    QOpenGLVertexArrayObject m_gridVAO;
    QOpenGLBuffer m_gridVBO;
    
    QOpenGLVertexArrayObject m_axesVAO;
    QOpenGLBuffer m_axesVBO;
    QOpenGLBuffer m_axesColorVBO;
    
    // Camera and interaction
    std::unique_ptr m_camera;
    QPoint m_lastMousePos;
    Qt::MouseButton m_activeMouseButton;
    
    // Rendering state
    PointCloudData m_pointCloudData;
    float m_pointSize;
    QColor m_backgroundColor;
    bool m_showGrid;
    bool m_showAxes;
    bool m_buffersNeedUpdate;
    
    // Grid and axes data
    std::vector m_gridVertices;
    std::vector m_axesVertices;
    std::vector m_axesColors;
};

} // namespace SceneRegistration
```

**PointCloudViewerWidget.cpp**
```cpp
#include "PointCloudViewerWidget.h"
#include 
#include 
#include 
#include 
#include 

namespace SceneRegistration {

// Camera3D Implementation
Camera3D::Camera3D()
    : m_position(0, 0, 10)
    , m_target(0, 0, 0)
    , m_up(0, 1, 0)
    , m_distance(10.0f)
    , m_azimuth(0.0f)
    , m_elevation(0.0f)
    , m_viewportWidth(800)
    , m_viewportHeight(600)
    , m_fov(45.0f)
    , m_nearPlane(0.1f)
    , m_farPlane(1000.0f)
{
    updateViewMatrix();
}

void Camera3D::setViewport(int width, int height) {
    m_viewportWidth = width;
    m_viewportHeight = height;
    
    float aspect = static_cast(width) / static_cast(height);
    m_projectionMatrix.setToIdentity();
    m_projectionMatrix.perspective(m_fov, aspect, m_nearPlane, m_farPlane);
}

void Camera3D::frameData(const QVector3D& min, const QVector3D& max) {
    m_target = (min + max) * 0.5f;
    
    QVector3D size = max - min;
    float maxDimension = qMax(qMax(size.x(), size.y()), size.z());
    m_distance = maxDimension * 2.0f;
    
    // Update near/far planes based on data size
    m_nearPlane = maxDimension * 0.001f;
    m_farPlane = maxDimension * 10.0f;
    
    m_azimuth = 45.0f;
    m_elevation = 30.0f;
    
    updateViewMatrix();
    setViewport(m_viewportWidth, m_viewportHeight);
}

void Camera3D::orbit(float deltaX, float deltaY) {
    m_azimuth += deltaX * 0.5f;
    m_elevation += deltaY * 0.5f;
    
    // Clamp elevation to prevent gimbal lock
    m_elevation = qBound(-89.0f, m_elevation, 89.0f);
    
    updateViewMatrix();
}

void Camera3D::pan(float deltaX, float deltaY) {
    QVector3D right = QVector3D::crossProduct(m_target - m_position, m_up).normalized();
    QVector3D up = QVector3D::crossProduct(right, m_target - m_position).normalized();
    
    float panSpeed = m_distance * 0.001f;
    QVector3D offset = (right * deltaX + up * deltaY) * panSpeed;
    
    m_target += offset;
    updateViewMatrix();
}

void Camera3D::zoom(float delta) {
    m_distance *= (1.0f + delta * 0.1f);
    m_distance = qMax(0.1f, m_distance);
    updateViewMatrix();
}

void Camera3D::updateViewMatrix() {
    float azimuthRad = qDegreesToRadians(m_azimuth);
    float elevationRad = qDegreesToRadians(m_elevation);
    
    QVector3D offset(
        m_distance * cos(elevationRad) * cos(azimuthRad),
        m_distance * sin(elevationRad),
        m_distance * cos(elevationRad) * sin(azimuthRad)
    );
    
    m_position = m_target + offset;
    
    m_viewMatrix.setToIdentity();
    m_viewMatrix.lookAt(m_position, m_target, m_up);
}

QMatrix4x4 Camera3D::viewMatrix() const {
    return m_viewMatrix;
}

QMatrix4x4 Camera3D::projectionMatrix() const {
    return m_projectionMatrix;
}

QMatrix4x4 Camera3D::viewProjectionMatrix() const {
    return m_projectionMatrix * m_viewMatrix;
}

// PointCloudViewerWidget Implementation
PointCloudViewerWidget::PointCloudViewerWidget(QWidget* parent)
    : QOpenGLWidget(parent)
    , m_camera(std::make_unique())
    , m_activeMouseButton(Qt::NoButton)
    , m_pointSize(2.0f)
    , m_backgroundColor(QColor(30, 30, 30))
    , m_showGrid(true)
    , m_showAxes(true)
    , m_buffersNeedUpdate(false)
{
    setFocusPolicy(Qt::StrongFocus);
    setMouseTracking(true);
}

PointCloudViewerWidget::~PointCloudViewerWidget() {
    makeCurrent();
    // OpenGL resources are automatically cleaned up
    doneCurrent();
}

void PointCloudViewerWidget::initializeGL() {
    initializeOpenGLFunctions();
    
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_PROGRAM_POINT_SIZE);
    
    setupShaders();
    setupBuffers();
    
    // Setup grid
    const float gridSize = 10.0f;
    const int gridLines = 21;
    const float step = gridSize * 2.0f / (gridLines - 1);
    
    m_gridVertices.clear();
    for (int i = 0; i ();
    
    const char* vertexShaderSource = R"(
        #version 330 core
        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 color;
        
        uniform mat4 mvpMatrix;
        uniform float pointSize;
        
        out vec3 fragColor;
        
        void main() {
            gl_Position = mvpMatrix * vec4(position, 1.0);
            gl_PointSize = pointSize;
            fragColor = color;
        }
    )";
    
    const char* fragmentShaderSource = R"(
        #version 330 core
        in vec3 fragColor;
        out vec4 color;
        
        void main() {
            // Create circular points
            vec2 coord = gl_PointCoord - vec2(0.5);
            if (length(coord) > 0.5)
                discard;
            
            color = vec4(fragColor, 1.0);
        }
    )";
    
    if (!m_pointCloudShader->addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource)) {
        handleOpenGLError("Failed to compile point cloud vertex shader");
        return;
    }
    
    if (!m_pointCloudShader->addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource)) {
        handleOpenGLError("Failed to compile point cloud fragment shader");
        return;
    }
    
    if (!m_pointCloudShader->link()) {
        handleOpenGLError("Failed to link point cloud shader program");
        return;
    }
    
    // Grid/Axes shader (simpler)
    m_gridShader = std::make_unique();
    
    const char* simpleVertexShader = R"(
        #version 330 core
        layout (location = 0) in vec3 position;
        layout (location = 1) in vec3 color;
        
        uniform mat4 mvpMatrix;
        
        out vec3 fragColor;
        
        void main() {
            gl_Position = mvpMatrix * vec4(position, 1.0);
            fragColor = color;
        }
    )";
    
    const char* simpleFragmentShader = R"(
        #version 330 core
        in vec3 fragColor;
        out vec4 color;
        
        void main() {
            color = vec4(fragColor, 1.0);
        }
    )";
    
    m_gridShader->addShaderFromSourceCode(QOpenGLShader::Vertex, simpleVertexShader);
    m_gridShader->addShaderFromSourceCode(QOpenGLShader::Fragment, simpleFragmentShader);
    m_gridShader->link();
    
    // Axes shader is the same as grid shader
    m_axesShader = std::make_unique();
    m_axesShader->addShaderFromSourceCode(QOpenGLShader::Vertex, simpleVertexShader);
    m_axesShader->addShaderFromSourceCode(QOpenGLShader::Fragment, simpleFragmentShader);
    m_axesShader->link();
}

void PointCloudViewerWidget::setupBuffers() {
    // Point cloud VAO/VBO
    m_pointCloudVAO.create();
    m_pointCloudVBO.create();
    m_colorVBO.create();
    
    // Grid VAO/VBO
    m_gridVAO.create();
    m_gridVBO.create();
    
    // Axes VAO/VBO
    m_axesVAO.create();
    m_axesVBO.create();
    m_axesColorVBO.create();
}

void PointCloudViewerWidget::paintGL() {
    glClearColor(m_backgroundColor.redF(), m_backgroundColor.greenF(), 
                 m_backgroundColor.blueF(), 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    if (m_buffersNeedUpdate) {
        updatePointCloudBuffers();
        m_buffersNeedUpdate = false;
    }
    
    QMatrix4x4 mvpMatrix = m_camera->viewProjectionMatrix();
    
    // Render grid
    if (m_showGrid) {
        renderGrid();
    }
    
    // Render axes
    if (m_showAxes) {
        renderAxes();
    }
    
    // Render point cloud
    if (!m_pointCloudData.isEmpty()) {
        renderPointCloud();
    }
}

void PointCloudViewerWidget::renderPointCloud() {
    if (!m_pointCloudShader || m_pointCloudData.isEmpty()) return;
    
    m_pointCloudShader->bind();
    m_pointCloudVAO.bind();
    
    QMatrix4x4 mvpMatrix = m_camera->viewProjectionMatrix();
    m_pointCloudShader->setUniformValue("mvpMatrix", mvpMatrix);
    m_pointCloudShader->setUniformValue("pointSize", m_pointSize);
    
    glDrawArrays(GL_POINTS, 0, static_cast(m_pointCloudData.pointCount()));
    
    m_pointCloudVAO.release();
    m_pointCloudShader->release();
}

void PointCloudViewerWidget::setPointCloudData(const PointCloudData& data) {
    m_pointCloudData = data;
    m_buffersNeedUpdate = true;
    
    if (!data.isEmpty()) {
        m_camera->frameData(data.boundingBoxMin, data.boundingBoxMax);
        emit pointCloudLoaded(data.pointCount());
    }
    
    update();
}

void PointCloudViewerWidget::updatePointCloudBuffers() {
    if (m_pointCloudData.isEmpty()) return;
    
    m_pointCloudVAO.bind();
    
    // Update position buffer
    m_pointCloudVBO.bind();
    m_pointCloudVBO.allocate(m_pointCloudData.points.data(), 
                            static_cast(m_pointCloudData.points.size() * sizeof(QVector3D)));
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
    glEnableVertexAttribArray(0);
    
    // Update color buffer
    m_colorVBO.bind();
    m_colorVBO.allocate(m_pointCloudData.colors.data(), 
                       static_cast(m_pointCloudData.colors.size() * sizeof(QVector3D)));
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
    glEnableVertexAttribArray(1);
    
    m_pointCloudVAO.release();
}

void PointCloudViewerWidget::mousePressEvent(QMouseEvent* event) {
    m_lastMousePos = event->pos();
    m_activeMouseButton = event->button();
    setFocus();
}

void PointCloudViewerWidget::mouseMoveEvent(QMouseEvent* event) {
    if (m_activeMouseButton == Qt::NoButton) return;
    
    QPoint delta = event->pos() - m_lastMousePos;
    m_lastMousePos = event->pos();
    
    switch (m_activeMouseButton) {
    case Qt::LeftButton:
        // Orbit
        m_camera->orbit(delta.x(), -delta.y());
        break;
    case Qt::RightButton:
    case Qt::MiddleButton:
        // Pan
        m_camera->pan(-delta.x(), delta.y());
        break;
    default:
        break;
    }
    
    update();
}

void PointCloudViewerWidget::wheelEvent(QWheelEvent* event) {
    float delta = event->angleDelta().y() / 120.0f;
    m_camera->zoom(-delta * 0.1f);
    update();
}

void PointCloudViewerWidget::resizeGL(int width, int height) {
    m_camera->setViewport(width, height);
}

void PointCloudViewerWidget::handleOpenGLError(const QString& operation) {
    GLenum error = glGetError();
    if (error != GL_NO_ERROR) {
        QString errorMsg = QString("%1: OpenGL Error %2").arg(operation).arg(error);
        qWarning() 
#include 
#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"

namespace SceneRegistration {

class LASParser;
class E57Parser;

struct LoadProgress {
    QString fileName;
    size_t pointsLoaded;
    size_t totalPoints;
    bool isComplete;
    QString error;
};

class PointCloudLoadManager : public QObject {
    Q_OBJECT

public:
    explicit PointCloudLoadManager(QObject* parent = nullptr);
    ~PointCloudLoadManager();

    // Load single scan
    void loadScanAsync(int scanId, const QString& filePath);
    
    // Load multiple scans (for cluster viewing)
    void loadScansAsync(const QList& scanIds, const QStringList& filePaths);
    
    // Cancel current loading operation
    void cancelLoading();
    
    // Status
    bool isLoading() const { return m_isLoading; }

signals:
    void pointCloudLoaded(const PointCloudData& data);
    void loadingProgress(const LoadProgress& progress);
    void loadingError(const QString& error);
    void loadingCancelled();

private slots:
    void onLoadingFinished();

private:
    PointCloudData loadSingleFile(const QString& filePath);
    PointCloudData loadMultipleFiles(const QStringList& filePaths);
    
    std::unique_ptr m_lasParser;
    std::unique_ptr m_e57Parser;
    
    QFutureWatcher* m_futureWatcher;
    bool m_isLoading;
};

} // namespace SceneRegistration
```

## LAS File Parser Implementation

**LASParser.h**
```cpp
#pragma once

#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"

namespace SceneRegistration {

struct LASHeader {
    char fileSignature[4];
    uint16_t fileSourceId;
    uint16_t globalEncoding;
    uint32_t numberOfPointRecords;
    uint8_t pointDataRecordFormat;
    uint16_t pointDataRecordLength;
    double xScaleFactor, yScaleFactor, zScaleFactor;
    double xOffset, yOffset, zOffset;
    double maxX, minX, maxY, minY, maxZ, minZ;
    
    bool isValid() const {
        return fileSignature[0] == 'L' && fileSignature[1] == 'A' && 
               fileSignature[2] == 'S' && fileSignature[3] == 'F';
    }
};

class LASParser {
public:
    LASParser();
    ~LASParser();
    
    PointCloudData parseFile(const QString& filePath);
    bool isValidLASFile(const QString& filePath);
    
    // Progress callback
    void setProgressCallback(std::function callback) {
        m_progressCallback = callback;
    }

private:
    bool readHeader(std::ifstream& file, LASHeader& header);
    QVector3D readPoint(std::ifstream& file, const LASHeader& header, uint8_t format);
    QVector3D generateDefaultColor(const QVector3D& point);
    
    std::function m_progressCallback;
    static constexpr size_t PROGRESS_UPDATE_INTERVAL = 100000;
};

} // namespace SceneRegistration
```

**LASParser.cpp**
```cpp
#include "LASParser.h"
#include 
#include 
#include 

namespace SceneRegistration {

LASParser::LASParser() = default;
LASParser::~LASParser() = default;

PointCloudData LASParser::parseFile(const QString& filePath) {
    PointCloudData data;
    
    if (!isValidLASFile(filePath)) {
        qWarning() (&header.pointDataRecordFormat), 1);
    
    file.seekg(98); // Point data record length
    file.read(reinterpret_cast(&header.pointDataRecordLength), 2);
    
    file.seekg(107); // Number of point records
    file.read(reinterpret_cast(&header.numberOfPointRecords), 4);
    
    // Scale factors and offsets
    file.seekg(131);
    file.read(reinterpret_cast(&header.xScaleFactor), 8);
    file.read(reinterpret_cast(&header.yScaleFactor), 8);
    file.read(reinterpret_cast(&header.zScaleFactor), 8);
    file.read(reinterpret_cast(&header.xOffset), 8);
    file.read(reinterpret_cast(&header.yOffset), 8);
    file.read(reinterpret_cast(&header.zOffset), 8);
    
    // Bounding box
    file.read(reinterpret_cast(&header.maxX), 8);
    file.read(reinterpret_cast(&header.minX), 8);
    file.read(reinterpret_cast(&header.maxY), 8);
    file.read(reinterpret_cast(&header.minY), 8);
    file.read(reinterpret_cast(&header.maxZ), 8);
    file.read(reinterpret_cast(&header.minZ), 8);
    
    return true;
}

QVector3D LASParser::readPoint(std::ifstream& file, const LASHeader& header, uint8_t format) {
    // Read X, Y, Z coordinates (first 12 bytes for most formats)
    int32_t x, y, z;
    file.read(reinterpret_cast(&x), 4);
    file.read(reinterpret_cast(&y), 4);
    file.read(reinterpret_cast(&z), 4);
    
    if (file.fail()) {
        return QVector3D();
    }
    
    // Convert to real coordinates
    double realX = x * header.xScaleFactor + header.xOffset;
    double realY = y * header.yScaleFactor + header.yOffset;
    double realZ = z * header.zScaleFactor + header.zOffset;
    
    // Skip remaining point data based on format
    size_t remainingBytes = header.pointDataRecordLength - 12;
    file.seekg(remainingBytes, std::ios::cur);
    
    return QVector3D(static_cast(realX), 
                     static_cast(realY), 
                     static_cast(realZ));
}

QVector3D LASParser::generateDefaultColor(const QVector3D& point) {
    // Generate height-based color gradient
    static float minHeight = std::numeric_limits::max();
    static float maxHeight = std::numeric_limits::lowest();
    
    minHeight = std::min(minHeight, point.y());
    maxHeight = std::max(maxHeight, point.y());
    
    if (maxHeight > minHeight) {
        float normalized = (point.y() - minHeight) / (maxHeight - minHeight);
        return QVector3D(normalized, 1.0f - normalized, 0.5f);
    }
    
    return QVector3D(0.7f, 0.7f, 0.7f); // Default gray
}

bool LASParser::isValidLASFile(const QString& filePath) {
    QFileInfo fileInfo(filePath);
    if (!fileInfo.exists() || !fileInfo.isReadable()) {
        return false;
    }
    
    std::ifstream file(filePath.toStdString(), std::ios::binary);
    if (!file.is_open()) {
        return false;
    }
    
    char signature[4];
    file.read(signature, 4);
    
    return signature[0] == 'L' && signature[1] == 'A' && 
           signature[2] == 'S' && signature[3] == 'F';
}

} // namespace SceneRegistration
```

## E57 Parser Implementation

**E57Parser.h**
```cpp
#pragma once

#include 
#include 
#include "PointCloudViewerWidget.h"

// Forward declarations for E57 library
namespace e57 { 
    class ImageFile; 
    class StructureNode;
    class CompressedVectorNode;
}

namespace SceneRegistration {

class E57Parser {
public:
    E57Parser();
    ~E57Parser();
    
    PointCloudData parseFile(const QString& filePath);
    bool isValidE57File(const QString& filePath);
    
    // Progress callback
    void setProgressCallback(std::function callback) {
        m_progressCallback = callback;
    }

private:
    PointCloudData parseSingleScan(e57::StructureNode& scanNode);
    QVector3D calculateBounds(const std::vector& points, 
                             QVector3D& minBounds, QVector3D& maxBounds);
    
    std::function m_progressCallback;
    static constexpr size_t PROGRESS_UPDATE_INTERVAL = 50000;
    static constexpr size_t MAX_POINTS_PER_READ = 100000;
};

} // namespace SceneRegistration
```

## Main Window Integration

**MainWindow.cpp (Integration Code)**
```cpp
#include "MainWindow.h"
#include "PointCloudViewerWidget.h"
#include "PointCloudLoadManager.h"
#include 
#include 
#include 
#include 
#include 
#include 

void MainWindow::setupPointCloudViewer() {
    // Create the 3D viewer widget
    m_pointCloudViewer = new PointCloudViewerWidget(this);
    
    // Create load manager
    m_loadManager = std::make_unique(this);
    
    // Connect signals
    connect(m_loadManager.get(), &PointCloudLoadManager::pointCloudLoaded,
            m_pointCloudViewer, &PointCloudViewerWidget::setPointCloudData);
    
    connect(m_loadManager.get(), &PointCloudLoadManager::loadingProgress,
            this, &MainWindow::onLoadingProgress);
    
    connect(m_loadManager.get(), &PointCloudLoadManager::loadingError,
            this, &MainWindow::onLoadingError);
    
    connect(m_pointCloudViewer, &PointCloudViewerWidget::pointCloudLoaded,
            this, &MainWindow::onPointCloudDisplayed);
    
    // Setup layout
    QWidget* centralWidget = new QWidget;
    setCentralWidget(centralWidget);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(centralWidget);
    
    // Create splitter for sidebar and viewer
    QSplitter* splitter = new QSplitter(Qt::Horizontal);
    splitter->addWidget(m_sidebarWidget);
    splitter->addWidget(m_pointCloudViewer);
    splitter->setStretchFactor(0, 0); // Sidebar fixed
    splitter->setStretchFactor(1, 1); // Viewer stretches
    
    mainLayout->addWidget(splitter);
    
    // Setup status bar for loading progress
    m_progressBar = new QProgressBar;
    m_progressBar->setVisible(false);
    statusBar()->addPermanentWidget(m_progressBar);
    
    m_statusLabel = new QLabel("Ready");
    statusBar()->addWidget(m_statusLabel);
}

void MainWindow::onViewPointCloudAction(int scanId) {
    // Get scan file path from database
    QString filePath = m_projectManager->getScanFilePath(scanId);
    
    if (filePath.isEmpty()) {
        showError("Cannot load scan", "File path not found in database");
        return;
    }
    
    // Start loading
    m_statusLabel->setText("Loading point cloud...");
    m_progressBar->setVisible(true);
    m_progressBar->setRange(0, 100);
    
    m_loadManager->loadScanAsync(scanId, filePath);
}

void MainWindow::onViewClusterPointClouds(int clusterId) {
    // Get all scan file paths in cluster
    auto scanPaths = m_projectManager->getClusterScanPaths(clusterId);
    
    if (scanPaths.isEmpty()) {
        showError("Cannot load cluster", "No scans found in cluster");
        return;
    }
    
    m_statusLabel->setText(QString("Loading %1 scans...").arg(scanPaths.size()));
    m_progressBar->setVisible(true);
    m_progressBar->setRange(0, 100);
    
    QList scanIds;
    QStringList filePaths;
    for (const auto& [scanId, filePath] : scanPaths) {
        scanIds.append(scanId);
        filePaths.append(filePath);
    }
    
    m_loadManager->loadScansAsync(scanIds, filePaths);
}

void MainWindow::onLoadingProgress(const LoadProgress& progress) {
    if (progress.totalPoints > 0) {
        int percentage = static_cast((progress.pointsLoaded * 100) / progress.totalPoints);
        m_progressBar->setValue(percentage);
        
        m_statusLabel->setText(QString("Loading %1: %2/%3 points")
                              .arg(progress.fileName)
                              .arg(progress.pointsLoaded)
                              .arg(progress.totalPoints));
    }
    
    if (progress.isComplete) {
        m_progressBar->setVisible(false);
        m_statusLabel->setText("Point cloud loaded successfully");
    }
}

void MainWindow::onPointCloudDisplayed(size_t pointCount) {
    m_statusLabel->setText(QString("Displaying %1 points").arg(pointCount));
    
    // Update viewer settings panel if exists
    if (m_viewerSettingsPanel) {
        m_viewerSettingsPanel->updatePointCount(pointCount);
    }
}
```

## CMakeLists.txt Configuration

```cmake
# Find required packages
find_package(Qt6 REQUIRED COMPONENTS Core Widgets OpenGL OpenGLWidgets)
find_package(OpenGL REQUIRED)

# Optional: Find point cloud libraries
find_package(PkgConfig QUIET)
if(PkgConfig_FOUND)
    pkg_check_modules(E57FORMAT QUIET e57format)
endif()

# Main library
add_library(scene_registration_lib
    src/PointCloudViewerWidget.cpp
    src/PointCloudLoadManager.cpp
    src/LASParser.cpp
    src/E57Parser.cpp
    src/MainWindow.cpp
    # ... other source files
)

target_link_libraries(scene_registration_lib
    PUBLIC
    Qt6::Core
    Qt6::Widgets
    Qt6::OpenGL
    Qt6::OpenGLWidgets
    OpenGL::GL
)

# Link E57 library if available
if(E57FORMAT_FOUND)
    target_link_libraries(scene_registration_lib PRIVATE ${E57FORMAT_LIBRARIES})
    target_include_directories(scene_registration_lib PRIVATE ${E57FORMAT_INCLUDE_DIRS})
    target_compile_definitions(scene_registration_lib PRIVATE HAVE_E57FORMAT)
endif()

target_include_directories(scene_registration_lib
    PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)
```

## Test Implementation

**test_point_cloud_viewer.cpp**
```cpp
#include 
#include 
#include 
#include 
#include "PointCloudViewerWidget.h"
#include "LASParser.h"

using namespace SceneRegistration;

class PointCloudViewerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup OpenGL context for testing
        surface = std::make_unique();
        surface->create();
        
        context = std::make_unique();
        context->create();
        context->makeCurrent(surface.get());
        
        viewer = std::make_unique();
    }
    
    void TearDown() override {
        viewer.reset();
        context.reset();
        surface.reset();
    }
    
    PointCloudData createTestPointCloud() {
        PointCloudData data;
        
        // Create a simple cube of points
        for (float x = -1.0f; x  surface;
    std::unique_ptr context;
    std::unique_ptr viewer;
};

TEST_F(PointCloudViewerTest, LoadPointCloudData) {
    // Test Case S3.2.1: Load and display point cloud data
    PointCloudData testData = createTestPointCloud();
    
    EXPECT_FALSE(viewer->hasData());
    
    viewer->setPointCloudData(testData);
    
    EXPECT_TRUE(viewer->hasData());
    EXPECT_EQ(viewer->pointCount(), testData.pointCount());
}

TEST_F(PointCloudViewerTest, CameraControls) {
    // Test Case S3.2.4: Camera control functionality
    Camera3D* camera = viewer->camera();
    
    QMatrix4x4 initialView = camera->viewMatrix();
    
    // Test orbit
    camera->orbit(10.0f, 5.0f);
    EXPECT_NE(camera->viewMatrix(), initialView);
    
    // Test zoom
    camera->zoom(0.1f);
    EXPECT_NE(camera->viewMatrix(), initialView);
    
    // Test pan
    camera->pan(5.0f, 5.0f);
    EXPECT_NE(camera->viewMatrix(), initialView);
}

TEST_F(PointCloudViewerTest, ClearPointCloud) {
    // Test Case S3.2.5: Clear viewer functionality
    PointCloudData testData = createTestPointCloud();
    viewer->setPointCloudData(testData);
    
    EXPECT_TRUE(viewer->hasData());
    
    viewer->clearPointCloud();
    
    EXPECT_FALSE(viewer->hasData());
    EXPECT_EQ(viewer->pointCount(), 0);
}
```

## Key API Information

**Qt6 OpenGL APIs:**
- `QOpenGLWidget`: Main widget for OpenGL rendering
- `QOpenGLShaderProgram`: Shader compilation and linking
- `QOpenGLBuffer` and `QOpenGLVertexArrayObject`: Vertex data management
- `QMatrix4x4`: 3D transformations and camera matrices

**Point Cloud Libraries:**
- **libE57Format**: For reading E57 files with full point data
- **LASlib** or custom parser: For reading LAS files efficiently
- **PCL (Point Cloud Library)**: Alternative comprehensive solution

**Performance Considerations:**
- Use vertex buffer objects (VBO) for efficient GPU memory usage
- Implement level-of-detail (LOD) for large point clouds
- Use instanced rendering for repeated geometry
- Consider point cloud decimation for real-time interaction

## Usage Example

```cpp
// Initialize viewer in main window
PointCloudViewerWidget* viewer = new PointCloudViewerWidget(this);

// Load point cloud data
PointCloudLoadManager loadManager;
connect(&loadManager, &PointCloudLoadManager::pointCloudLoaded,
        viewer, &PointCloudViewerWidget::setPointCloudData);

// Load a LAS file
loadManager.loadScanAsync(1, "/path/to/scan.las");

// Configure viewer settings
viewer->setPointSize(3.0f);
viewer->setShowGrid(true);
viewer->setBackgroundColor(QColor(50, 50, 50));
```

This implementation provides a complete 3D point cloud viewer with OpenGL rendering, camera controls, and support for both LAS and E57 file formats, meeting all Sprint 3.2 requirements for your FARO scene registration software.

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/35208055/79c9d349-d7cd-4af4-bde4-d49529903f20/paste.txt
[2] https://forum.qt.io/topic/156629/checking-installation-and-properly-using-qt6-3-2-platform-plug-in
[3] https://docs.rs/e57-to-las/latest/e57_to_las/fn.convert_file.html
[4] https://stackoverflow.com/questions/77582742/error-while-building-qt6-from-source-using-x86-64-w64-mingw32
[5] https://www.theseus.fi/bitstream/10024/512372/2/Puuronen_Miina.pdf
[6] https://github.com/kuanyingchou/point-cloud-viewer
[7] https://www.scribd.com/document/868522330/Introducing-Qt-6-Learn-To-Build-Fun-Apps-Games-For-Mobile-Desktop-In-C-1st-Ed-Ben-Coepp-download
[8] https://content.e-bookshelf.de/media/reading/L-17398284-e437f75f51.pdf
[9] https://www.qtcentre.org/threads/71044-Show-large-3D-point-clouds-and-meshes-in-a-QML-QtQuick2-application
[10] https://community.khronos.org/t/point-cloud-rendering-artifacts/107260
[11] https://answers.ros.org/question/295527/how-to-control-camera-distance-using-librviz-in-custom-qt-gui/