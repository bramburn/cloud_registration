Backlog: Sprint 3 - Poisson Disk & Random Sampling Implementation
Introduction

This document outlines the detailed backlog for Sprint 3: "Poisson Disk & Random Sampling Implementation." This sprint represents a significant expansion of the point cloud optimization capabilities within the FARO Scene Registration Software, directly building upon the foundational work established in Sprint 1 (Settings Panel & Core Integration) and the initial subsampling capabilities introduced in Sprint 2 (Voxel Grid Subsampling). While Voxel Grid provides a useful, uniform decimation, this sprint aims to diversify the available tools, recognizing that different tasks require different types of data reduction.

The primary objective of this sprint is to introduce two distinct yet complementary subsampling methods: Poisson Disk Sampling and Random Sampling. Poisson Disk Sampling is a sophisticated technique designed to produce a visually uniform and spatially separated point distribution. This makes it exceptionally well-suited for high-quality rendering, generating simplified meshes for visualization, or preparing data for advanced analysis algorithms that perform optimally with evenly distributed points, avoiding the visual "clumping" or "holes" that can occur with simpler methods. Its output is aesthetically pleasing and geometrically consistent. In contrast, Random Sampling will offer the fastest, albeit least intelligent, method for point cloud reduction. While it does not guarantee spatial uniformity or feature preservation, its unparalleled speed makes it an ideal choice for very quick, low-fidelity previews of extremely large datasets, allowing users to rapidly inspect file contents without significant waiting times. This sprint will involve the meticulous development of the core filtering logic for both new methods within dedicated, reusable C++ classes, the seamless integration of their specific user interface controls into the existing settings panel (developed in Sprint 1), and the necessary updates to the file parsing workflow to dynamically apply these new methods based on user selection, ensuring a flexible and powerful user experience.
User Stories

    User Story 1: As a user, I want to apply Poisson Disk subsampling to LAS files, so I can achieve a visually uniform and spatially separated point cloud.

        Description: This user story introduces Poisson Disk subsampling, a highly valuable technique for generating a visually pleasing and spatially uniform distribution of points from a dense point cloud. Unlike simpler methods like Voxel Grid, which quantize space into a rigid grid, Poisson Disk sampling ensures that no two points in the resulting subsampled cloud are closer than a specified minimumRadius. This property is crucial because it inherently prevents points from clumping together in dense areas while still ensuring adequate coverage in sparser regions, leading to a much more natural-looking and evenly spread downsampled cloud. This characteristic makes it particularly valuable for high-quality visualizations where aesthetic appeal and uniform density are paramount, for simplified mesh generation where triangles should be well-formed, or for preparing data for advanced analysis algorithms (e.g., surface reconstruction, normal estimation) that are sensitive to point density variations and benefit from a more regular point distribution. Users will gain fine-grained control over the sampling process by configuring the minimumRadius (directly impacting the output density and visual separation) and the candidatePoints (influencing the algorithm's thoroughness in finding new points).

        Actions to Undertake:

            Create PoissonDiskSampler Class: This is a major development task. A new, self-contained C++ class named PoissonDiskSampler will be designed and implemented. This class will encapsulate the sophisticated geometric logic required for Poisson Disk sampling. Its primary public method, filter(), will be designed to accept a constant reference to a std::vector<float> representing the input point cloud (where points are typically stored as XYZXYZ... or XYZRGBXYZRGB...). Crucially, it will also take a const LoadingSettings& object, from which it will extract the minimumRadius (the guaranteed minimum Euclidean distance between any two output points) and candidatePoints (the number of attempts to find a new point around an existing one). The filter() method will then return a new std::vector<float> containing the reduced, subsampled point cloud. The internal implementation will involve:

                Bounding Box Calculation: First, accurately calculate the bounding box of the entire input point cloud. This defines the spatial extent of the sampling grid and is essential for normalizing coordinates or setting up acceleration structures.

                Spatial Acceleration Structure: For efficient nearest-neighbor queries (critical for checking the minimumRadius constraint), a spatial acceleration structure will be implemented. For smaller datasets, a simple 3D grid (similar to Voxel Grid, but used for lookup, not reduction) or a k-d tree could be considered. For larger datasets, a more optimized approach might be necessary. This structure will quickly identify points within the minimumRadius of a candidate point.

                Active List Initialization: The algorithm typically starts by placing an initial random point within the bounding box into an "active list" and adding it to the output point set.

                Iterative Point Generation: The core of the algorithm involves an iterative loop:

                    Pick a random point from the "active list."

                    Generate candidatePoints number of random candidate points within a ring (or spherical shell) around the picked point, with an inner radius of minimumRadius and an outer radius of 2 * minimumRadius.

                    For each candidate point, use the spatial acceleration structure to check if it violates the minimumRadius constraint (i.e., if there's already an existing point within minimumRadius of the candidate).

                    If a valid candidate is found (no violation), add it to the output point set and to the "active list."

                    If no valid candidate is found after candidatePoints attempts, remove the picked point from the "active list."

                The loop continues until the active list is empty.

                Random Number Generation: Proper seeding and usage of std::random_device and std::mt19937 will ensure high-quality, non-deterministic random numbers for point generation.

            Update LoadingSettings and LoadingSettingsDialog:

                src/loadingsettings.h Modification: The LoadingMethod enum will be extended to include LoadingMethod::PoissonDisk. The QVariantMap parameters within the LoadingSettings struct will be updated to store the new Poisson Disk specific configurations: a double for "minimumRadius" and an int for "candidatePoints". This ensures the settings object can correctly carry these parameters.

                src/loadingsettingsdialog.h and src/loadingsettingsdialog.cpp Modification: These files will be updated to dynamically add and manage the UI controls for the new Poisson Disk parameters. When LoadingMethod::PoissonDisk is selected in the main method QComboBox:

                    A QDoubleSpinBox labeled "Minimum Radius" will appear. It will be configured with a sensible range (e.g., 0.01m for very dense, up to 10.0m for very sparse output) and appropriate decimal precision (e.g., 2-3 decimal places). A clear, descriptive tooltip will be added: "Defines the minimum guaranteed distance between any two points in the subsampled cloud. A larger radius results in fewer, more spaced-out points, ideal for coarser visualizations."

                    A QSpinBox labeled "Candidate Points" will appear. It will be configured with a range (e.g., 10 to 50, as higher values increase computation time but lead to denser, more complete sampling) and a tooltip: "The number of attempts to find a new valid point around an existing one. Higher values produce a more uniform and denser sampling but increase processing time."

                    The LoadingSettingsDialog::onMethodChanged slot will be enhanced to correctly handle the visibility of these controls, ensuring they are only displayed when "Poisson Disk" is the active selection and hidden for other methods.

                QSettings Integration: The saveSettings() and loadSettings() methods within LoadingSettingsDialog.cpp will be meticulously updated to correctly store and retrieve the "minimumRadius" and "candidatePoints" parameters using Qt's QSettings mechanism. This guarantees that these user preferences persist across application launches, providing a consistent user experience.

            Integrate PoissonDiskSampler into LasParser:

                src/lasparser.h and src/lasparser.cpp Modification: The core LasParser::parse() method will be modified to conditionally incorporate the PoissonDiskSampler. After the initial full point data has been read from the LAS file into a temporary std::vector<float> (as Poisson Disk typically operates on the raw data), a new conditional check will be added: if (settings.method == LoadingMethod::PoissonDisk).

                If this condition evaluates to true, an instance of PoissonDiskSampler will be created, and its filter() method will be invoked. The raw point data and the relevant LoadingSettings parameters will be passed as arguments.

                Memory Management: Following the successful return of the subsampled data from PoissonDiskSampler::filter(), the original, larger std::vector<float> containing the full point data will be explicitly cleared and its memory capacity released (e.g., using std::vector<float>().swap(originalPointsVector); or originalPointsVector.clear(); originalPointsVector.shrink_to_fit();) to minimize peak memory consumption during the overall loading process. The LasParser::parse() method will then return the much smaller, subsampled std::vector<float> for rendering.

            Update QProgressDialog: To provide clear and granular feedback to the user, the QProgressDialog (which is managed by MainWindow and updated by LasParser via signals) will be enhanced. After the initial "Reading Points..." phase (which can be a significant portion of the load for large files), a new, distinct progress message, "Applying Poisson Disk Filter...", will be displayed during the execution of the PoissonDiskSampler. This specific message helps the user understand the current processing stage and manages expectations regarding the time taken for the often computationally intensive subsampling step. The percentage completion for this phase will also be accurately updated.

        References between Files:

            New files: src/poissondisksampler.h (declares the PoissonDiskSampler class and its interface) and src/poissondisksampler.cpp (implements the detailed Poisson Disk sampling algorithm). These are crucial new components.

            src/loadingsettings.h: This file is updated to define the new LoadingMethod::PoissonDisk enum value and to provide the structure for storing its minimumRadius and candidatePoints parameters within the QVariantMap.

            src/loadingsettingsdialog.h & src/loadingsettingsdialog.cpp: These files are modified to incorporate the UI elements (QDoubleSpinBox, QSpinBox) for the Poisson Disk parameters and to manage their dynamic visibility and persistence via QSettings.

            src/lasparser.h & src/lasparser.cpp: These files are central to the integration. LasParser's parse() method will be updated to conditionally invoke the PoissonDiskSampler and handle the resulting subsampled data.

            src/mainwindow.cpp: This file will be updated to manage the QProgressDialog messages, displaying the new "Applying Poisson Disk Filter..." stage.

            tests/test_poissondisksampler.cpp: This is a new unit test file specifically dedicated to thoroughly testing the PoissonDiskSampler class in isolation, ensuring its algorithmic correctness, particularly the minimum distance property and spatial uniformity.

        Acceptance Criteria:

            UI Integration: The "Point Cloud Loading Settings" dialog must now prominently feature a new option labeled "Poisson Disk" within its method selection control (e.g., QComboBox). This option should be clearly distinguishable from other methods.

            Dynamic Parameter Controls: When the "Poisson Disk" method is actively selected, two specific UI controls must dynamically appear in the settings dialog: a QDoubleSpinBox for "Minimum Radius" (with a functional range of 0.01m to 10.0m, accurate decimal precision, and a helpful tooltip explaining its impact on point density and visual separation) and a QSpinBox for "Candidate Points" (with a functional range of 10 to 50, and its own clear tooltip explaining its role in sampling thoroughness). These controls must correctly hide when any other loading method is chosen, maintaining a clean UI.

            Functional Subsampling: Loading any valid LAS file with the "Poisson Disk" method selected must successfully apply the subsampling algorithm. This will be evidenced by a measurable reduction in the total number of points loaded into the PointCloudViewerWidget compared to a "Full Load" of the same file.

            Visual Uniformity and Separation: The resulting subsampled point cloud, when rendered in the PointCloudViewerWidget, must appear visually uniform, without noticeable clumping of points in dense areas or large, unnatural gaps in sparser regions. A visual inspection should confirm that points are well-separated according to the minimumRadius.

            Parameter Impact: Adjusting the "Minimum Radius" parameter (e.g., increasing it from 0.1m to 0.5m) must demonstrably alter the output point count, with larger radii resulting in a more significant reduction in points and greater visual separation. Similarly, increasing "Candidate Points" should lead to a denser, more complete (though still separated) sampling.

            Progress Feedback: During the loading process for the "Poisson Disk" method, the QProgressDialog must accurately display distinct progress messages. This includes an initial "Reading Points..." phase, followed by a clear "Applying Poisson Disk Filter..." message during the subsampling computation. The progress bar should continue to update during this phase.

            Settings Persistence: The user's chosen "Poisson Disk" method and its specific configured values for "Minimum Radius" and "Candidate Points" must be correctly saved to QSettings and persist across application restarts, ensuring that the preferences are automatically loaded the next time the application is launched.

            Unit Test Success: All newly created unit tests for the PoissonDiskSampler class (in tests/test_poissondisksampler.cpp) must pass successfully, confirming the algorithmic correctness and robustness of the Poisson Disk implementation, particularly its adherence to the minimum distance property and its ability to produce spatially uniform distributions across various input scenarios.

        Testing Plan:

            Test Case 1: Verify Poisson Disk UI Controls and Persistence (Manual UI Test)

                Test Data: N/A (UI interaction only).

                Expected Result:

                    Launch the application.

                    Open "Loading Settings..." from the "File" menu.

                    Select "Poisson Disk" from the method dropdown. Verify that "Minimum Radius" (QDoubleSpinBox) and "Candidate Points" (QSpinBox) controls become visible and are pre-populated with default values.

                    Adjust "Minimum Radius" to 0.5m and "Candidate Points" to 30.

                    Click "OK" to save settings and close the dialog.

                    Completely close the application.

                    Relaunch the application and reopen "Loading Settings...".

                    Verify that "Poisson Disk" is still selected as the default method, and the "Minimum Radius" and "Candidate Points" parameters are correctly set to 0.5m and 30, respectively.

                Testing Tool: Manual UI testing, visual inspection.

            Test Case 2: Load small_dense.las with Poisson Disk (Various Parameters) (Manual UI Test & Visual Inspection)

                Test Data: small_dense.las (a small, valid LAS file with a known, dense, and relatively uniform point distribution, e.g., a scanned sphere or cube).

                Expected Result:

                    Scenario A (Fine Sampling): Load with "Minimum Radius" 0.1m, "Candidate Points" 20. The point count in the status bar should be significantly reduced compared to "Full Load". The point cloud should appear visually dense, uniform, and points should be clearly separated.

                    Scenario B (Coarse Sampling): Load with "Minimum Radius" 0.5m, "Candidate Points" 20. The point count should be further reduced compared to Scenario A, and the visual density should be lower, but still uniform with clear point separation.

                    Scenario C (High Candidates): Load with "Minimum Radius" 0.1m, "Candidate Points" 50. The point count should be slightly higher than Scenario A, indicating a more thorough sampling, but still maintaining the minimum distance.

                    In all scenarios, the QProgressDialog must display "Applying Poisson Disk Filter..." during the subsampling phase.

                Testing Tool: Manual UI testing, visual inspection of the PointCloudViewerWidget (zooming in to verify point separation), verification of point count in the status bar.

            Test Case 3: Load large_dense.las with Poisson Disk (Performance Test) (Manual UI Test, Stopwatch, System Monitor)

                Test Data: large_dense.las (a large, dense LAS file, e.g., 500MB+ or 1GB+).

                Expected Result:

                    The loading time for large_dense.las with Poisson Disk (e.g., Minimum Radius 0.5m, Candidate Points 30) should be significantly faster (aim for 2x-8x speedup) than loading the same file with "Full Load".

                    Peak memory usage observed via System Monitor should be substantially lower than during a "Full Load" of the same file.

                    The UI should remain responsive throughout the loading process, with no freezing or significant lag.

                    The QProgressDialog should accurately reflect the "Reading Points..." and "Applying Poisson Disk Filter..." stages, with smooth progress updates.

                Testing Tool: Manual UI testing, using a stopwatch to measure load times, and System Monitor (e.g., Windows Task Manager, htop on Linux) to observe real-time memory and CPU utilization.

            Test Case 4: PoissonDiskSampler Unit Tests - Basic Functionality (Google Test)

                Test Data:

                    An empty std::vector<float> as input.

                    A std::vector<float> containing only a single point.

                    A std::vector<float> with points perfectly aligned on a grid, designed to test minimum distance adherence.

                    A LoadingSettings object where minimumRadius is set to 0.0 (an invalid input, should be handled gracefully).

                Expected Result:

                    An empty input vector should result in an empty output vector.

                    A single point input should result in a single point output (if minimumRadius allows).

                    For the grid test, the output point count should be consistent with the minimumRadius and the points should be correctly separated.

                    minimumRadius = 0.0 should either throw an exception, return the original points, or log an error, depending on the chosen robust handling strategy.

                Testing Tool: Google Test (tests/test_poissondisksampler.cpp).

            Test Case 5: PoissonDiskSampler Unit Tests - Minimum Distance Verification (Google Test)

                Test Data: A std::vector<float> containing a dense cluster of points where some are very close to each other, combined with a LoadingSettings object specifying a minimumRadius (e.g., 0.1m).

                Expected Result: A unit test should iterate through all pairs of points in the output std::vector<float> from PoissonDiskSampler::filter() and verify that the Euclidean distance between any two points is greater than or equal to the specified minimumRadius (allowing for minor floating-point precision errors).

                Testing Tool: Google Test (tests/test_poissondisksampler.cpp).

    User Story 2: As a user, I want to apply Random subsampling to LAS files, so I can quickly reduce point count for very fast previews.

        Description: This user story introduces Random subsampling, which stands as the simplest, fastest, and most straightforward method for point cloud reduction. While it does not incorporate any sophisticated logic to preserve spatial structure, avoid point clumping, or prioritize features, its unparalleled speed makes it uniquely ideal for specific use cases. Primarily, it is designed for very quick, low-fidelity previews of extremely large datasets. This allows users to rapidly inspect the general spatial extent and approximate density of a file's contents without enduring long loading times or consuming excessive memory. The user's control is simplified to specifying a keepPercentage of points to retain from the original dataset, making it a clear and direct trade-off between loading speed and the visual density of the preview. This method is perfect when a rough visual representation is sufficient, and computational efficiency is the absolute highest priority.

        Actions to Undertake:

            Create RandomSampler Class: Develop a new, standalone C++ class named RandomSampler. This class will implement the basic Random subsampling algorithm. Its primary public method, filter(), will accept a const std::vector<float>& representing the input point cloud and a const LoadingSettings& object from which it extracts the keepPercentage parameter (the desired percentage of points to retain). It will return a new std::vector<float> containing the randomly selected points. The internal implementation will involve:

                Random Selection: The most straightforward approach is to iterate through the input point cloud and, for each point, decide (based on a random number generation and the keepPercentage) whether to include it in the output. Alternatively, for better performance on very large datasets, a strategy involving shuffling a subset of indices or directly sampling indices could be used.

                Proper Seeding: Crucially, ensuring proper seeding of the random number generator (std::random_device for non-determinism, and std::mt19937 for the actual generation) is vital to prevent repetitive or predictable sampling patterns across different runs.

                Efficiency: The implementation should prioritize speed, avoiding complex computations or data structures that would negate the primary benefit of this method.

            Update LoadingSettings and LoadingSettingsDialog:

                src/loadingsettings.h Modification: The LoadingMethod enum will be extended to include LoadingMethod::RandomSampling. The QVariantMap parameters within the LoadingSettings struct will be updated to define and store a new key: "keepPercentage" (as an int or double).

                src/loadingsettingsdialog.h and src/loadingsettingsdialog.cpp Modification: These files will be updated to dynamically add and manage the UI controls for the new Random Sampling parameter. When LoadingMethod::RandomSampling is selected in the main method QComboBox:

                    A QSlider labeled "Keep Percentage" will appear, accompanied by a QSpinBox or QLabel to display its exact numerical value. It will be configured with a sensible range (e.g., 1% to 50% to ensure significant reduction) and a tooltip: "The percentage of original points to randomly keep. Lower values result in faster loading and less memory, but also lower detail."

                    The LoadingSettingsDialog::onMethodChanged slot will be enhanced to correctly handle the visibility of this control, ensuring it is only shown when "Random Sampling" is selected and hidden for other methods.

                QSettings Integration: The saveSettings() and loadSettings() methods within LoadingSettingsDialog.cpp will be updated to correctly store and retrieve the "keepPercentage" parameter using QSettings, ensuring its persistence across application launches.

            Integrate RandomSampler into LasParser:

                src/lasparser.h and src/lasparser.cpp Modification: The core LasParser::parse() method will be modified to conditionally incorporate the RandomSampler. After the initial full point data has been read from the LAS file into a temporary std::vector<float>, a new conditional check will be added: if (settings.method == LoadingMethod::RandomSampling).

                If this condition evaluates to true, an instance of RandomSampler will be created, and its filter() method will be invoked, passing the raw point data and the relevant LoadingSettings parameters.

                Memory Management: Similar to other subsampling methods, after the RandomSampler returns the subsampled data, the original, larger std::vector<float> containing the full point data will be explicitly cleared and its memory capacity released to minimize peak memory consumption. The LasParser::parse() method will then return the much smaller, subsampled std::vector<float>.

            Update QProgressDialog: To provide clear and granular feedback to the user, the QProgressDialog will be enhanced. After the initial "Reading Points..." phase, a new, distinct progress message, "Applying Random Filter...", will be displayed during the execution of the RandomSampler. This specific message helps the user understand the current processing stage and manages expectations regarding the very rapid subsampling step. The percentage completion for this phase will also be accurately updated.

        References between Files:

            New files: src/randomsampler.h (declares the RandomSampler class) and src/randomsampler.cpp (implements the random sampling algorithm). These are new components.

            src/loadingsettings.h: Updated with new enum value and parameter key.

            src/loadingsettingsdialog.h & src/loadingsettingsdialog.cpp: UI and logic for new settings.

            src/lasparser.h & src/lasparser.cpp: Integration of RandomSampler and conditional parsing logic.

            src/mainwindow.cpp: Updates to QProgressDialog messages.

            tests/test_randomsampler.cpp: New unit test file.

        Acceptance Criteria:

            UI Integration: The "Point Cloud Loading Settings" dialog must now prominently feature a new option labeled "Random Sampling" within its method selection control (e.g., QComboBox).

            Dynamic Parameter Controls: When the "Random Sampling" method is actively selected, a specific UI control must dynamically appear: a QSlider labeled "Keep Percentage" (with an accompanying QSpinBox or QLabel to display its exact value). It will be configured with a functional range of 1% to 50% and a clear tooltip explaining its impact on point count and visual fidelity. This control must correctly hide when any other loading method is chosen.

            Functional Subsampling: Loading any valid LAS file with the "Random Sampling" method selected must successfully apply the subsampling algorithm, resulting in a significantly reduced point count. The output point count must be approximately equal to the specified keepPercentage of the original total point count.

            Parameter Impact: Changing the "Keep Percentage" parameter (e.g., from 10% to 50%) must demonstrably alter the output point count, with higher percentages resulting in more points.

            Progress Feedback: During the loading process for the "Random Sampling" method, the QProgressDialog must accurately display distinct progress messages, including "Reading Points..." followed by a clear "Applying Random Filter..." message during the subsampling computation. The progress bar should update rapidly during this phase.

            Settings Persistence: The user's chosen "Random Sampling" method and its specific configured "Keep Percentage" value must be correctly saved to QSettings and persist across application restarts, ensuring that the preferences are automatically loaded the next time the application is launched.

            Unit Test Success: All newly created unit tests for the RandomSampler class (in tests/test_randomsampler.cpp) must pass successfully, confirming the algorithmic correctness and robustness of the random sampling implementation, particularly its ability to produce the specified approximate point count and handle various input scenarios.

        Testing Plan:

            Test Case 1: Verify Random Sampling UI Controls and Persistence (Manual UI Test)

                Test Data: N/A (UI interaction only).

                Expected Result:

                    Launch the application.

                    Open "Loading Settings..." from the "File" menu.

                    Select "Random Sampling" from the method dropdown. Verify that the "Keep Percentage" QSlider (with its display) becomes visible.

                    Adjust "Keep Percentage" to 25%.

                    Click "OK" to save settings and close the dialog.

                    Completely close the application.

                    Relaunch the application and reopen "Loading Settings...".

                    Verify that "Random Sampling" is still selected as the default method, and the "Keep Percentage" parameter is correctly set to 25%.

                Testing Tool: Manual UI testing, visual inspection.

            Test Case 2: Load large_dense.las with Random Sampling (Various Percentages) (Manual UI Test, Stopwatch, Status Bar)

                Test Data: large_dense.las (a large, dense LAS file).

                Expected Result:

                    Scenario A (Low Percentage): Load with "Keep Percentage" 5%. The file should load extremely fast (e.g., within 1-2 seconds for a 500MB file). The point count in the status bar should be approximately 5% of the original. The visual quality in the viewer will be very low, potentially showing large gaps.

                    Scenario B (Higher Percentage): Load with "Keep Percentage" 25%. The file should load faster than "Full Load" but slower than Scenario A. The point count should be approximately 25% of the original. The visual quality will be higher than Scenario A but still uneven.

                    In both scenarios, the QProgressDialog must display "Applying Random Filter..." during the subsampling phase, updating very quickly.

                Testing Tool: Manual UI testing, using a stopwatch to measure load times, verification of point count in the status bar, visual inspection (understanding that visual quality will be compromised).

            Test Case 3: RandomSampler Unit Tests - Point Count Verification (Google Test)

                Test Data:

                    An input std::vector<float> with a known number of points (e.g., 1000 points).

                    LoadingSettings objects with various keepPercentage values (e.g., 10, 50, 100).

                Expected Result: A unit test should call RandomSampler::filter() and verify that the size() of the output std::vector<float> is approximately the specified percentage of the input size (allowing for slight variations due to random selection, but within a small tolerance). For 1000 points and 10%, output should be around 100.

                Testing Tool: Google Test (tests/test_randomsampler.cpp).

            Test Case 4: RandomSampler Unit Tests - Edge Cases (Google Test)

                Test Data: Empty input vector, single point input vector.

                Expected Result: Empty input returns empty output. Single point input returns single point if keepPercentage is > 0, else empty.

                Testing Tool: Google Test (tests/test_randomsampler.cpp).

Actions to Undertake (Consolidated)

    Core Logic Development (PoissonDiskSampler, RandomSampler):

        Create src/poissondisksampler.h and src/poissondisksampler.cpp. Implement the PoissonDiskSampler::filter() method, ensuring it correctly handles spatial partitioning (e.g., using a grid for lookup), minimum distance checks, active list management, and robust random point generation.

        Create src/randomsampler.h and src/randomsampler.cpp. Implement the RandomSampler::filter() method, focusing on efficient random selection of points based on the keepPercentage.

        Crucially, ensure proper and high-quality random number generation seeding for both samplers, typically using std::random_device and std::mt19937 to guarantee non-deterministic results across different runs.

    LoadingSettings & LoadingSettingsDialog Updates:

        Modify src/loadingsettings.h to expand the LoadingMethod enum by adding LoadingMethod::PoissonDisk and LoadingMethod::RandomSampling.

        Update the QVariantMap parameters within the LoadingSettings struct to include the specific parameters for each new method: minimumRadius (double) and candidatePoints (int) for Poisson Disk, and keepPercentage (int or double) for Random Sampling.

        Modify src/loadingsettingsdialog.h and src/loadingsettingsdialog.cpp to dynamically add the necessary UI controls (QDoubleSpinBox for radius, QSpinBox for candidates, QSlider with display for percentage) when the corresponding new loading method is selected. Ensure these controls are configured with appropriate ranges, step sizes, and clear tooltips.

        Enhance the LoadingSettingsDialog::onMethodChanged slot to correctly manage the visibility of these new controls, ensuring only relevant parameters are shown for the currently selected method.

        Verify that QSettings correctly saves and loads all new parameters for both Poisson Disk and Random Sampling, maintaining user preferences across application sessions.

    LasParser Integration:

        Modify src/lasparser.h and src/lasparser.cpp.

        In the LasParser::parse() method, add new conditional logic branches (if (settings.method == LoadingMethod::PoissonDisk) and if (settings.method == LoadingMethod::RandomSampling)).

        If a new method is selected, after reading the full raw point data from the LAS file, instantiate the respective sampler (PoissonDiskSampler or RandomSampler) and call its filter() method, passing the raw point data and the LoadingSettings object.

        Implement robust memory management: after the subsampling filter returns the reduced point set, explicitly clear and release the memory occupied by the original, full point data std::vector<float> to minimize peak memory consumption during the overall loading process. The LasParser::parse() method will then return the subsampled data.

        Update the QProgressDialog messages (managed by MainWindow and updated by LasParser) to display specific messages during the subsampling phase, such as "Applying Poisson Disk Filter..." or "Applying Random Filter...", providing more detailed feedback to the user.

    Unit Testing:

        Create a new unit test file: tests/test_poissondisksampler.cpp. This file will contain comprehensive Google Test cases to validate the PoissonDiskSampler class in isolation, covering various input scenarios, parameter combinations, and verifying the minimum distance property and spatial uniformity of the output.

        Create a new unit test file: tests/test_randomsampler.cpp. This file will contain comprehensive Google Test cases to validate the RandomSampler class in isolation, verifying its ability to produce the specified approximate point count and handle edge cases.

        Add integration tests to tests/test_lasparser.cpp. These tests will verify that LasParser correctly integrates with and calls the new PoissonDiskSampler and RandomSampler classes, and that the data flow and output point counts are as expected when these new methods are selected.

        Add specific UI tests to verify the correct dynamic behavior of the LoadingSettingsDialog's new controls and their persistence via QSettings.

References between Files

    src/poissondisksampler.h <-> src/poissondisksampler.cpp: These files define and implement the core Poisson Disk sampling algorithm. poissondisksampler.h declares the class interface, and poissondisksampler.cpp provides the detailed C++ implementation.

    src/randomsampler.h <-> src/randomsampler.cpp: These files define and implement the core Random sampling algorithm. randomsampler.h declares the class interface, and randomsampler.cpp provides the detailed C++ implementation.

    src/lasparser.h <-> src/lasparser.cpp: These files are central to the overall point cloud loading process. LasParser will now conditionally call either PoissonDiskSampler::filter() or RandomSampler::filter() based on the user's LoadingSettings.

    src/loadingsettings.h: This crucial header file is updated to define the new LoadingMethod enum values (PoissonDisk, RandomSampling) and to include the specific parameters for these methods within its QVariantMap. It is a dependency for LasParser, LoadingSettingsDialog, and the new sampler classes.

    src/loadingsettingsdialog.h <-> src/loadingsettingsdialog.cpp: These files manage the user interface for all loading settings. They are updated to dynamically display the new controls for Poisson Disk and Random Sampling and to handle their values, saving them to and loading them from QSettings.

    src/mainwindow.cpp: This file continues to manage the QProgressDialog and will now display specific messages related to "Applying Poisson Disk Filter..." or "Applying Random Filter..." during the subsampling phases.

    tests/test_poissondisksampler.cpp: This new file contains the unit tests specifically designed to validate the PoissonDiskSampler's algorithmic correctness and behavior.

    tests/test_randomsampler.cpp: This new file contains the unit tests specifically designed to validate the RandomSampler's algorithmic correctness and behavior.

    tests/test_lasparser.cpp: This existing test file will be extended to include integration tests, verifying that LasParser correctly utilizes the new PoissonDiskSampler and RandomSampler classes and that the overall parsing and subsampling pipeline functions as expected.

List of Files being Created

    File 1: src/poissondisksampler.h

        Purpose: This header file declares the PoissonDiskSampler class, providing the public interface for applying the Poisson Disk subsampling algorithm to point cloud data. It defines the class structure, its constructor, and the filter method signature, along with any necessary private helper structures or member variables.

        Contents:

        #ifndef POISSONDISKSAMPLER_H
        #define POISSONDISKSAMPLER_H

        #include <vector>    // For std::vector to hold point data
        #include <QVector3D> // For 3D vector operations and point representation
        #include <random>    // For robust random number generation (std::mt19937, std::random_device)
        #include <unordered_map> // For spatial hashing (efficient lookup of points in grid cells)
        #include <algorithm> // For std::shuffle (optional, depends on implementation strategy)
        #include <cmath>     // For std::sqrt, std::pow
        #include "loadingsettings.h" // To access minimumRadius and candidatePoints from settings

        class PoissonDiskSampler
        {
        public:
            PoissonDiskSampler(); // Constructor, initializes random number generator

            // Applies Poisson Disk subsampling to the input point cloud.
            // inputPoints: A vector of float representing XYZ (or XYZRGB, etc.) points.
            //              Assumes points are stored as (x, y, z, ...) sequence of floats.
            // settings: Contains the minimumRadius and candidatePoints parameters.
            // Returns a new vector of floats with the subsampled points.
            std::vector<float> filter(const std::vector<float>& inputPoints, const LoadingSettings& settings);

        private:
            // Helper struct for a 3D grid cell key, used in spatial hashing for efficient lookups.
            // This allows mapping 3D coordinates to a discrete grid cell.
            struct GridCellKey {
                int x, y, z;
                // Equality operator for std::unordered_map
                bool operator==(const GridCellKey& other) const {
                    return x == other.x && y == other.y && z == other.z;
                }
            };

            // Custom hash function for GridCellKey, required for std::unordered_map.
            // Ensures efficient hashing of 3D integer coordinates.
            struct GridCellKeyHasher {
                size_t operator()(const GridCellKey& k) const {
                    // Simple hash combination; more robust hashes can be used for larger ranges.
                    return std::hash<int>()(k.x) ^ (std::hash<int>()(k.y) << 1) ^ (std::hash<int>()(k.z) << 2);
                }
            };

            std::mt19937 m_rng; // Mersenne Twister pseudo-random number generator for high-quality randomness.
            std::uniform_real_distribution<float> m_dist; // Uniform distribution for generating random floats [0,1).

            // Private helper method to check if a candidate point is valid (i.e., not too close to existing points).
            bool isValid(const QVector3D& candidate, float minRadius,
                         const std::vector<QVector3D>& existingPoints,
                         const std::unordered_map<GridCellKey, std::vector<int>, GridCellKeyHasher>& grid,
                         float cellSize, const QVector3D& minBounds);

            // Private helper method to get neighboring grid cells for proximity checks.
            std::vector<GridCellKey> getNeighboringCells(const GridCellKey& centerCell);
        };

        #endif // POISSONDISKSAMPLER_H

        Relationships: This file depends on src/loadingsettings.h to receive configuration. It is utilized by src/lasparser.h (for invoking the filter) and tests/test_poissondisksampler.cpp (for unit testing).

    File 2: src/poissondisksampler.cpp

        Purpose: This source file contains the detailed C++ implementation of the PoissonDiskSampler class. It will contain the logic for the filter method, including bounding box calculation, the iterative "dart throwing" process, spatial hashing for efficient nearest-neighbor checks, and robust random number generation.

        Contents: (The C++ code will implement the filter method, which will:

            Parse input std::vector<float> into std::vector<QVector3D>.

            Calculate the bounding box and determine an appropriate grid cellSize based on minRadius.

            Initialize an std::unordered_map<GridCellKey, std::vector<int>, GridCellKeyHasher> to represent the spatial grid, storing indices of points within each cell.

            Maintain an activeList (e.g., std::vector<int>) of points from which to generate new candidates.

            Implement the main loop:

                Randomly select a point p from activeList.

                Generate candidatePoints random candidates around p within the specified ring.

                For each candidate c, call isValid() to check if it's too close to any existing points (using the grid for efficient lookups).

                If c is valid, add it to the output list, and add its index to activeList and the grid.

                If no valid candidate is found after candidatePoints attempts, remove p from activeList.

            Convert std::vector<QVector3D> back to std::vector<float> for return.

            Implement isValid() and getNeighboringCells() helper methods.)

        Relationships: This file implements src/poissondisksampler.h.

    File 3: tests/test_poissondisksampler.cpp

        Purpose: This new file will contain the Google Test suite for the PoissonDiskSampler class. It will define various test cases to ensure the algorithm's correctness, efficiency, and adherence to the Poisson Disk properties.

        Contents: (Google Test TEST_F or TEST macros for:

            Empty Input: Test with an empty std::vector<float>.

            Single Point Input: Test with a single point to ensure it's handled correctly.

            Uniform Grid Test: Test with a perfectly uniform grid of points to verify the output density and separation.

            Minimum Distance Verification: A critical test that iterates through all pairs of points in the output point cloud and asserts that the distance between any two points is greater than or equal to the specified minimumRadius (allowing for a small epsilon for floating-point comparisons).

            Parameter Impact: Tests with different minimumRadius values (small vs. large) and candidatePoints values to verify their impact on output point count and density.

            Edge Cases: Testing with points at the bounding box limits, or with very sparse input data.

            Performance (Micro-benchmark): A basic test to measure the execution time for a moderately sized input to ensure it's within acceptable limits.)

        Relationships: This file directly tests src/poissondisksampler.h and src/poissondisksampler.cpp.

    File 4: src/randomsampler.h

        Purpose: This header file declares the RandomSampler class, providing the public interface for applying the straightforward Random subsampling algorithm. It defines the class structure, its constructor, and the filter method signature, along with necessary private member variables for random number generation.

        Contents:

        #ifndef RANDOMSAMPLER_H
        #define RANDOMSAMPLER_H

        #include <vector>    // For std::vector to hold point data
        #include <random>    // For robust random number generation (std::mt19937, std::random_device)
        #include <algorithm> // For std::shuffle (if using a shuffle-based approach)
        #include "loadingsettings.h" // To access keepPercentage from settings

        class RandomSampler
        {
        public:
            RandomSampler(); // Constructor, initializes random number generator

            // Applies random subsampling to the input point cloud.
            // inputPoints: A vector of float representing XYZ (or XYZRGB, etc.) points.
            //              Assumes points are stored as (x, y, z, ...) sequence of floats.
            // settings: Contains the keepPercentage parameter.
            // Returns a new vector of floats with the subsampled points.
            std::vector<float> filter(const std::vector<float>& inputPoints, const LoadingSettings& settings);

        private:
            std::mt19937 m_rng; // Mersenne Twister pseudo-random number generator for high-quality randomness.
            std::uniform_real_distribution<float> m_dist; // Uniform distribution for generating random floats [0,1).
        };

        #endif // RANDOMSAMPLER_H

        Relationships: This file depends on src/loadingsettings.h to receive configuration. It is utilized by src/lasparser.h (for invoking the filter) and tests/test_randomsampler.cpp (for unit testing).

    File 5: src/randomsampler.cpp

        Purpose: This source file contains the detailed C++ implementation of the RandomSampler class. It will contain the logic for the filter method, focusing on efficient random point selection based on the specified percentage.

        Contents: (The C++ code will implement the filter method, which will:

            Parse input std::vector<float> into std::vector<QVector3D> (or directly operate on float vector if structure is known).

            Calculate the target number of points based on inputPoints.size() and keepPercentage.

            Use std::shuffle on a vector of indices, then pick the first targetCount indices, or iterate through the input points and use m_dist(m_rng) to randomly decide whether to include each point.

            Collect the selected points into the output std::vector<float>.

            Ensure the random number generator is properly seeded on construction to avoid predictable sequences.)

        Relationships: This file implements src/randomsampler.h.

    File 6: tests/test_randomsampler.cpp

        Purpose: This new file will contain the Google Test suite for the RandomSampler class. It will define various test cases to ensure the algorithm's correctness, particularly its ability to produce approximately the specified percentage of points.

        Contents: (Google Test TEST_F or TEST macros for:

            Empty Input: Test with an empty std::vector<float>.

            Single Point Input: Test with a single point to ensure it's handled correctly.

            Point Count Verification: A critical test that generates a large number of input points and asserts that the output std::vector<float> has a size approximately equal to the keepPercentage of the input size (allowing for a small statistical tolerance due to randomness).

            Parameter Impact: Tests with different keepPercentage values (e.g., 1%, 50%, 100%) to verify their impact on output point count.

            Performance (Micro-benchmark): A basic test to measure the execution time for a moderately sized input to ensure it's extremely fast.)

        Relationships: This file directly tests src/randomsampler.h and src/randomsampler.cpp.

Acceptance Criteria (Consolidated)

    Poisson Disk Option in Settings:

        The "Point Cloud Loading Settings" dialog must prominently include "Poisson Disk" as a selectable option within the loading method control. This option should be clearly labeled and distinguishable from other methods.

    Dynamic UI for Poisson Disk Parameters:

        When "Poisson Disk" is selected in the settings dialog, two new, relevant UI controls must dynamically appear:

            "Minimum Radius" (QDoubleSpinBox): This control must have a functional range (e.g., 0.01m to 10.0m), appropriate decimal precision (e.g., two decimal places), and a clear tooltip explaining its impact on the output point density and visual separation.

            "Candidate Points" (QSpinBox): This control must have a functional range (e.g., 10 to 50), and a clear tooltip explaining its role in the algorithm's thoroughness and impact on processing time.

        These controls must automatically hide when any other loading method is selected, ensuring a clean and context-sensitive user interface.

    Functional Poisson Disk Subsampling:

        Loading any valid LAS file with "Poisson Disk" selected must successfully apply the subsampling algorithm, resulting in a significantly reduced point count compared to a "Full Load."

        The subsampled point cloud, when rendered in the PointCloudViewerWidget, must appear visually uniform and exhibit clear spatial separation, with no noticeable clumping of points. A visual inspection should confirm that points are distributed evenly.

        Changing the "Minimum Radius" parameter must directly and correctly alter the output point count and the visual separation of points (larger radius = fewer, more separated points).

        Changing the "Candidate Points" parameter must correctly influence the density and completeness of the sampling (higher candidates = potentially denser, more uniform output for a given radius).

        The QProgressDialog must accurately display "Applying Poisson Disk Filter..." during the subsampling phase, providing clear feedback to the user.

        The selected Poisson Disk settings (method, minimum radius, candidate points) must be correctly saved to QSettings and persist across application restarts.

    Random Sampling Option in Settings:

        The "Point Cloud Loading Settings" dialog must prominently include "Random Sampling" as a selectable option within the loading method control.

    Dynamic UI for Random Sampling Parameters:

        When "Random Sampling" is selected in the settings dialog, a new UI control must dynamically appear:

            "Keep Percentage" (QSlider with an accompanying QSpinBox or QLabel for numerical display): This control must have a functional range (e.g., 1% to 50%), and a clear tooltip explaining its direct impact on the output point count and visual fidelity.

        This control must automatically hide when any other loading method is selected.

    Functional Random Subsampling:

        Loading any valid LAS file with "Random Sampling" selected must successfully apply the subsampling algorithm, resulting in a reduced point count.

        The output point count must be approximately equal to the specified keepPercentage of the original total point count (allowing for minor statistical variation).

        Changing the "Keep Percentage" parameter must directly and correctly alter the output point count (higher percentage = more points).

        The QProgressDialog must accurately display "Applying Random Filter..." during the subsampling phase, providing clear feedback to the user.

        The selected Random Sampling settings (method, keep percentage) must be correctly saved to QSettings and persist across application restarts.

    No Regressions:

        All functionalities implemented in Sprint 1 (Full Load, Header-Only, settings persistence, header metadata display) and Sprint 2 (Voxel Grid subsampling) must remain fully functional, stable, and exhibit no degradation in performance.

        The application must not crash or freeze during any loading operation, including those utilizing the new Poisson Disk or Random Sampling methods, even with very large files or extreme parameter values.

    Unit Test Coverage:

        All unit tests for PoissonDiskSampler (in tests/test_poissondisksampler.cpp) must pass successfully, ensuring the algorithm's correctness, particularly its adherence to the minimum distance property and spatial uniformity.

        All unit tests for RandomSampler (in tests/test_randomsampler.cpp) must pass successfully, ensuring the algorithm's correctness, particularly its ability to produce the specified approximate point count and handle various input scenarios.

Testing Plan

The testing plan for Sprint 3 will be comprehensive, focusing on validating the PoissonDiskSampler and RandomSampler both in isolation (through dedicated unit tests) and as integral parts of the integrated loading pipeline (via manual UI tests and integration tests). This multi-faceted approach ensures both algorithmic correctness and seamless user experience.

    Test Data:

        small_dense.las: A small, valid, and relatively dense LAS file (e.g., a simple geometric shape like a sphere or cube with many points). This is ideal for visually inspecting the uniformity and separation of Poisson Disk output and for quick verification of Random Sampling.

        large_dense.las: A large, valid, and very dense LAS file (e.g., 500MB+ or 1GB+). This file is crucial for performance testing, comparing loading times and memory consumption against "Full Load" and "Voxel Grid."

        sparse.las: A LAS file with very few points or points that are widely spaced. This will test how the samplers behave with low-density input.

        empty.las: An empty LAS file (containing only a header, no points).

        single_point.las: A LAS file containing only one point.

        clustered.las: A LAS file with distinct, dense clusters of points and large empty spaces, to challenge the spatial distribution of Poisson Disk.

    Testing Tools:

        Manual UI Testing: This remains a primary tool for verifying the responsiveness of the UI, the dynamic visibility and correct behavior of new controls in the LoadingSettingsDialog, the visual quality and distribution of subsampled point clouds in the PointCloudViewerWidget, and the accuracy of QProgressDialog messages.

        Google Test: This C++ testing framework will be used extensively for writing automated unit tests. It is indispensable for validating the internal algorithmic logic of PoissonDiskSampler and RandomSampler (e.g., minimum distance checks, point count accuracy) and for ensuring their correct integration with LasParser.

        System Monitor (e.g., Windows Task Manager, Linux htop, macOS Activity Monitor): This tool will be used to observe real-time CPU and memory usage during loading operations, particularly for large_dense.las with different sampling methods, to quantitatively confirm performance improvements and memory reduction.

        Point Cloud Viewer (External, e.g., CloudCompare): Optionally, an external, industry-standard point cloud viewer like CloudCompare can be used to load the original and subsampled LAS files. This allows for an objective visual comparison of point distribution, density, and feature preservation, providing an independent verification of the filter's output quality.

    Test Cases (Detailed):

        Test Case 1: Verify Poisson Disk UI Controls and Persistence (Manual UI Test)

            Test Data: N/A (UI interaction only).

            Expected Result:

                Launch the application and open "Loading Settings..." from the "File" menu.

                Select "Poisson Disk" from the method dropdown. Verify that the "Minimum Radius" (QDoubleSpinBox) and "Candidate Points" (QSpinBox) controls become visible, are correctly labeled, and are pre-populated with sensible default values.

                Adjust "Minimum Radius" to 0.5m and "Candidate Points" to 30. Observe that the QDoubleSpinBox allows decimal input and the QSpinBox allows integer input within their specified ranges.

                Click "OK" to save the settings and close the dialog.

                Completely close the application (e.g., via "File -> Exit").

                Relaunch the application and reopen "Loading Settings...".

                Verify that "Poisson Disk" is still selected as the default method, and the "Minimum Radius" and "Candidate Points" parameters are correctly set to 0.5m and 30, respectively, demonstrating persistence.

            Testing Tool: Manual UI testing, visual inspection.

        Test Case 2: Load small_dense.las with Poisson Disk (Various Parameters) (Manual UI Test & Visual Inspection)

            Test Data: small_dense.las (e.g., a simple sphere of points).

            Expected Result:

                Scenario A (Fine Sampling): Configure Poisson Disk with "Minimum Radius" 0.1m, "Candidate Points" 20. Load small_dense.las. The point count in the status bar should be significantly reduced compared to "Full Load". In the PointCloudViewerWidget, the point cloud should appear visually dense, uniform, and points should be clearly separated when zoomed in.

                Scenario B (Coarse Sampling): Configure Poisson Disk with "Minimum Radius" 0.5m, "Candidate Points" 20. Load small_dense.las. The point count should be further reduced compared to Scenario A, and the visual density should be lower, but the points should still appear uniformly distributed with clear separation.

                Scenario C (High Candidates): Configure Poisson Disk with "Minimum Radius" 0.1m, "Candidate Points" 50. Load small_dense.las. The point count should be slightly higher than Scenario A, indicating a more thorough sampling (denser for the given radius), but still maintaining the minimum distance property.

                In all scenarios, the QProgressDialog must accurately display "Applying Poisson Disk Filter..." during the subsampling phase, with the progress bar updating.

            Testing Tool: Manual UI testing, detailed visual inspection of the PointCloudViewerWidget (zooming in to verify point separation and uniformity), verification of point count in the status bar.

        Test Case 3: Load large_dense.las with Poisson Disk (Performance Test) (Manual UI Test, Stopwatch, System Monitor)

            Test Data: large_dense.las (a multi-gigabyte point cloud).

            Expected Result:

                The loading time for large_dense.las with Poisson Disk (e.g., Minimum Radius 0.5m, Candidate Points 30) should be significantly faster (aim for 2x-8x speedup) than loading the same file with "Full Load". For a 60-second full load, this should be under 30 seconds.

                Peak memory usage observed via System Monitor should be substantially lower (e.g., 50% or more reduction) than during a "Full Load" of the same file, demonstrating effective memory optimization.

                The UI should remain fully responsive throughout the entire loading process, with no freezing or significant lag, even during the computationally intensive Poisson Disk filtering phase.

                The QProgressDialog should accurately reflect the "Reading Points..." and "Applying Poisson Disk Filter..." stages, with smooth and continuous progress updates.

            Testing Tool: Manual UI testing, using a stopwatch to precisely measure load times, and System Monitor (e.g., Windows Task Manager, htop on Linux) to observe real-time memory and CPU utilization.

        Test Case 4: PoissonDiskSampler Unit Tests - Basic Functionality (Google Test)

            Test Data:

                An empty std::vector<float> as input.

                A std::vector<float> containing only a single point (to ensure it's handled without error).

                A std::vector<float> with points perfectly aligned on a grid, designed to specifically test the minimum distance adherence and uniform sampling behavior.

                A LoadingSettings object where minimumRadius is set to 0.0 (an invalid input).

            Expected Result:

                An empty input vector should result in an empty output vector.

                A single point input should result in a single point output (assuming minimumRadius is small enough to allow it).

                For the grid test, the output point count should be consistent with the minimumRadius and the points should be correctly separated.

                minimumRadius = 0.0 should either throw a specific exception, return the original points unchanged, or log an error, depending on the chosen robust handling strategy, but not crash the application.

            Testing Tool: Google Test (tests/test_poissondisksampler.cpp).

        Test Case 5: PoissonDiskSampler Unit Tests - Minimum Distance Verification (Google Test)

            Test Data: A std::vector<float> containing a dense cluster of points where some are very close to each other (e.g., multiple points within a 0.01m radius), combined with a LoadingSettings object specifying a minimumRadius (e.g., 0.1m).

            Expected Result: A unit test should iterate through all pairs of points in the output std::vector<float> generated by PoissonDiskSampler::filter(). For every pair of distinct points, the Euclidean distance between them must be greater than or equal to the specified minimumRadius, allowing for a small epsilon (e.g., 1e-6) for floating-point comparison inaccuracies. This confirms the core property of Poisson Disk sampling.

            Testing Tool: Google Test (tests/test_poissondisksampler.cpp).

        Test Case 6: Verify Random Sampling UI Controls and Persistence (Manual UI Test)

            Test Data: N/A (UI interaction only).

            Expected Result:

                Launch the application and open "Loading Settings...".

                Select "Random Sampling" from the method dropdown. Verify that the "Keep Percentage" QSlider (with its accompanying QSpinBox or QLabel display) becomes visible, is correctly labeled, and is pre-populated with a sensible default percentage.

                Adjust "Keep Percentage" to 25%.

                Click "OK" to save settings and close the dialog.

                Completely close the application.

                Relaunch the application and reopen "Loading Settings...".

                Verify that "Random Sampling" is still selected as the default method, and the "Keep Percentage" parameter is correctly set to 25%, demonstrating persistence.

            Testing Tool: Manual UI testing.

        Test Case 7: Load large_dense.las with Random Sampling (Various Percentages) (Manual UI Test, Stopwatch, Status Bar)

            Test Data: large_dense.las (a multi-gigabyte point cloud).

            Expected Result:

                Scenario A (Low Percentage): Configure Random Sampling with "Keep Percentage" 5%. Load large_dense.las. The file should load extremely fast (e.g., within 1-2 seconds for a 500MB file, depending on I/O). The point count in the status bar should be approximately 5% of the original total. The visual quality in the viewer will be very low, likely showing large gaps and an uneven distribution, as expected for random sampling.

                Scenario B (Higher Percentage): Configure Random Sampling with "Keep Percentage" 25%. Load large_dense.las. The file should load faster than "Full Load" but slower than Scenario A. The point count should be approximately 25% of the original. The visual quality will be higher than Scenario A but still uneven.

                In both scenarios, the QProgressDialog must display "Applying Random Filter..." during the subsampling phase, updating very quickly due to the simplicity of the algorithm.

            Testing Tool: Manual UI testing, using a stopwatch to measure load times, verification of point count in the status bar, visual inspection (understanding that visual quality will be compromised for speed).

        Test Case 8: RandomSampler Unit Tests - Point Count Verification (Google Test)

            Test Data:

                An input std::vector<float> with a known, large number of points (e.g., 10,000 points).

                LoadingSettings objects with various keepPercentage values (e.g., 10, 50, 100).

            Expected Result: A unit test should call RandomSampler::filter() and verify that the size() of the output std::vector<float> is approximately the specified percentage of the input size. For example, for 10,000 points and 10%, the output size should be between 950 and 1050 (allowing for statistical variation). For 100%, the output size should be exactly the input size.

            Testing Tool: Google Test (tests/test_randomsampler.cpp).

        Test Case 9: Integration Test - LasParser with new Samplers (Google Test)

            Test Data: small_dense.las (a small, valid LAS file).

            Expected Result:

                A unit test should call LasParser::parse() with LoadingMethod::PoissonDisk settings and verify that the returned point count is reduced and the PoissonDiskSampler was invoked.

                Another unit test should call LasParser::parse() with LoadingMethod::RandomSampling settings and verify that the returned point count is reduced to the approximate percentage and the RandomSampler was invoked.

            Testing Tool: Google Test (tests/test_lasparser.cpp).

Assumptions and Dependencies

    Sprint 1 & 2 Completion and Stability: This sprint is critically dependent on the successful and stable completion of all user stories and acceptance criteria from Sprint 1 ("Settings Panel & Core Integration") and Sprint 2 ("Voxel Grid Subsampling Implementation"). This includes the robust functioning of the LoadingSettingsDialog, the LoadingSettings struct, reliable QSettings persistence, and the correct "Full Load", "Header-Only", and "Voxel Grid" functionalities for LAS files. Any instability or incomplete features from previous sprints will directly impede progress in Sprint 3.

    Valid LAS File Format Adherence: It is a core assumption that all LAS files provided for testing and user interaction will consistently adhere to the official LAS file format specification (versions 1.0-1.4). The LasParser is expected to correctly read and interpret the raw point data as per this standard. Any deviations from the standard in input files may lead to unexpected behavior or parsing errors, which are outside the scope of this sprint's specific feature implementation.

    Consistent Point Data Structure: The std::vector<float> returned by LasParser and subsequently processed by PoissonDiskSampler and RandomSampler is assumed to contain point data in a consistent and predictable format. Typically, this means points are stored as sequences of floats (e.g., XYZ, XYZRGB, XYZI), where each point occupies a fixed number of float values. For the spatial operations of Poisson Disk and Random Sampling, the first three float values are always assumed to represent the X, Y, and Z coordinates, respectively.

    Memory Availability for Initial Read: While both Poisson Disk and Random Sampling significantly reduce the final memory footprint, the algorithms, as designed in this sprint, require that the initial raw point data (or at least a substantial chunk of it) can be loaded into memory before the subsampling process begins. This sprint does not introduce full out-of-core processing for the samplers themselves, meaning that for extremely massive files, there might still be a peak memory requirement during the initial data acquisition phase within LasParser. This will be addressed in a later sprint.

    Qt6.9.0 and C++17/20: Development will continue to strictly adhere to the Qt6.9.0 framework and leverage modern C++ standards (C++17 or C++20) for all new code. This ensures compatibility with the existing codebase and allows for the use of modern language features and libraries, particularly the <random> library for high-quality random number generation.

    Random Number Generation Quality: The effectiveness of Poisson Disk and Random Sampling heavily relies on the quality of the underlying random number generation. It is assumed that std::random_device and std::mt19937 provide sufficient randomness for the application's needs.

Non-Functional Requirements

    Performance:

        Loading Speed Enhancement (Poisson Disk): Loading large LAS files with Poisson Disk subsampling enabled must demonstrate a significant improvement in loading speed, targeting a 2x to 8x speedup compared to loading the same file with the "Full Load" method. The exact speedup will depend on the minimumRadius and candidatePoints parameters, but a noticeable reduction in wait times is expected.

        Loading Speed Enhancement (Random Sampling): Loading large LAS files with Random Sampling enabled must be the fastest available method, targeting a 4x to 10x+ speedup compared to "Full Load." This method prioritizes raw speed for quick previews.

        Memory Efficiency: Peak memory consumption during both Poisson Disk and Random Sampling loading should be substantially lower than during a "Full Load" for large datasets. This reduction should be proportional to the point count reduction achieved by the chosen sampling method.

        CPU Utilization: The sampling processes for both Poisson Disk and Random Sampling should efficiently utilize available CPU cores. While full QtConcurrent parallelization is a focus for Sprint 5, the algorithms themselves should be optimized to minimize unnecessary computations and memory accesses, ensuring that the processing time is as low as possible for the given serial execution.

    Usability:

        Intuitive Controls: The newly introduced "Minimum Radius," "Candidate Points," and "Keep Percentage" controls within the settings dialog must be highly intuitive and self-explanatory. This includes clear labels, appropriate default values, sensible ranges, and informative tooltips that accurately explain their function and impact on the subsampling process and the resulting point cloud.

        Clear Feedback: The QProgressDialog and the QStatusBar messages must provide accurate, real-time, and easily understandable feedback to the user regarding the current stage of the Poisson Disk or Random Sampling loading process (e.g., "Reading Points...", "Applying Poisson Disk Filter...", "Applying Random Filter..."). This transparency helps manage user expectations and provides a continuous sense of progress.

    Stability:

        Application Robustness: The application must exhibit high stability, preventing crashes or unresponsiveness during all file-related operations, including opening files, changing settings, and handling error conditions (e.g., corrupted files, non-existent paths, or extreme parameter values for the new samplers). Error messages should be gracefully presented via QMessageBox without disrupting the application flow.

        Robust Parameter Handling: Error handling for invalid parameters (e.g., a negative minimumRadius, a keepPercentage outside the 1-100 range) must be robust. The application should either prevent such inputs via UI validation or handle them gracefully in the backend (e.g., by logging an error and defaulting to a safe value) without crashing.

    Maintainability:

        Modular Design: The PoissonDiskSampler and RandomSampler classes must be designed as modular, standalone components with clear APIs, promoting reusability for other point cloud processing tasks in the future. They should have a clear separation of concerns from the LasParser and from each other.

        Code Quality: All new C++ code developed in this sprint must adhere strictly to the project's established coding standards, including consistent formatting, meaningful variable names, and comprehensive inline comments explaining complex logic, algorithms, and design decisions. This ensures the codebase remains easy to understand, debug, and extend by other developers.

Conclusion

Sprint 3 represents a significant leap forward in expanding the point cloud optimization capabilities of the FARO Scene Registration Software by introducing both Poisson Disk and Random Sampling. By successfully implementing these two distinct methods, providing granular user control over their parameters, and ensuring their seamless integration into the existing loading workflow, the application will offer users a more versatile and powerful set of tools for balancing performance and visual fidelity. This sprint's success is crucial for enhancing the overall user experience, particularly for quick previews, specialized visualizations, and preparing data for various analytical tasks. It further solidifies the application's position as a robust and efficient point cloud processing tool, moving closer to the ambitious performance goals outlined in the PRD.