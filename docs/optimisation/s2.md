# **Backlog: Sprint 2 \- Voxel Grid Subsampling Implementation**

## **Introduction**

This document details the comprehensive backlog for Sprint 2: "Voxel Grid Subsampling Implementation," a critical phase that directly builds upon the foundational work established in Sprint 1 (Settings Panel & Core Integration). The primary objective of this sprint is to introduce the first advanced point cloud optimization technique into the FARO Scene Registration Software: **Voxel Grid Subsampling**. This method is a cornerstone for efficient point cloud processing, allowing users to intelligently reduce the overwhelming density of large LAS (Lidar ASCII Standard) point cloud files. By grouping points within a precisely defined 3D grid and representing each occupied grid cell (voxel) with a single, representative point (typically the centroid of all points within that voxel), we can achieve a significant reduction in the overall point count. This reduction directly translates to several crucial benefits: dramatically improved loading times, substantial decreases in memory consumption, and a more responsive application experience, all while maintaining a highly desirable uniform spatial distribution of points. This uniformity is vital for subsequent visualization, analysis, and processing steps that often assume a relatively even point density. This sprint will involve the meticulous creation of the core filtering logic within a dedicated, reusable class, the seamless integration of new user interface controls into the existing settings panel from Sprint 1, and the necessary updates to the file parsing workflow to intelligently incorporate this powerful new method.

## **User Stories**

* **User Story 1**: As a user, I want to apply Voxel Grid subsampling to LAS files, so I can reduce point count while maintaining uniform density.  
  * **Description**: This user story directly addresses a significant pain point for users dealing with massive LAS point clouds: the trade-off between loading speed/memory and data fidelity. By enabling Voxel Grid subsampling, the application empowers users to intelligently downsample their datasets. This intelligent reduction of points, achieved by replacing clusters of points within a defined 3D space (voxels) with a single representative point, directly translates to several critical performance improvements. First, it leads to significantly faster loading times, as the application needs to process and render fewer points. Second, it results in substantially lower memory consumption, making it possible to work with datasets that might otherwise exceed available RAM. Third, a key advantage of Voxel Grid is its inherent ability to maintain a relatively uniform spatial distribution of points. Unlike simple random sampling, which can leave visually "hole-y" or unevenly dense areas, Voxel Grid ensures that the subsampled cloud still provides a consistent and visually representative overview of the scanned environment. This uniform density is highly beneficial for various downstream tasks, including initial visualization, coarse registration, or preparing data for algorithms that perform better with evenly distributed points. Users will gain precise control over the resolution and aggressiveness of this subsampling through user-configurable parameters, allowing them to fine-tune the balance between detail and performance for their specific analytical or visualization needs.  
  * **Actions to Undertake**:  
    1. **Create VoxelGridFilter Class**: This is the core development task for this sprint. A new, self-contained C++ class named VoxelGridFilter will be designed and implemented. This class will be responsible solely for the geometric logic of voxel grid subsampling. Its primary public method, filter(), will be designed to accept a constant reference to a std::vector\<float\> representing the input point cloud (where points are typically stored as XYZXYZ... or XYZRGBXYZRGB...). Crucially, it will also take a const LoadingSettings& object, from which it will extract the leafSize (the dimension of each voxel cube) and minPointsPerVoxel (the minimum number of original points required within a voxel for it to contribute a representative point). The filter() method will then return a new std::vector\<float\> containing the reduced, subsampled point cloud. The internal implementation will involve:  
       * Calculating the bounding box of the input point cloud to define the overall grid extent.  
       * Iterating through each input point, calculating its corresponding voxel index (i, j, k) based on its coordinates and the leafSize.  
       * Using a spatial hashing mechanism (e.g., std::unordered\_map\<VoxelKey, std::vector\<QVector3D\>, VoxelKeyHasher\>) to efficiently group points that fall into the same voxel.  
       * For each populated voxel, checking if it meets the minPointsPerVoxel threshold.  
       * If the threshold is met, calculating the centroid (average X, Y, Z) of all points within that voxel to serve as the single representative point.  
       * Collecting these representative points into the output std::vector\<float\>.  
    2. **Update LoadingSettings and LoadingSettingsDialog**:  
       * **src/loadingsettings.h Modification**: The LoadingMethod enum within this header will be extended to include a new enumerator: LoadingMethod::VoxelGrid. Additionally, the QVariantMap parameters within the LoadingSettings struct will be updated to define and store the specific keys for Voxel Grid configuration, namely "leafSize" (as a double) and "minPointsPerVoxel" (as an int). This ensures that the settings object can correctly carry the necessary parameters for the VoxelGridFilter.  
       * **src/loadingsettingsdialog.h and src/loadingsettingsdialog.cpp Modification**: These files will be updated to dynamically manage the UI controls for the new Voxel Grid parameters. When LoadingMethod::VoxelGrid is selected in the main method QComboBox:  
         * A QDoubleSpinBox labeled "Leaf Size" will appear, configured with a sensible range (e.g., 0.01m to 5.0m) and appropriate decimal precision (e.g., 2-3 decimal places). A clear tooltip will be added: "Controls the size of each 3D voxel cube. Smaller values preserve more detail but result in more points; larger values drastically reduce point count for faster processing."  
         * A QSpinBox labeled "Min Points Per Voxel" will appear, configured with a range (e.g., 1 to 10\) and a tooltip: "Sets the minimum number of original points required within a voxel for it to contribute a point to the subsampled cloud. Useful for filtering noise."  
         * Crucially, LoadingSettingsDialog::onMethodChanged will be enhanced to handle the visibility of these controls, ensuring they are only shown when "Voxel Grid" is selected and hidden for other methods.  
       * **QSettings Integration**: The saveSettings() and loadSettings() methods within LoadingSettingsDialog.cpp will be updated to correctly store and retrieve the "leafSize" and "minPointsPerVoxel" parameters using QSettings, guaranteeing that these user preferences persist across application launches.  
    3. **Integrate VoxelGridFilter into LasParser**:  
       * **src/lasparser.h and src/lasparser.cpp Modification**: The core LasParser::parse() method will be modified to incorporate the VoxelGridFilter. After the initial full point data has been read from the LAS file into a temporary std::vector\<float\> (which is still necessary as Voxel Grid operates on the raw data), a conditional check will be added: if (settings.method \== LoadingMethod::VoxelGrid).  
       * If the condition is true, an instance of VoxelGridFilter will be created, and its filter() method will be called, passing the raw point data and the relevant LoadingSettings parameters.  
       * **Memory Management**: After the VoxelGridFilter returns the subsampled data, the original, larger std::vector\<float\> containing the full point data will be explicitly cleared and its memory capacity released (e.g., using std::vector\<float\>().swap(originalPointsVector);) to minimize peak memory consumption. The LasParser::parse() method will then return the much smaller, subsampled std::vector\<float\>.  
       * **Parameter Passing**: Ensure that the LasParser correctly extracts the "leafSize" and "minPointsPerVoxel" from the LoadingSettings object and passes them accurately to the VoxelGridFilter.  
    4. **Update QProgressDialog**: To provide more granular and informative feedback to the user, the QProgressDialog (managed by MainWindow and updated by LasParser) will be enhanced. After the initial "Reading Points..." phase is complete, a new progress message, "Applying Voxel Filter...", will be displayed during the execution of the VoxelGridFilter. This distinct message helps the user understand the current processing stage and manages expectations regarding the time taken for the subsampling step. The percentage completion for this phase will also be updated.  
  * **References between Files**:  
    * **New files**: src/voxelgridfilter.h (declares the VoxelGridFilter class) and src/voxelgridfilter.cpp (implements the voxel grid algorithm). These are crucial new components.  
    * src/loadingsettings.h: This file is updated to define the new LoadingMethod::VoxelGrid enum value and to provide the structure for storing its leafSize and minPointsPerVoxel parameters within the QVariantMap.  
    * src/loadingsettingsdialog.h & src/loadingsettingsdialog.cpp: These files are modified to incorporate the UI elements (QDoubleSpinBox, QSpinBox) for the Voxel Grid parameters and to manage their dynamic visibility and persistence via QSettings.  
    * src/lasparser.h & src/lasparser.cpp: These files are central to the integration. LasParser's parse() method will be updated to conditionally invoke the VoxelGridFilter and handle the resulting subsampled data.  
    * src/mainwindow.cpp: This file will be updated to manage the QProgressDialog messages, displaying the new "Applying Voxel Filter..." stage.  
    * tests/test\_voxelgridfilter.cpp: This is a new unit test file specifically dedicated to thoroughly testing the VoxelGridFilter class in isolation, ensuring its algorithmic correctness.  
  * **Acceptance Criteria**:  
    * **UI Integration**: The "Point Cloud Loading Settings" dialog must now prominently feature a new option labeled "Voxel Grid" within its method selection control (e.g., QComboBox).  
    * **Dynamic Parameter Controls**: When the "Voxel Grid" method is selected, two specific UI controls must dynamically appear: a QDoubleSpinBox for "Leaf Size" (with a functional range of 0.01m to 5.0m, accurate decimal precision, and a helpful tooltip) and a QSpinBox for "Min Points Per Voxel" (with a functional range of 1 to 10 and its own clear tooltip). These controls must correctly hide when any other loading method is chosen.  
    * **Functional Subsampling**: Loading any valid LAS file with the "Voxel Grid" method selected must successfully apply the subsampling algorithm. This will be evidenced by a measurable reduction in the total number of points loaded into the PointCloudViewerWidget compared to a "Full Load" of the same file.  
    * **Visual Uniformity**: The resulting subsampled point cloud, when rendered in the PointCloudViewerWidget, must exhibit a visually uniform distribution of points, without noticeable gaps or clumps that would indicate an uneven sampling.  
    * **Parameter Impact**: Adjusting the "Leaf Size" parameter (e.g., increasing it from 0.1m to 0.5m) must demonstrably alter the output point count, with larger leaf sizes resulting in a more significant reduction in points. Similarly, increasing "Min Points Per Voxel" should lead to a further reduction, particularly in sparser areas.  
    * **Progress Feedback**: During the loading process for "Voxel Grid" method, the QProgressDialog must accurately display distinct progress messages. This includes an initial "Reading Points..." phase, followed by a clear "Applying Voxel Filter..." message during the subsampling computation.  
    * **Settings Persistence**: The user's chosen "Voxel Grid" method and its specific configured values for "Leaf Size" and "Minimum Points Per Voxel" must be correctly saved to QSettings and persist across application restarts, ensuring that the preferences are automatically loaded the next time the application is launched.  
    * **Unit Test Success**: All newly created unit tests for the VoxelGridFilter class (in tests/test\_voxelgridfilter.cpp) must pass successfully, confirming the algorithmic correctness and robustness of the voxel grid implementation across various input scenarios.  
  * **Testing Plan**:  
    * **Test Case 1**: Verify Voxel Grid UI Controls and Persistence (Manual UI Test)  
      * **Test Data**: N/A (UI interaction only).  
      * **Expected Result**:  
        1. Launch the application.  
        2. Open "Loading Settings..." from the "File" menu.  
        3. Select "Voxel Grid" from the method dropdown. Verify that "Leaf Size" (QDoubleSpinBox) and "Min Points Per Voxel" (QSpinBox) controls become visible.  
        4. Adjust "Leaf Size" to 0.5m and "Min Points Per Voxel" to 3\.  
        5. Click "OK" to save settings and close the dialog.  
        6. Completely close the application.  
        7. Relaunch the application and reopen "Loading Settings...".  
        8. Verify that "Voxel Grid" is still selected as the default method, and the "Leaf Size" and "Min Points Per Voxel" parameters are correctly set to 0.5m and 3, respectively.  
      * **Testing Tool**: Manual UI testing, visual inspection.  
    * **Test Case 2**: Load small\_uniform.las with Voxel Grid (Various Parameters) (Manual UI Test & Visual Inspection)  
      * **Test Data**: small\_uniform.las (a small, valid LAS file with a known, relatively uniform point distribution).  
      * **Expected Result**:  
        1. **Scenario A (Fine Voxel)**: Load with "Leaf Size" 0.1m, "Min Points Per Voxel" 1\. The point count in the status bar should be significantly reduced compared to "Full Load", but the point cloud should still appear visually dense and uniform in the viewer.  
        2. **Scenario B (Coarse Voxel)**: Load with "Leaf Size" 0.5m, "Min Points Per Voxel" 1\. The point count should be further reduced compared to Scenario A, and the visual density should be lower, but still uniform.  
        3. **Scenario C (Filtering Sparse)**: Load with "Leaf Size" 0.1m, "Min Points Per Voxel" 5\. The point count should be reduced, and any naturally sparser areas within the small\_uniform.las (if present) might show further reduction or even small gaps, demonstrating the minPointsPerVoxel effect.  
        4. In all scenarios, the QProgressDialog must display "Applying Voxel Filter..." during the subsampling phase.  
      * **Testing Tool**: Manual UI testing, visual inspection of the PointCloudViewerWidget, verification of point count in the status bar.  
    * **Test Case 3**: Load large\_valid.las with Voxel Grid (Performance Test) (Manual UI Test, Stopwatch, System Monitor)  
      * **Test Data**: large\_valid.las (a large, dense LAS file, e.g., 500MB+ or 1GB+).  
      * **Expected Result**:  
        1. The loading time for large\_valid.las with Voxel Grid (e.g., Leaf Size 0.5m, Min Points 1\) should be significantly faster (aim for 2x-4x speedup) than loading the same file with "Full Load".  
        2. Peak memory usage observed via System Monitor should be substantially lower than during a "Full Load" of the same file.  
        3. The UI should remain responsive throughout the loading process, with no freezing or significant lag.  
        4. The QProgressDialog should accurately reflect the "Reading Points..." and "Applying Voxel Filter..." stages, with smooth progress updates.  
      * **Testing Tool**: Manual UI testing, using a stopwatch to measure load times, and System Monitor (e.g., Windows Task Manager, htop on Linux) to observe real-time memory and CPU utilization.  
    * **Test Case 4**: VoxelGridFilter Unit Tests \- Basic Functionality (Google Test)  
      * **Test Data**:  
        * An empty std::vector\<float\> as input.  
        * A std::vector\<float\> containing only a single point.  
        * A std::vector\<float\> with points perfectly aligned on a grid, where each voxel contains exactly one point.  
        * A LoadingSettings object where leafSize is set to 0.0 (an invalid input).  
      * **Expected Result**:  
        * An empty input vector should result in an empty output vector.  
        * A single point input should result in a single point output (assuming minPointsPerVoxel is 1).  
        * Points perfectly aligned on a grid should be correctly subsampled, with the output point count matching the number of occupied voxels.  
        * leafSize \= 0.0 should be handled gracefully (e.g., throwing an exception, returning the original points, or logging an error, depending on the chosen robust handling strategy).  
      * **Testing Tool**: Google Test (tests/test\_voxelgridfilter.cpp).  
    * **Test Case 5**: VoxelGridFilter Unit Tests \- Min Points Per Voxel Logic (Google Test)  
      * **Test Data**: A std::vector\<float\> containing points specifically arranged to create voxels with varying point counts (e.g., one voxel with 2 points, another with 5 points, and a third with 1 point).  
      * **Expected Result**:  
        * If minPointsPerVoxel is set to 3, the voxel containing 2 points should be entirely ignored (no representative point generated), while the voxel with 5 points should contribute exactly one representative point. The voxel with 1 point should also be ignored.  
      * **Testing Tool**: Google Test (tests/test\_voxelgridfilter.cpp).  
    * **Test Case 6**: Integration Test \- LasParser with Voxel Grid (Google Test)  
      * **Test Data**: small\_uniform.las (or a mocked version of it).  
      * **Expected Result**: A unit test should call LasParser::parse(filePath, {LoadingMethod::VoxelGrid, {"leafSize", 0.1}, {"minPointsPerVoxel", 1}}) and verify that the returned std::vector\<float\> contains the correct number of subsampled points and that their spatial distribution (e.g., bounding box of the output) is consistent with the Voxel Grid operation.  
      * **Testing Tool**: Google Test (tests/test\_lasparser.cpp).

## **Assumptions and Dependencies**

* **Sprint 1 Completion and Stability**: This sprint is critically dependent on the successful and stable completion of all user stories and acceptance criteria from Sprint 1 ("Settings Panel & Core Integration"). This includes the robust functioning of the LoadingSettingsDialog, the LoadingSettings struct, reliable QSettings persistence, and the correct "Full Load" and "Header-Only" functionalities for LAS files. Any instability or incomplete features from Sprint 1 will directly impede progress in Sprint 2\.  
* **Valid LAS File Format Adherence**: It is a core assumption that all LAS files provided for testing and user interaction will adhere to the official LAS file format specification (versions 1.0-1.4). The LasParser is expected to correctly read and interpret the raw point data as per this standard. Any deviations from the standard in input files may lead to unexpected behavior or parsing errors.  
* **Consistent Point Data Structure**: The std::vector\<float\> returned by LasParser and subsequently processed by VoxelGridFilter is assumed to contain point data in a consistent and predictable format. Typically, this means points are stored as sequences of floats (e.g., XYZ, XYZRGB, XYZI), where each point occupies a fixed number of float values. For the Voxel Grid algorithm, the first three float values are always assumed to represent the X, Y, and Z coordinates, respectively.  
* **Memory Availability for Initial Read**: While Voxel Grid subsampling significantly reduces the *final* memory footprint, the algorithm inherently requires that the *initial* raw point data (or at least a substantial chunk of it) can be loaded into memory before the subsampling process begins. This sprint does not introduce full out-of-core processing for the Voxel Grid step itself, meaning that for extremely massive files, there might still be a peak memory requirement during the initial data acquisition phase within LasParser.  
* **Qt6.9.0 and C++17/20**: Development will continue to strictly adhere to the Qt6.9.0 framework and leverage modern C++ standards (C++17 or C++20) for all new code. This ensures compatibility with the existing codebase and allows for the use of modern language features and libraries.

## **Non-Functional Requirements**

* **Performance**:  
  * **Loading Speed Enhancement**: Loading a large LAS file with Voxel Grid subsampling enabled must demonstrate a significant improvement in loading speed, targeting a **2x to 4x speedup** compared to loading the same file with the "Full Load" method. For example, a 60-second full load should ideally reduce to 15-30 seconds with Voxel Grid. This directly impacts user productivity and reduces waiting times.  
  * **Memory Efficiency**: The peak memory consumption during Voxel Grid loading should be **substantially lower** than during a "Full Load" for large datasets. This is crucial for enabling the application to handle files that might otherwise cause out-of-memory errors on typical workstations. The reduction should be proportional to the point count reduction.  
  * **CPU Utilization**: The Voxel Grid filtering process, while not fully parallelized with QtConcurrent in this sprint (that's a focus for Sprint 5), should still exhibit efficient CPU utilization. The algorithm should be optimized to minimize unnecessary computations and memory accesses, ensuring that the processing time is as low as possible for the given serial execution.  
* **Usability**:  
  * **Intuitive Controls**: The newly introduced "Leaf Size" and "Min Points Per Voxel" controls within the settings dialog must be self-explanatory. This includes clear labels, appropriate default values, sensible ranges, and informative tooltips that explain their function and impact on the subsampling process.  
  * **Clear Feedback**: The QProgressDialog and the QStatusBar messages must provide accurate, real-time, and easily understandable feedback to the user regarding the current stage of the Voxel Grid loading process (e.g., "Reading Points...", "Applying Voxel Filter..."). This transparency helps manage user expectations and provides a sense of progress.  
* **Stability**:  
  * **Robustness under Load**: The application must remain consistently stable and responsive during Voxel Grid loading, even when dealing with very large files, highly dense point clouds, or edge-case parameter values (e.g., extremely small leaf sizes that might generate a large number of voxels).  
  * **Error Handling for Parameters**: Error handling for invalid Voxel Grid parameters (e.g., a negative leaf size, or a leaf size of zero) must be robust. The application should either prevent such inputs via UI validation or handle them gracefully in the backend (e.g., by logging an error and defaulting to a safe value) without crashing.  
* **Maintainability**:  
  * **Modular Design**: The VoxelGridFilter class must be designed as a modular, standalone component with a clear API, promoting reusability for other point cloud processing tasks in the future. It should have a clear separation of concerns from the LasParser.  
  * **Code Quality**: All new C++ code developed in this sprint must adhere strictly to the project's established coding standards, including consistent formatting, meaningful variable names, and comprehensive inline comments explaining complex logic, algorithms, and design decisions. This ensures the codebase remains easy to understand, debug, and extend.

## **Conclusion**

Sprint 2 marks a crucial and impactful step in delivering tangible performance improvements to the FARO Scene Registration Software by introducing the Voxel Grid Subsampling capability. By successfully implementing the robust VoxelGridFilter class, seamlessly integrating it into the existing LAS loading pipeline, and providing intuitive user interface controls within the settings panel, users will gain invaluable control over point cloud density and, consequently, loading efficiency. This sprint's success is not merely about adding a feature; it is vital for demonstrating the application's evolving capabilities in intelligently handling and visualizing large datasets. Furthermore, the successful completion of this sprint lays a solid technical and user experience foundation, paving the way for the integration of more advanced subsampling techniques and further significant performance enhancements in subsequent development sprints. The meticulous attention to detail in the backlog, from user stories to comprehensive testing, ensures a high-quality and impactful delivery.