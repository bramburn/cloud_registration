Backlog: Sprint 1 - Settings Panel & Core Integration
Introduction

This document outlines the detailed backlog for Sprint 1: "Settings Panel & Core Integration," as defined in the Product Requirements Document (PRD) for Point Cloud Loading Optimization. This sprint is foundational, laying the essential groundwork for all subsequent advanced loading optimization features. The primary goal is to establish the user-facing interface for loading settings, enable the most fundamental method switching capabilities for LAS files â€“ specifically between a "Full Load" (the current default behavior) and a rapid "Header-Only" inspection. Furthermore, a critical aspect of this sprint is ensuring the persistence of user preferences, so that chosen settings are remembered across application sessions, significantly enhancing user convenience and reducing repetitive configuration. Successful completion of this sprint will deliver immediate value by providing users with basic control over the loading process and a more responsive initial interaction with large datasets.
User Stories

    User Story 1: As a user, I want to access a loading settings panel, so I can configure how point cloud files are loaded.

        Description: This user story focuses on providing a dedicated and easily discoverable graphical interface where users can view and modify the core parameters related to point cloud loading. The panel should be intuitive to navigate, allowing users to quickly understand and select different loading strategies. Its accessibility from the main application window is crucial to ensure users can reach it without extensive searching or complex navigation paths. This panel will serve as the central hub for all future loading optimizations.

        Actions to Undertake:

            Create LoadingSettingsDialog Class: Initiate the development of a new QDialog subclass named LoadingSettingsDialog. This class will encapsulate all the UI elements and logic pertaining to the loading settings.

            Design Basic UI: Within LoadingSettingsDialog, design the initial user interface. This will include a QComboBox (dropdown menu) or a set of QRadioButtons to allow users to select the desired loading method. Initially, the options will be limited to "Full Load" and "Header-Only".

            Implement Dialog Buttons: Add standard QPushButton instances for "Apply", "Cancel", and "OK" to the LoadingSettingsDialog. These buttons will manage the dialog's state, saving changes, discarding them, or applying and closing.

            Create QAction in MainWindow: Introduce a new QAction object within the MainWindow class. This action will be added to the "File" menu, clearly labeled "Loading Settings..." to ensure discoverability.

            Connect QAction to Slot: Establish a signal-slot connection where the triggered() signal of the newly created QAction is connected to a new private slot within MainWindow (e.g., onLoadingSettingsTriggered()). This slot will be responsible for instantiating and displaying the LoadingSettingsDialog as a modal dialog.

        References between Files:

            src/mainwindow.h & src/mainwindow.cpp: These files will be modified to declare and implement the new QAction for the menu item and the corresponding slot to open the LoadingSettingsDialog.

            New files: src/loadingsettingsdialog.h (header for the dialog class) and src/loadingsettingsdialog.cpp (implementation of the dialog's UI and logic).

        Acceptance Criteria:

            A new menu item labeled "Loading Settings..." is clearly visible and accessible under the "File" menu in the MainWindow.

            Clicking this menu item successfully opens a new, modal QDialog window.

            The opened dialog is titled "Point Cloud Loading Settings" to clearly indicate its purpose.

            The dialog's content area includes a control (e.g., a QComboBox or QRadioButtons) that allows the user to select between at least two distinct loading methods: "Full Load" and "Header-Only".

            The dialog correctly displays and responds to "Apply", "Cancel", and "OK" buttons, which close the dialog as expected.

        Testing Plan:

            Test Case 1: Verify dialog opening from menu.

                Test Data: N/A

                Expected Result: Launch the application, navigate to the "File" menu, and click "Loading Settings...". A new modal dialog titled "Point Cloud Loading Settings" should appear on screen.

                Testing Tool: Manual UI testing.

            Test Case 2: Verify dialog buttons functionality.

                Test Data: N/A

                Expected Result: With the "Point Cloud Loading Settings" dialog open, click the "Cancel" button; the dialog should close without applying any changes. Reopen the dialog, select an option (e.g., "Header-Only"), click "OK"; the dialog should close, and the setting should be implicitly applied for subsequent loads (to be verified in US3).

                Testing Tool: Manual UI testing.

    User Story 2: As a user, I want to choose between "Full Load" and "Header-Only" methods for LAS files, so I can control the loading depth.

        Description: This user story enables a fundamental level of control over the LAS file loading process. Users will be able to explicitly choose between loading the entire point cloud dataset ("Full Load"), which provides maximum detail but can be time and memory intensive, or performing a rapid "Header-Only" inspection. The "Header-Only" option is crucial for quickly verifying file integrity, assessing file size, or obtaining basic spatial information without committing to a full data load, which is especially beneficial for very large files. This choice directly impacts the application's responsiveness and resource consumption.

        Actions to Undertake:

            Define LoadingSettings Struct/Class: Create a new C++ struct or class, LoadingSettings, in a dedicated header file (src/loadingsettings.h). This struct will serve as a container for the currently selected LoadingMethod (an enum, e.g., LoadingMethod::FullLoad, LoadingMethod::HeaderOnly) and will be extensible to include future method-specific parameters using QVariantMap.

            Update LoadingSettingsDialog: Modify the LoadingSettingsDialog to instantiate and manage an instance of the LoadingSettings struct. When the user selects a method from the QComboBox or QRadioButtons, the LoadingSettingsDialog's internal LoadingSettings object should be updated accordingly.

            Modify MainWindow::onOpenFileClicked: Adjust the existing MainWindow::onOpenFileClicked slot. Instead of directly calling LasParser::parse() without parameters, it will now retrieve the current LoadingSettings (preferably from QSettings for persistence, as detailed in US3) and pass this object as an argument to the LasParser::parse() method.

            Update LasParser::parse Signature: Change the signature of the LasParser::parse() method to accept a const LoadingSettings& as a parameter. This makes the parsing logic dependent on user preferences.

            Implement Conditional Parsing Logic: Within LasParser::parse(), implement conditional branching based on the LoadingSettings.method value. If LoadingMethod::FullLoad is selected, the parser will proceed with its existing logic to read the entire LAS file, including all point data. If LoadingMethod::HeaderOnly is selected, the parser will only read the LAS file header.

            "Header-Only" Return Behavior: When in "Header-Only" mode, LasParser::parse() should read the header successfully, populate its internal metadata members (e.g., m_pointCount, m_boundingBoxMin, m_boundingBoxMax), but it must return an empty std::vector<float> for the point data. This ensures no point data is loaded into memory, making the operation extremely fast.

        References between Files:

            src/mainwindow.cpp: This file will be modified to retrieve the LoadingSettings and pass it as an argument when invoking LasParser::parse().

            src/lasparser.h & src/lasparser.cpp: These files will undergo significant modification to their parse() method signature and internal logic to accept LoadingSettings and implement the conditional parsing (full vs. header-only).

            New file: src/loadingsettings.h: This header will contain the definition of the LoadingSettings struct/class and the LoadingMethod enum.

            src/loadingsettingsdialog.h & src/loadingsettingsdialog.cpp: These files will be updated to manage the LoadingSettings object internally and provide a getSettings() method to retrieve the current configuration.

        Acceptance Criteria:

            When "Full Load" is the active setting, opening any valid LAS file results in all points being loaded and displayed in the PointCloudViewerWidget, behaving identically to the application's current baseline functionality.

            When "Header-Only" is the active setting, opening any valid LAS file completes almost instantaneously (e.g., within 100-200 milliseconds for typical files, regardless of size).

            In "Header-Only" mode, the PointCloudViewerWidget remains empty or is explicitly cleared if a previous point cloud was loaded, confirming that no point data has been rendered.

            A unit test confirms that when LasParser::parse() is invoked with LoadingMethod::HeaderOnly, the returned std::vector<float> containing point data has a size of zero.

            No regressions are observed in the existing "Full Load" LAS file loading functionality; it remains stable and correct.

        Testing Plan:

            Test Case 1: Load a small LAS file with "Full Load" selected.

                Test Data: test_small.las (a small, valid LAS file, e.g., 1MB, with a few thousand points).

                Expected Result: The file loads completely, and all points are rendered accurately in the PointCloudViewerWidget. The loading time should be consistent with the current baseline performance.

                Testing Tool: Manual UI testing, augmented by a modified LasParserTest unit test to verify the full point data is correctly parsed when LoadingMethod::FullLoad is used.

            Test Case 2: Load the same small LAS file with "Header-Only" selected.

                Test Data: test_small.las.

                Expected Result: The file loads extremely quickly (perceived as instantaneous). The PointCloudViewerWidget should display no points. The status bar should update with correct metadata (as per User Story 4).

                Testing Tool: Manual UI testing, observing loading speed and viewer state.

            Test Case 3: Verify LasParser::parse returns empty vector in "Header-Only" mode (Unit Test).

                Test Data: A path to test_small.las (the actual file content can be mocked for the unit test, focusing on the return behavior).

                Expected Result: A direct call to LasParser::parse(filePath, {LoadingMethod::HeaderOnly}) should return a std::vector<float> object whose size() method returns 0.

                Testing Tool: Google Test (tests/test_lasparser.cpp).

    User Story 3: As a user, I want my loading preferences to be saved, so I don't have to reconfigure them every time.

        Description: This user story addresses a crucial aspect of user convenience and application usability. By persisting the selected loading method and any associated parameters across application sessions, users are spared the repetitive task of reconfiguring their preferred loading options every time they launch the software. This creates a more seamless and personalized workflow, as the application remembers their last-used settings, allowing them to jump directly into their tasks. QSettings provides a robust, cross-platform mechanism for storing application-specific user preferences.

        Actions to Undertake:

            Implement QSettings Write Operations: Within the LoadingSettingsDialog class, implement logic to save the currently selected LoadingMethod (and any future parameters stored in LoadingSettings.parameters) to QSettings. This save operation should be triggered when the "Apply" or "OK" buttons are clicked, ensuring that user changes are committed. The settings should be stored under a clear key, e.g., "PointCloudLoading/DefaultMethod".

            Implement QSettings Read Operations: In the constructor of the LoadingSettingsDialog, implement logic to read the previously saved LoadingSettings from QSettings. These retrieved settings should then be used to initialize the UI controls (e.g., setting the QComboBox to the last selected method) when the dialog is opened. If no settings are found (first launch), default values should be used (e.g., LoadingMethod::FullLoad).

            Retrieve Settings in MainWindow: Modify MainWindow::onOpenFileClicked (and any other relevant file loading entry points) to retrieve the active LoadingSettings directly from QSettings before initiating the LasParser::parse() call. This ensures that the application always uses the user's saved preferences for file loading, even if the settings dialog hasn't been explicitly opened in the current session. The LoadingSettingsDialog's primary role will then be to update these QSettings.

        References between Files:

            src/loadingsettingsdialog.h & src/loadingsettingsdialog.cpp: These files will be the primary location for implementing QSettings read and write logic, ensuring persistence of the LoadingSettings object.

            src/mainwindow.cpp: This file will be modified to read the current LoadingSettings from QSettings before passing them to the LasParser.

        Acceptance Criteria:

            After selecting a loading method (e.g., "Header-Only") in the "Point Cloud Loading Settings" dialog and clicking "OK" or "Apply", then closing and reopening the application, the "Loading Settings" dialog, when reopened, correctly displays the previously selected method.

            When the application is launched and a LAS file is opened (without explicitly opening the settings dialog), the file is loaded using the method that was last saved (e.g., if "Header-Only" was last saved, the file loads in "Header-Only" mode).

        Testing Plan:

            Test Case 1: Save and load settings persistence (manual end-to-end).

                Test Data: N/A

                Expected Result:

                    Launch the application.

                    Open "Loading Settings...", select "Header-Only" from the dropdown, and click "OK".

                    Close the application completely.

                    Relaunch the application.

                    Open "Loading Settings...". Verify that "Header-Only" is still pre-selected in the dropdown.

                    Load test_small.las via "File -> Open". Verify that it loads quickly and no points are displayed (confirming "Header-Only" mode is active).

                Testing Tool: Manual UI testing.

    User Story 4: As a user, I want to see basic file metadata after a "Header-Only" load, so I can quickly verify file content.

        Description: When a user opts for a "Header-Only" load, the immediate visual feedback (lack of points) needs to be complemented by concrete information about the file. Displaying key metadata such as the total point count and the bounding box (spatial extent) directly in the UI (e.g., in the status bar) provides crucial context. This allows the user to quickly confirm that they've selected the correct file and understand its basic characteristics without the overhead of a full data load. It transforms a seemingly "empty" load into a valuable information retrieval step.

        Actions to Undertake:

            Modify LasParser to Store Metadata: Enhance the LasParser class to store the parsed header metadata (specifically numberOfPointRecords, minBounds, maxBounds) as private member variables (e.g., m_pointCount, m_boundingBoxMin, m_boundingBoxMax). These should be populated during any successful header read, regardless of whether it's a full or header-only load.

            Define LasHeaderMetadata Struct: Create a new lightweight struct, LasHeaderMetadata (in src/lasheadermetadata.h), to encapsulate these key header properties. This struct will be used to pass the metadata across thread boundaries safely.

            Add New LasParser Signal: Introduce a new Q_SIGNAL in LasParser (e.g., headerParsed(const LasHeaderMetadata& metadata)). This signal will be emitted by the LasParser worker thread immediately after a successful header read, carrying the LasHeaderMetadata struct.

            Connect Signals in MainWindow: In MainWindow, establish a Qt::QueuedConnection between the LasParser's new headerParsed signal and a new slot in MainWindow (e.g., onLasHeaderParsed(const LasHeaderMetadata& metadata)). This ensures thread-safe reception of the metadata on the main UI thread.

            Update MainWindow UI: Implement the onLasHeaderParsed slot in MainWindow to take the received LasHeaderMetadata and update the QStatusBar with a concise summary. The message should include the file name, total point count, and the min/max X, Y, Z coordinates of the bounding box (e.g., "File: [filename], Points: [count], BBox: [minX,minY,minZ]-[maxX,maxY,maxZ]").

        References between Files:

            src/lasparser.h & src/lasparser.cpp: These files will be modified to store the parsed header metadata internally and to emit the new headerParsed signal.

            src/mainwindow.h & src/mainwindow.cpp: These files will be modified to declare the new slot (onLasHeaderParsed) and establish the signal-slot connection with LasParser, and to update the QStatusBar.

            New struct: src/lasheadermetadata.h: This file will define the structure for passing LAS header information.

        Acceptance Criteria:

            After successfully performing a "Header-Only" load of a LAS file, the MainWindow's status bar (or a clearly designated information area) prominently displays the total number of points from the LAS file header.

            The status bar also displays the minimum and maximum X, Y, Z coordinates of the bounding box, accurately reflecting the spatial extent of the LAS file.

            This displayed metadata updates correctly and immediately when different LAS files are loaded in "Header-Only" mode.

        Testing Plan:

            Test Case 1: Verify status bar updates for "Header-Only" load.

                Test Data: test_known_metadata.las (a LAS file with pre-verified point count and bounding box coordinates).

                Expected Result: Load test_known_metadata.las with "Header-Only" selected. The status bar should display a message like "File: test_known_metadata.las, Points: 1234567, BBox: (-10.0,-5.0,0.0)-(10.0,5.0,20.0)" (with actual values).

                Testing Tool: Manual UI testing, cross-referencing with known file metadata.

            Test Case 2: LasParser emits correct header metadata (Unit Test).

                Test Data: A mocked LasParser instance that simulates reading a LAS header and emitting the headerParsed signal with specific LasHeaderMetadata values.

                Expected Result: A Google Test should verify that the headerParsed signal is emitted and that the LasHeaderMetadata struct passed through the signal contains the correct numberOfPointRecords, minBounds, and maxBounds values.

                Testing Tool: Google Test (tests/test_lasparser.cpp).

Actions to Undertake (Consolidated)

    UI Development (LoadingSettingsDialog):

        Create src/loadingsettings.h to define the LoadingSettings struct and LoadingMethod enum, serving as the central data model for preferences.

        Create src/loadingsettingsdialog.h and src/loadingsettingsdialog.cpp to implement the QDialog for user settings. This includes setting up the main layout, QComboBox for method selection ("Full Load", "Header-Only"), and QPushButtons for "Apply", "Cancel", and "OK".

        Implement the slot connections for onApplyClicked(), onOkClicked(), onCancelClicked(), and onMethodChanged(int index) within LoadingSettingsDialog.cpp to manage dialog state and update internal settings.

        Integrate QSettings read/write operations within LoadingSettingsDialog's constructor and onApplyClicked()/onOkClicked() to ensure persistence of the LoadingSettings object across application sessions.

    MainWindow Integration:

        Modify src/mainwindow.h to declare a new QAction for "Loading Settings..." and a slot (e.g., onLoadingSettingsTriggered()) to handle its activation.

        Modify src/mainwindow.cpp to create and add the "Loading Settings..." QAction to the "File" menu, connecting its triggered() signal to onLoadingSettingsTriggered().

        Update MainWindow::onOpenFileClicked to retrieve the current LoadingSettings from QSettings before initiating any file parsing, ensuring user preferences are respected.

        Declare a new slot in src/mainwindow.h (e.g., onLasHeaderParsed(const LasHeaderMetadata& metadata)) to receive header information from LasParser.

        Implement onLasHeaderParsed in src/mainwindow.cpp to update the QStatusBar with the file's point count and bounding box.

        Establish a Qt::QueuedConnection from the LasParser's headerParsed signal to MainWindow::onLasHeaderParsed.

    LasParser Refactoring:

        Modify src/lasparser.h to update the signature of the parse() method to accept a const LoadingSettings& parameter.

        Add new private member variables to src/lasparser.h to store parsed header metadata (m_pointCount, m_boundingBoxMin, m_boundingBoxMax).

        Declare a new Q_SIGNAL in src/lasparser.h: headerParsed(const LasHeaderMetadata& metadata).

        Modify src/lasparser.cpp to implement conditional logic within parse(): if LoadingMethod::HeaderOnly is selected, only read the header, populate metadata members, emit headerParsed, and return an empty std::vector<float>. If LoadingMethod::FullLoad, proceed with full parsing.

        Ensure that the headerParsed signal is emitted after any successful header read, regardless of the loading method.

    Unit Testing:

        Update tests/test_lasparser.cpp to include new test cases specifically for:

            Verifying that LasParser::parse() returns an empty std::vector<float> when LoadingMethod::HeaderOnly is used.

            Confirming that LasParser correctly populates its internal metadata members and emits the headerParsed signal with accurate LasHeaderMetadata for both "Full Load" and "Header-Only" scenarios.

        Add new unit tests for LoadingSettingsDialog to verify QSettings read/write operations and correct UI initialization based on saved settings.

References between Files

    src/mainwindow.h <-> src/mainwindow.cpp: These files form the core application UI and logic. mainwindow.h declares elements and slots, mainwindow.cpp implements them, including menu actions, signal/slot connections, and interaction with other components.

    src/mainwindow.cpp -> src/lasparser.h: MainWindow initiates the parsing process by calling LasParser::parse(), passing the LoadingSettings object to control parsing behavior.

    src/mainwindow.cpp <- src/lasparser.h: MainWindow connects to LasParser's parsingFinished signal (existing) and the new headerParsed signal to receive updates and display information on the UI.

    src/loadingsettings.h <-> src/loadingsettingsdialog.h <-> src/loadingsettingsdialog.cpp: This set of files defines the data structure for loading preferences (loadingsettings.h), the UI dialog for managing these preferences (loadingsettingsdialog.h), and its implementation (loadingsettingsdialog.cpp), which also handles saving/loading preferences via QSettings.

    src/loadingsettings.h -> src/lasparser.h: The LasParser class directly uses the LoadingSettings struct to determine its parsing behavior.

    src/lasparser.h <-> src/lasparser.cpp: These files contain the core logic for reading LAS files. lasparser.h declares the class, its methods, and signals, while lasparser.cpp provides the implementation for reading headers, points, and emitting progress/metadata.

    src/lasheadermetadata.h -> src/lasparser.h & src/mainwindow.h: lasheadermetadata.h defines the data structure used by LasParser to emit header information, and by MainWindow to receive and display it.

    tests/test_lasparser.cpp -> src/lasparser.h: The unit tests in test_lasparser.cpp directly interact with the LasParser class to verify its functionality, including the new header-only mode and metadata emission.

List of Files being Created

    File 1: src/loadingsettings.h

        Purpose: This header file defines the fundamental data structure that encapsulates the user's chosen point cloud loading method and any associated parameters. It acts as a lightweight, centralized configuration object passed between UI and backend components.

        Contents:

        #ifndef LOADINGSETTINGS_H
        #define LOADINGSETTINGS_H

        #include <QVariantMap> // Used for storing flexible, method-specific parameters

        // Enum to define the available point cloud loading methods
        enum class LoadingMethod {
            FullLoad,    // Loads all points and attributes (current baseline)
            HeaderOnly,  // Reads only the file header for metadata
            // Future methods will be added here (e.g., VoxelGrid, PoissonDisk)
        };

        // Struct to hold the selected loading method and its parameters
        struct LoadingSettings {
            LoadingMethod method = LoadingMethod::FullLoad; // Default to full load
            QVariantMap parameters; // A map to store key-value pairs for method-specific settings
                                    // (e.g., "leafSize" for VoxelGrid, "keepPercentage" for Random)
        };

        #endif // LOADINGSETTINGS_H

        Relationships: This file is a dependency for src/loadingsettingsdialog.h, src/mainwindow.h, and src/lasparser.h, as all these components need to understand and utilize the LoadingSettings configuration.

    File 2: src/loadingsettingsdialog.h

        Purpose: This header defines the QDialog subclass responsible for presenting the point cloud loading options to the user. It declares the UI elements, slots for user interaction, and private methods for managing settings persistence.

        Contents:

        #ifndef LOADINGSETTINGSDIALOG_H
        #define LOADINGSETTINGSDIALOG_H

        #include <QDialog>
        #include <QComboBox>     // For method selection dropdown
        #include <QPushButton>   // For Apply, OK, Cancel buttons
        #include <QVBoxLayout>   // For vertical arrangement of UI elements
        #include <QSettings>     // For reading and writing application settings
        #include "loadingsettings.h" // Dependency for the LoadingSettings struct

        class LoadingSettingsDialog : public QDialog
        {
            Q_OBJECT // Macro required for Qt's meta-object system (signals/slots)

        public:
            // Constructor: initializes the dialog with a parent widget
            explicit LoadingSettingsDialog(QWidget *parent = nullptr);
            // Destructor: cleans up resources
            ~LoadingSettingsDialog();

            // Public method to retrieve the currently configured loading settings
            LoadingSettings getSettings() const;

        private slots:
            // Slots for button clicks and combo box changes
            void onApplyClicked();
            void onOkClicked();
            void onCancelClicked();
            void onMethodChanged(int index); // Triggered when combo box selection changes

        private:
            // Private helper methods for managing settings persistence
            void loadSettings(); // Reads settings from QSettings
            void saveSettings(); // Writes settings to QSettings
            // Private helper method to update UI elements based on selected method
            void updateUIForMethod(LoadingMethod method);

            // UI Components
            QComboBox *m_methodComboBox;
            QPushButton *m_applyButton;
            QPushButton *m_okButton;
            QPushButton *m_cancelButton;
            QVBoxLayout *m_mainLayout;       // Main layout for the dialog
            QVBoxLayout *m_parametersLayout; // Layout for dynamically added parameter widgets (future sprints)

            // Internal state
            LoadingSettings m_currentSettings; // Holds the dialog's current settings
            QSettings m_qSettings;             // QSettings object for persistence
        };

        #endif // LOADINGSETTINGSDIALOG_H

        Relationships: This file depends on src/loadingsettings.h. It is used by src/mainwindow.h (to declare an instance of the dialog).

    File 3: src/loadingsettingsdialog.cpp

        Purpose: This source file contains the implementation details for the LoadingSettingsDialog. It includes the constructor (setting up the UI, connecting signals/slots, loading initial settings), the logic for handling button clicks, updating settings based on user input, and the concrete implementation of QSettings read/write operations.

        Contents: (This file will contain the C++ code that implements the UI layout, populates the combo box, handles user interactions, and manages the saving and loading of LoadingSettings using QSettings).

        Relationships: This file implements src/loadingsettingsdialog.h. It directly interacts with the QSettings API for application-wide preference management.

    File 4: src/lasheadermetadata.h

        Purpose: This header file defines a simple, lightweight struct specifically designed to carry essential metadata extracted from the LAS file header. This struct provides a type-safe and organized way to pass header information (like point count and bounding box) from the LasParser (potentially running in a separate thread) to the MainWindow for display.

        Contents:

        #ifndef LASHEADERMETADATA_H
        #define LASHEADERMETADATA_H

        #include <QString>
        #include <QVector3D> // For representing 3D coordinates (min/max bounds)
        #include <cstdint>   // For fixed-width integer types like uint32_t

        // Struct to hold key metadata extracted from a LAS file header
        struct LasHeaderMetadata {
            uint32_t numberOfPointRecords = 0; // Total number of points in the file
            QVector3D minBounds;               // Minimum X, Y, Z coordinates of the bounding box
            QVector3D maxBounds;               // Maximum X, Y, Z coordinates of the bounding box
            QString filePath;                  // The path of the file this metadata belongs to (for display)
            // Additional relevant header information can be added here in future sprints
        };

        #endif // LASHEADERMETADATA_H

        Relationships: This file is a dependency for src/lasparser.h (as LasParser will emit this struct) and src/mainwindow.h (as MainWindow will receive and process this struct).

Acceptance Criteria (Consolidated)

    Settings Dialog Accessibility and Functionality:

        The "Loading Settings..." menu item must be clearly visible and accessible under the "File" menu in the MainWindow.

        Clicking this menu item shall reliably open a new, modal QDialog window, which must be titled "Point Cloud Loading Settings".

        Within the dialog, a user-friendly control (e.g., a QComboBox or QRadioButtons group) must be present, offering at least two distinct loading options: "Full Load" and "Header-Only".

        The dialog must include functional "Apply", "Cancel", and "OK" buttons. "Cancel" should close the dialog without saving changes. "Apply" should save changes without closing. "OK" should save changes and close the dialog.

    LAS Loading Method Selection Verification:

        When "Full Load" is the active setting in the "Point Cloud Loading Settings" dialog, any subsequent LAS file loads must behave identically to the current application's baseline functionality, meaning all points are loaded into memory and correctly displayed in the PointCloudViewerWidget.

        Conversely, when "Header-Only" is the active setting, any subsequent LAS file loads must complete with near-instantaneous speed (e.g., within 100-200 milliseconds for a file of any size, purely reading the header).

        In "Header-Only" mode, the PointCloudViewerWidget must explicitly display no points, or be cleared if points from a previous load were present, visually confirming that no point data has been loaded.

        A dedicated unit test must confirm that when the LasParser::parse() method is invoked with LoadingMethod::HeaderOnly specified in the LoadingSettings, the returned std::vector<float> (intended for point data) has a size of zero, indicating no points were loaded.

    Settings Persistence Across Sessions:

        After a user selects a specific loading method (e.g., "Header-Only") within the "Point Cloud Loading Settings" dialog and confirms their choice (e.g., by clicking "OK" or "Apply"), then closes the application and subsequently reopens it, the "Loading Settings" dialog, when accessed again, must correctly display the previously selected method as its default.

        Furthermore, upon application relaunch, and without the user explicitly opening the settings dialog, any subsequent LAS file loading operation (e.g., via "File -> Open") must automatically utilize the last saved loading method from QSettings.

    Header Metadata Display for "Header-Only" Loads:

        Following a successful "Header-Only" load of a LAS file, the MainWindow's status bar (or another clearly designated, persistent information area in the UI) must prominently display the total number of point records extracted directly from the LAS file header.

        In addition to the point count, the status bar must also accurately present the minimum and maximum X, Y, Z coordinates of the file's bounding box, providing a quick spatial overview.

        This displayed metadata must update dynamically and correctly whenever a different LAS file is loaded in "Header-Only" mode.

    Overall Stability and No Regressions:

        All existing functionalities of the application (e.g., basic file opening, 3D viewer navigation, UCS display, existing menu items) must remain fully functional, stable, and exhibit no degradation in performance.

        The application must not experience any crashes, freezes, or unresponsiveness during any stage of file selection, settings modification, or point cloud loading operations, including scenarios involving invalid or non-existent files. Error messages should be informative and non-blocking.

Testing Plan

The testing plan will employ a hybrid approach, combining rigorous manual UI testing to verify user experience and visual correctness with automated unit tests using the Google Test framework for precise validation of backend logic and data integrity.

    Test Data:

        small_valid.las: A small, well-formed LAS file (e.g., 1MB, 50,000 points) with known point count and bounding box. This is ideal for quick functional verification.

        large_valid.las: A large, valid LAS file (e.g., 500MB+, millions of points) to specifically test performance differences between "Full Load" and "Header-Only" and observe UI responsiveness.

        corrupted_header.las: A deliberately crafted LAS file where the header signature or version information is incorrect, designed to trigger error handling paths.

        non_existent.las: A file path that does not correspond to any actual file on the system, for testing file not found scenarios.

    Testing Tools:

        Manual UI Testing: This will be the primary tool for verifying the visual appearance of the LoadingSettingsDialog, the responsiveness of the MainWindow during loading, the correctness of status bar updates, and the overall user experience.

        Google Test: This C++ testing framework will be used for writing automated unit tests. It's crucial for validating the internal logic of LasParser (e.g., correct header parsing, empty vector return), LoadingSettingsDialog (e.g., QSettings interaction), and other backend components.

        System Monitor (e.g., Windows Task Manager, Linux htop, macOS Activity Monitor): Used to observe CPU and memory usage during loading operations, particularly for large_valid.las in "Header-Only" vs. "Full Load" modes, to confirm performance improvements.

    Test Cases (Detailed):

        Test Case 1: Open Loading Settings Dialog

            Test Data: N/A

            Expected Result:

                Launch the application.

                Navigate to "File" menu -> "Loading Settings...".

                A new modal QDialog titled "Point Cloud Loading Settings" should appear.

                The dialog should contain a QComboBox (or QRadioButtons) with "Full Load" and "Header-Only" options.

                "Apply", "Cancel", and "OK" buttons should be visible and clickable.

            Testing Tool: Manual UI testing.

        Test Case 2: Save and Load Settings Persistence

            Test Data: N/A

            Expected Result:

                Launch the application.

                Open "Loading Settings...", select "Header-Only" from the method dropdown.

                Click "OK" to save and close the dialog.

                Completely close the application (e.g., via "File -> Exit").

                Relaunch the application.

                Open "Loading Settings..." again. Verify that "Header-Only" is still the pre-selected option in the dropdown.

                Load small_valid.las via "File -> Open". Verify that it loads very quickly and no points are displayed, confirming the persisted "Header-Only" setting is active.

            Testing Tool: Manual UI testing.

        Test Case 3: Load small_valid.las with "Full Load"

            Test Data: small_valid.las

            Expected Result:

                Ensure "Full Load" is selected in settings.

                Load small_valid.las. The file should load successfully within its expected baseline time (e.g., a few seconds).

                All points from small_valid.las should be correctly rendered and displayed in the PointCloudViewerWidget.

                The QStatusBar should update to indicate successful loading (e.g., "Successfully loaded X points").

            Testing Tool: Manual UI testing, visual inspection of the loaded point cloud.

        Test Case 4: Load large_valid.las with "Header-Only"

            Test Data: large_valid.las

            Expected Result:

                Ensure "Header-Only" is selected in settings.

                Load large_valid.las. The file should load almost instantly (perceived as immediate, typically under 200ms).

                The PointCloudViewerWidget should display no points. If points were previously loaded, they should be cleared.

                The QStatusBar should update immediately with the correct point count and bounding box for large_valid.las (e.g., "File: large_valid.las, Points: [correct count], BBox: [correct min]-[correct max]").

                System Monitor should show minimal CPU and memory spike during the load.

            Testing Tool: Manual UI testing, stopwatch for timing, System Monitor for resource observation.

        Test Case 5: LasParser::parse returns empty vector in "Header-Only" mode (Unit Test)

            Test Data: A path to a valid LAS file (e.g., test_small.las). The test will mock file I/O if necessary to isolate the parsing logic.

            Expected Result: A unit test function (e.g., TEST_F(LasParserTest, HeaderOnlyReturnsEmptyVector)) should call LasParser::parse(filePath, {LoadingMethod::HeaderOnly}). The std::vector<float> object returned by this call must have its size() method return 0.

            Testing Tool: Google Test (tests/test_lasparser.cpp).

        Test Case 6: LasParser emits correct header metadata in "Header-Only" mode (Unit Test)

            Test Data: A mocked LAS file header with known numberOfPointRecords, minBounds, and maxBounds.

            Expected Result: A unit test (e.g., TEST_F(LasParserTest, HeaderOnlyEmitsCorrectMetadata)) should verify that when LasParser::parse() is called with LoadingMethod::HeaderOnly, the headerParsed signal is emitted, and the LasHeaderMetadata struct passed as an argument contains the precise numberOfPointRecords, minBounds, and maxBounds values corresponding to the mocked header.

            Testing Tool: Google Test (tests/test_lasparser.cpp).

        Test Case 7: Error Handling - Corrupted LAS Header

            Test Data: corrupted_header.las

            Expected Result:

                Attempting to open corrupted_header.las (with either "Full Load" or "Header-Only" selected) should result in a non-blocking QMessageBox appearing.

                The message box should be titled "Loading Error" and contain a user-friendly message indicating an invalid or corrupted LAS file header.

                The QStatusBar should update to "Failed to load file: [filename]".

                The application must remain stable and responsive, without crashing or freezing.

            Testing Tool: Manual UI testing.

        Test Case 8: Error Handling - Non-Existent File

            Test Data: non_existent.las (a path that does not exist).

            Expected Result:

                Attempting to open non_existent.las should trigger a QMessageBox.

                The message box should be titled "Loading Error" and clearly state "File not found" or similar.

                The QStatusBar should update to "Failed to load file: [filename]".

                The application must remain stable and responsive.

            Testing Tool: Manual UI testing.

Assumptions and Dependencies

    Qt6.9.0 and C++17/20: The entire project will continue to be developed using the Qt6.9.0 framework and leverage features available in C++17 or C++20 standards, ensuring compatibility and modern programming practices.

    Existing LasParser and E57Parser Baseline: This sprint's development assumes that the current LasParser is functional for its "Full Load" behavior and that E57Parser correctly handles its mock data generation. Full E57 parsing is explicitly out of scope for Sprint 1 and will be addressed in later sprints.

    No Third-Party Libraries for LAS in Sprint 1: All LAS file parsing, including header reading and basic point data interpretation for "Full Load" and "Header-Only" modes, will be implemented natively in C++ using standard library features and Qt's file I/O capabilities. No external LAS-specific libraries will be introduced in this sprint.

    File System Access: It is assumed that the application will have the necessary read permissions to access and open point cloud files from the user's local file system.

    User Interface Framework: The application's user interface will continue to be built exclusively using Qt Widgets, leveraging its mature and robust UI components.

    Single-Threaded Parsing for Header-Only: While LasParser runs in a QThread, the "Header-Only" logic itself is simple enough not to require internal multi-threading; it's primarily about efficient file I/O.

Non-Functional Requirements

    Performance:

        "Header-Only" Loading Speed: The loading time for LAS files when "Header-Only" is selected must be near-instantaneous, specifically targeted to be under 100 milliseconds for typical files, regardless of the overall file size. This ensures a fluid and responsive user experience for quick file inspection.

        "Full Load" Performance Baseline: The performance of "Full Load" for LAS files must not degrade. It should maintain or ideally slightly improve upon the current application's baseline loading speed, ensuring that the introduction of new settings does not negatively impact existing functionality.

    Usability:

        Intuitive Settings Dialog: The "Loading Settings" dialog must be designed with a clear, intuitive layout, making it easy for users to understand the available options and their implications without needing external documentation.

        Clear Status Bar Messages: All messages displayed in the QStatusBar related to file loading (success, failure, metadata) must be concise, informative, and easily understandable by the end-user.

    Stability:

        Application Robustness: The application must exhibit high stability, preventing crashes or unresponsiveness during all file-related operations, including opening files, changing settings, and handling error conditions (e.g., corrupted files, non-existent paths). Error messages should be gracefully presented via QMessageBox without disrupting the application flow.

    Maintainability:

        Code Quality: All newly developed code must adhere to established C++ coding standards, be well-structured, and include comprehensive comments explaining complex logic, algorithms, and class responsibilities.

        Modular Design: New classes such as LoadingSettingsDialog, LoadingSettings, and LasHeaderMetadata must have clear, single responsibilities, promoting modularity and ease of future expansion or modification.

Conclusion

Sprint 1 represents a pivotal step in enhancing the FARO Scene Registration Software's point cloud loading capabilities. By successfully delivering the user-configurable settings panel, enabling the fundamental "Full Load" and "Header-Only" options for LAS files, ensuring the persistence of user preferences, and providing immediate, informative feedback through header metadata display, this sprint will provide tangible user value. It establishes a robust and extensible foundation upon which all subsequent, more complex subsampling algorithms and full E57 parsing features will be built. The meticulous planning and detailed acceptance criteria outlined herein are crucial for ensuring a high-quality outcome for this foundational sprint.