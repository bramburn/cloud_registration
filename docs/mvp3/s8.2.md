# Detailed Backlog: Sprint 8, Sub-Sprint 8.2 - UI/UX Refinement & User Feedback Integration

## Introduction

This document provides a detailed backlog for Sub-Sprint 8.2: UI/UX
Refinement & User Feedback Integration. This sub-sprint focuses on
enhancing the overall look, feel, and usability of the application based
on design best practices and anticipated user feedback. It aims to
deliver a polished, intuitive, and consistent user interface,
contributing significantly to the \"Final Polish\" phase.

## User Stories

- **User Story 1**: As a user, I want the application to look and feel
  professional and modern, with consistent styling.

  - **Description**: This involves applying a cohesive visual theme,
    ensuring consistent design elements (buttons, inputs, labels,
    panels), and updating iconography to create a polished and modern
    aesthetic across the entire application.

  - **Actions to Undertake**:

    1.  **Review UIThemeManager**: Analyze the existing
        src/ui/include/ui/UIThemeManager.h and
        src/ui/src/UIThemeManager.cpp. Ensure it provides a
        comprehensive set of colors, fonts, and potentially styling
        rules (e.g., using QSS - Qt Style Sheets).

    2.  **Define Visual Theme**: Establish a clear set of design
        guidelines for colors, fonts (e.g., \"Inter\" as specified in
        instructions), border-radius (rounded corners on all elements),
        and spacing. Translate these into UIThemeManager properties.

    3.  **Apply Global Stylesheet**: In src/app/src/main.cpp (or
        MainPresenter\'s initialization), apply a global QSS string
        generated by UIThemeManager::generateAllComponentStyles().

    4.  **Refine Individual Widgets**: Go through AlignmentControlPanel,
        ExportDialog, ICPParameterDialog, TargetDetectionDialog,
        PoseGraphViewerWidget, SidebarWidget, MainWindow, and other
        custom widgets:

        - Replace any hardcoded styles (e.g.,
          setStyleSheet(\"background-color: blue;\")) with calls to
          UIThemeManager::instance().getColorHex(UIThemeManager::ColorRole::PrimaryBackground)
          or similar.

        - Ensure border-radius is applied to all relevant elements via
          QSS.

        - Standardize font usage to \"Inter\" (or another appropriate
          font) where custom fonts are required.

    5.  **Update Iconography**:

        - Review all existing icons. Replace low-quality or inconsistent
          icons.

        - Prefer lucide-react (for web components), Font Awesome (for
          specific game icons if applicable), or inline SVG for vector
          graphics. For desktop Qt, use QIcon from SVG files or
          QStyle::StandardPixmap.

        - Ensure consistent icon sizes and styles across the
          application.

  - **References between Files**:

    - UIThemeManager.h / UIThemeManager.cpp: Core styling definitions
      and QSS generation.

    - src/app/src/main.cpp: Applies global stylesheet.

    - Various src/ui/ widget .h/.cpp files: Will be modified to use
      UIThemeManager and QSS.

    - Resource files (.qrc): May include new SVG icons.

  - **Acceptance Criteria**:

    - The application has a consistent, modern visual theme throughout
      all its UI components.

    - All interactive elements (buttons, input fields) and panels have
      rounded corners.

    - Typography is consistent (e.g., \"Inter\" font) and legible.

    - Icons are high-quality, consistent in style, and clearly convey
      their function.

    - No visible hardcoded styles remain; all styling uses
      UIThemeManager or global QSS.

  - **Testing Plan**:

    - **Test Case 1**: Global Stylesheet Application.

      - **Test Data**: Launch application.

      - **Expected Result**: All standard Qt widgets (buttons, text
        inputs, etc.) inherit the global QSS properties (e.g., rounded
        corners, consistent background/foreground colors).

      - **Testing Tool**: Manual Visual Inspection.

    - **Test Case 2**: UIThemeManager Integration in Custom Widgets.

      - **Test Data**: Open various custom dialogs/panels
        (AlignmentControlPanel, ExportDialog, etc.).

      - **Expected Result**: Custom widgets correctly apply styles from
        UIThemeManager and avoid visual inconsistencies.

      - **Testing Tool**: Manual Visual Inspection.

    - **Test Case 3**: Icon Consistency.

      - **Test Data**: Review all menus, toolbars, and buttons.

      - **Expected Result**: All icons are clear, consistently sized,
        and visually match the application\'s theme.

      - **Testing Tool**: Manual Visual Inspection.

- **User Story 2**: As a user, I want intuitive navigation and clear
  visual hierarchies.

  - **Description**: This involves optimizing layout, spacing, and
    visual cues to ensure that users can easily understand the structure
    of the application, locate information, and navigate between
    different features or panels.

  - **Actions to Undertake**:

    1.  **Layout Optimization**:

        - Review layouts of MainWindow, RegistrationWorkflowWidget
          (tabs/stacked widget usage), SidebarWidget, and all custom
          dialogs.

        - Ensure optimal use of QHBoxLayout, QVBoxLayout, QGridLayout,
          QFormLayout for logical grouping and efficient use of space.

        - Add appropriate QSpacerItems to ensure elements are not too
          cramped or too spread out.

    2.  **Consistent Spacing**:

        - Define a consistent spacing unit (e.g., multiples of 4px or
          8px) for margins, padding, and inter-widget spacing.

        - Apply these consistently across all UI elements (e.g.,
          setContentsMargins(), setSpacing()).

    3.  **Visual Hierarchy**:

        - Use QGroupBoxes, QFrames, and contrasting background colors
          (from UIThemeManager) to visually group related controls.

        - Ensure important information (e.g., RMS error, active mode) is
          prominent.

    4.  **Typography for Hierarchy**: Use different font sizes, weights,
        and colors (from UIThemeManager) to establish a clear
        typographic hierarchy (e.g., headings, subheadings, body text,
        labels).

    5.  **Responsive Layout (Desktop)**: Ensure main window and core
        widgets scale gracefully when the window is resized. Avoid fixed
        pixel dimensions where relative sizes (stretch,
        QSize::Preferred) are more appropriate.

  - **References between Files**:

    - All src/ui/ widget .h/.cpp files (layouts, spacing, group boxes).

    - UIThemeManager.h / .cpp: Provides standardized spacing values if
      defined there.

  - **Acceptance Criteria**:

    - All UI panels and dialogs have a clean, uncluttered layout with
      consistent spacing between elements.

    - Related controls are logically grouped using visual separators or
      containers.

    - Important information and controls are easily discoverable and
      visually prominent.

    - The application scales gracefully on different window sizes
      without clipping or overlapping elements.

  - **Testing Plan**:

    - **Test Case 1**: Layout Consistency and Spacing.

      - **Test Data**: Open all application windows, dialogs, and
        panels.

      - **Expected Result**: Consistent spacing (e.g., same padding
        around buttons, same margins for groups). Elements are
        well-aligned.

      - **Testing Tool**: Manual Visual Inspection.

    - **Test Case 2**: Visual Hierarchy and Prominence.

      - **Test Data**: Review key features (e.g.,
        AlignmentControlPanel).

      - **Expected Result**: RMS error, status messages are easy to read
        and stand out. Main action buttons are clearly visible.

      - **Testing Tool**: Manual Visual Inspection.

    - **Test Case 3**: Window Resizing.

      - **Test Data**: Resize the main application window and various
        dialogs.

      - **Expected Result**: UI elements resize and rearrange gracefully
        without clipping, overlapping, or excessive whitespace.

      - **Testing Tool**: Manual QA.

- **User Story 3**: As a user, I want clear and concise feedback
  messages for all operations.

  - **Description**: Effective feedback helps users understand what the
    application is doing, if an operation succeeded or failed, and what
    to do next. This involves standardizing messaging style and ensuring
    all important operations provide appropriate feedback.

  - **Actions to Undertake**:

    1.  **Standardize Message Style**: Define consistent phrasing, tone
        (e.g., informative, not overly verbose), and severity levels
        (info, warning, error, success).

    2.  **IMainView Message Methods**: Ensure IMainView.h has
        comprehensive methods:

        - void displayInfoMessage(const QString& title, const QString&
          message); (e.g., for successful export).

        - void displayWarningMessage(const QString& title, const
          QString& message); (e.g., for insufficient points).

        - void displayErrorMessage(const QString& title, const QString&
          message); (e.g., for file load failure).

        - void updateStatusBar(const QString& message, int timeout = 0);
          (for transient messages).

    3.  **Review All Feedback Points**: Go through MainPresenter and
        other presenters/controllers and ensure:

        - File import/export success/failure.

        - Project open/save success/failure.

        - Alignment computation results (success, insufficient, error,
          cancelled).

        - Target detection results (success, no targets found, error,
          cancelled).

        - Bundle Adjustment results.

        - Undo/Redo (e.g., \"Undo \'Apply Transformation\'\").

        - Progress updates (already covered in previous sprints, but
          review wording).

    4.  **Non-Blocking Feedback**: Prefer status bar messages or
        non-modal popups (QSystemTrayIcon::Message) for non-critical
        information to avoid interrupting workflow. Use modal dialogs
        (QMessageBox) for critical errors or confirmations.

  - **References between Files**:

    - IMainView.h / MainWindow.cpp: Provides concrete implementation of
      message display.

    - MainPresenter.h / MainPresenter.cpp: Calls IMainView methods for
      feedback.

    - AlignmentEngine.h / AlignmentEngine.cpp: Sets status messages for
      alignment states.

    - Other backend components: May pass error messages to presenters.

  - **Acceptance Criteria**:

    - All major application operations (file I/O, registration,
      detection, optimization) provide clear success, warning, or error
      feedback messages.

    - Feedback messages are concise, easy to understand, and consistent
      in style.

    - Non-critical information is displayed non-modally (e.g., status
      bar).

    - Critical errors or confirmations use modal dialogs.

  - **Testing Plan**:

    - **Test Case 1**: Consistent Message Style.

      - **Test Data**: Trigger various success, warning, error
        scenarios.

      - **Expected Result**: Messages appear with consistent titles,
        phrasing, and visual cues (e.g., error icon).

      - **Testing Tool**: Manual QA.

    - **Test Case 2**: Feedback for All Key Operations.

      - **Test Data**: Perform all major user workflows (create project,
        load scan, manual align, export, ICP, BA, etc.).

      - **Expected Result**: Appropriate feedback (success, error,
        progress) is provided for each step.

      - **Testing Tool**: Manual QA / Integration tests (verifying
        IMainView method calls).

## Actions to Undertake (Consolidated)

1.  **Frontend (UI Components)**:

    - **UIThemeManager (src/ui/include/ui/UIThemeManager.h and
      src/ui/src/UIThemeManager.cpp)**:

      - Refine color palette, font definitions, and basic QSS rules
        (e.g., for QPushButton, QLineEdit, QGroupBox, QFrame).

      - Ensure methods like generateAllComponentStyles() provide a
        comprehensive stylesheet.

      - Add constants for standard spacing units (e.g., int
        defaultMargin = 8;).

    - **MainWindow (src/app/src/mainwindow.cpp)**:

      - Apply global QSS at startup:
        QApplication::instance()-\>setStyleSheet(UIThemeManager::instance().generateAllComponentStyles());

      - Implement void displayInfoMessage(const QString& title, const
        QString& message);

      - Implement void displayWarningMessage(const QString& title, const
        QString& message);

      - Implement void displayErrorMessage(const QString& title, const
        QString& message);

      - Implement void updateStatusBar(const QString& message, int
        timeout = 0);

      - Implement void setActionsEnabled(QAction\* action, bool
        enabled); (from S8.1).

    - **Review All Custom Widgets (src/ui/\*.cpp files)**:

      - **Styling**: Remove hardcoded setStyleSheet() calls. Use
        UIThemeManager::instance().getColorHex() or QSS classes/IDs.

      - **Rounded Corners**: Add border-radius property via QSS to all
        QPushButton, QLineEdit, QGroupBox, QFrame, QTabWidget (tabs),
        QTableWidget, QTreeView, etc.

      - **Fonts**: Ensure font-family: \"Inter\"; is applied globally or
        locally where needed.

      - **Layouts**: Review all QHBoxLayout, QVBoxLayout, QGridLayout,
        QFormLayout usage. Ensure consistent setSpacing() and
        setContentsMargins(). Use addStretch() and addSpacerItem() where
        appropriate.

      - **Iconography**: Update QIcons to use consistent SVG or
        high-quality PNGs/XPMs (from Qt resources). Use
        QStyle::StandardPixmap for common actions if applicable.

      - **Message Display**: Ensure any direct QLabel message updates
        conform to a consistent style (e.g., using a specific color for
        errors).

2.  **Backend (Core Logic/Services)**:

    - **MainPresenter (src/app/src/MainPresenter.cpp)**:

      - Review all error/success/warning points and ensure
        m_view-\>display\*Message() methods are used consistently.

      - Ensure m_view-\>updateStatusBar() is used for transient
        messages.

    - **AlignmentEngine (src/registration/AlignmentEngine.cpp)**:

      - Ensure alignmentStateChanged(state, message) signal (from S2.3)
        provides clear, concise messages for Idle, Insufficient,
        Computing, Valid, Error states.

    - **Other Core Modules**: Ensure consistent error/success reporting
      patterns are followed (e.g., return status enums, emit signals, or
      pass messages up to MainPresenter).

## References between Files (Consolidated)

- UIThemeManager \<-\> All UI widgets and main.cpp: Core of styling.

- IMainView (MainWindow concrete implementation) \<-\> MainPresenter:
  Provides UI feedback methods.

- MainPresenter -\> Various core components: Triggers operations,
  receives status/results.

- Various core components -\> MainPresenter: Report back status/errors.

## List of Files being Created

- No new files are created for this sub-sprint. All changes are to
  existing files.

## Acceptance Criteria (Consolidated)

- The application\'s UI exhibits a consistent and modern visual theme,
  including a standardized color palette, typography (e.g., \"Inter\"
  font), and rounded corners on all relevant elements.

- All custom and standard Qt widgets are styled using UIThemeManager or
  global QSS, with no visible hardcoded styles.

- Layouts across all windows and dialogs are clean, well-spaced, and
  maintain visual hierarchy, without elements overlapping or clipping on
  resize.

- All icons are high-quality, consistent in style, and clearly represent
  their function.

- All major application operations (file I/O, registration, detection,
  optimization) provide clear, concise, and consistent feedback messages
  (success, warning, error) to the user.

- Non-critical messages appear non-modally (e.g., status bar), while
  critical errors use modal dialogs.

## Testing Plan (Consolidated)

- **Manual Visual Inspection & Usability Testing**: This is the primary
  testing method for UI/UX refinement.

  - **Test Case 1**: Global Theme Consistency.

    - **Test Data**: Launch application. Open all dialogs (ExportDialog,
      ICPParameterDialog, TargetDetectionDialog, ReportOptionsDialog),
      navigate all tabs, open context menus.

    - **Expected Result**: All UI elements (buttons, text fields,
      labels, group boxes, tabs, scrollbars) consistently adhere to the
      defined theme (colors, fonts, rounded corners).

  - **Test Case 2**: Layout and Spacing Review.

    - **Test Data**: Open all application panels and dialogs. Resize the
      main window.

    - **Expected Result**: No overlapping, clipping, or excessive
      whitespace. Logical grouping of controls.

  - **Test Case 3**: Icon Review.

    - **Test Data**: Review all icons in menus, toolbars, buttons.

    - **Expected Result**: Icons are clear, consistent, and
      recognizable.

  - **Test Case 4**: Feedback Message Consistency.

    - **Test Data**: Deliberately trigger various success, warning, and
      error states (e.g., successful load, invalid file load,
      insufficient points for alignment, cancelled operation).

    - **Expected Result**: All messages are clear, concise, and follow a
      consistent format (title, message content, use of status bar vs.
      dialogs).

- **Automated Visual Regression Tests (if framework available)**:

  - **Test Case 1**: Screenshot comparison of key UI states.

    - **Test Data**: Predefined application states (e.g., empty project,
      loaded scans, alignment in progress).

    - **Expected Result**: Screenshots match baseline, indicating no
      unintended visual changes.

    - **Testing Tool**: Automated screenshot comparison framework (e.g.,
      using Qt Test, ImageMagick, or specialized UI testing tools).

## Assumptions and Dependencies

- **Prior Sprints Completed**: All core functional features are
  implemented and stable.

- **UIThemeManager Foundation**: The basic UIThemeManager class and its
  ability to generate QSS are already in place.

- **Qt QSS Capabilities**: Qt\'s stylesheet engine is robust enough to
  handle the desired visual styling.

- **Icon Assets**: High-quality SVG or other vector/bitmap icon assets
  are available for use.

## Non-Functional Requirements

- **Usability**: The application is intuitive, easy to navigate, and
  pleasant to use for long periods.

- **Aesthetics**: The application presents a modern, professional, and
  visually appealing interface.

- **Consistency**: A consistent user experience is provided across all
  features and platforms.

- **Accessibility (Basic)**: Basic accessibility considerations are met
  (e.g., sufficient color contrast).

- **Performance**: UI rendering and animations (if any) are smooth and
  responsive.

## Conclusion

Sub-Sprint 8.2 is dedicated to refining the user experience,
transforming the application into a polished and professional product.
By focusing on consistent styling, intuitive layouts, and clear
feedback, it ensures the application is not just functional but also a
joy to use, ready for deployment.
