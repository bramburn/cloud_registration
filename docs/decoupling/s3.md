Project Backlog: Sprint 3 - Decoupling PointCloudViewerWidget
Introduction

This document provides the detailed backlog for Sprint 3 of the architectural refactoring initiative. Building on the successful decoupling of the core E57 parser and writer libraries in previous sprints, the focus now shifts to the user interface layer. This sprint will concentrate on decoupling the PointCloudViewerWidget, the primary component responsible for rendering 3D point cloud data. By abstracting the viewer's functionality, we will break the tight coupling between the application's presentation logic and its core data management and business logic, leading to a more flexible and maintainable UI architecture.
User Stories

    User Story 3: Decouple the 3D Viewer Component

        As a developer, I want to abstract the PointCloudViewerWidget behind an interface so that I can test the application's data visualization logic independently of the Qt-based widget implementation and enable easier integration of alternative rendering technologies in the future.

        Description: This story involves creating an IPointCloudViewer interface that defines a contract for all 3D rendering operations, such as loading point data, clearing the view, and manipulating the camera. The existing PointCloudViewerWidget will be refactored to implement this interface. Higher-level components, like MainWindow, which currently interact directly with the widget, will be updated to use the IPointCloudViewer abstraction. This will enforce a clean separation of concerns, where the main application logic is not directly tied to a specific UI widget implementation.

Actions to Undertake

To complete User Story 3, the following actions are required:

    Define IPointCloudViewer Interface:

        Review the public API of src/pointcloudviewerwidget.h to identify the essential methods required for controlling the viewer from other parts of the application.

        Create a new header file, src/IPointCloudViewer.h, to define the abstract interface.

        Declare pure virtual functions for key operations, including:

            void loadPointCloud(const std::vector<float>& points);

            void clearPointCloud();

            void setState(ViewerState state, const QString& message);

            void setLODEnabled(bool enabled);

            void setRenderWithColor(bool enabled);

            void setRenderWithIntensity(bool enabled);

        Ensure a virtual destructor is present in the interface.

    Refactor PointCloudViewerWidget:

        Modify the PointCloudViewerWidget class in src/pointcloudviewerwidget.h to publicly inherit from IPointCloudViewer.

        Add the override keyword to the implementations of the interface methods within src/pointcloudviewerwidget.cpp.

        Ensure the widget's existing rendering logic and OpenGL implementation remain encapsulated within the class, exposed only through the new interface.

    Update MainWindow to Use the Interface:

        Modify src/mainwindow.h to hold a pointer to IPointCloudViewer instead of PointCloudViewerWidget. The m_viewer member will be changed to IPointCloudViewer* m_viewer;.

        Since PointCloudViewerWidget is a QWidget, it cannot be fully decoupled through constructor injection in the same way as non-widget classes. The MainWindow will still be responsible for the widget's creation and layout management.

        The key change will be in how MainWindow interacts with the viewer. After creating the PointCloudViewerWidget instance, MainWindow will assign its pointer to the m_viewer member of type IPointCloudViewer*. All subsequent calls to the viewer's methods will be made through this interface pointer, not the concrete widget pointer.

        Remove any direct includes of pointcloudviewerwidget.h from mainwindow.h where possible, favoring forward declarations and including IPointCloudViewer.h.

References between Files

    src/IPointCloudViewer.h (New File):

        Will be included by src/pointcloudviewerwidget.h for implementation.

        Will be included by src/mainwindow.h to define the member pointer m_viewer.

        Will be referenced in tests that need to mock the viewer.

    src/pointcloudviewerwidget.h (Modified):

        Will #include "IPointCloudViewer.h".

        The class declaration will be updated to class PointCloudViewerWidget : public QOpenGLWidget, protected QOpenGLFunctions, public IPointCloudViewer.

    src/mainwindow.h and src/mainwindow.cpp (Modified):

        The m_viewer member variable will be changed from PointCloudViewerWidget* to IPointCloudViewer*.

        All method calls to the viewer will be done through the m_viewer interface pointer. The initial creation and layouting of the PointCloudViewerWidget will still occur within MainWindow, but the logical interaction will be through the abstraction.

List of Files being Created

    File 1: src/IPointCloudViewer.h

        Purpose: To provide an abstract contract for any 3D point cloud rendering component. This decouples the application's core logic from the specific Qt and OpenGL implementation details of the current viewer.

        Contents:

            An enum ViewerState to define the possible states of the viewer.

            The IPointCloudViewer abstract class.

            Pure virtual functions for viewer operations, such as:

                virtual void loadPointCloud(const std::vector<float>& points) = 0;

                virtual void clearPointCloud() = 0;

                virtual void setState(ViewerState state, const QString& message = "") = 0;

            A virtual destructor.

        Relationships: This interface will be implemented by PointCloudViewerWidget. It will be used by MainWindow to control the viewer.

Acceptance Criteria

    A new header file, src/IPointCloudViewer.h, is created and defines the abstract interface for the viewer.

    The PointCloudViewerWidget class successfully implements all methods from the IPointCloudViewer interface.

    The MainWindow class interacts with the viewer component exclusively through the IPointCloudViewer interface pointer for all logical operations (e.g., loading data, setting state).

    The application compiles and runs without any regressions in the 3D viewer's functionality, including data loading, rendering, and camera controls.

    A new test case demonstrates that the MainWindow's logic can be tested using a mock implementation of IPointCloudViewer.

Testing Plan

    Test Case 1: PointCloudViewerWidget Regression Test

        Description: Manually test all existing functionality of the PointCloudViewerWidget to ensure no behavior has changed after the refactoring.

        Test Data: Use existing sample E57 and LAS files.

        Expected Result: All viewer features, including point cloud loading, clearing, camera controls (orbit, pan, zoom), and state display (idle, loading, error) must work identically to the pre-refactoring version.

        Testing Tool: Manual execution and visual inspection.
    Test Case 2: MainWindow and Viewer Integration Test

        Description: Verify that the MainWindow correctly controls the PointCloudViewerWidget through the IPointCloudViewer interface.

        Test Data: Load a standard point cloud file through the MainWindow's "Open File" action.

        Expected Result: The MainWindow should successfully call the loadPointCloud method on its m_viewer interface pointer, and the PointCloudViewerWidget should render the data. The entire data loading and display workflow should be intact.

        Testing Tool: Manual execution and debugger-assisted verification of method calls.
    Test Case 3: Mock Viewer Test

        Description: Create a simple mock class that implements IPointCloudViewer and logs method calls (e.g., loadPointCloud was called with X points). Temporarily replace the real PointCloudViewerWidget with this mock in MainWindow's setup to test the interaction logic.

        Test Data: N/A. The test will be triggered by UI actions.

        Expected Result: When a file is loaded in the MainWindow, the mock viewer's loadPointCloud method should be invoked, and the log should confirm this. This test proves that MainWindow is no longer dependent on the concrete viewer implementation.

        Testing Tool: Manual test with a temporary mock class and debug output (qDebug).

Assumptions and Dependencies

    Assumptions:

        The public interface of PointCloudViewerWidget is well-defined and contains all the necessary methods for external control.

        The internal rendering logic of PointCloudViewerWidget is sound and will not require refactoring in this sprint.

    Dependencies:

        Sprints 1 & 2: This sprint relies on the decoupled parser and writer interfaces, as the data flow into the viewer originates from the parser.

        Qt Framework: The PointCloudViewerWidget is a QOpenGLWidget, and its lifecycle is managed by Qt's parent-child system. This dependency cannot be removed, but the logical coupling can be minimized.

        OpenGL: The viewer's rendering is dependent on the OpenGL API.

Non-Functional Requirements

    Performance: As with previous sprints, the introduction of a virtual interface is expected to have a negligible impact on rendering performance. Frame rates should remain consistent. FPS will be monitored before and after the change to ensure performance remains within a 5% margin.

    Code Clarity: The primary goal is to improve the clarity of the interaction between MainWindow and the viewer. The code in MainWindow should become simpler, as it will only be concerned with calling high-level interface methods rather than interacting with the widget's internal state.

Conclusion

Sprint 3 will extend the decoupling effort into the UI layer, a critical step for improving the application's overall architecture. By abstracting the PointCloudViewerWidget, we will create a more flexible and testable system where the main application logic is not tied to a specific rendering implementation. This will pave the way for easier future development, such as adding new visualization types or integrating different rendering engines.