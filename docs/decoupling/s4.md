Project Backlog: Sprint 4 - Decoupling MainWindow
Introduction

This document details the backlog for Sprint 4 of the E57 Point Cloud Processing application's architectural refactoring. With the core data handling libraries (e57parserlib and e57writer_lib) and the primary UI rendering component (PointCloudViewerWidget) now decoupled, this sprint targets the central orchestrator of the application: MainWindow. The goal is to refactor MainWindow by applying the Model-View-Presenter (MVP) pattern, separating its view responsibilities from the application and presentation logic. This will significantly reduce its complexity, improve its testability, and create a more maintainable and scalable UI architecture.
User Stories

    User Story 4: Decouple the MainWindow from Application Logic

        As a developer, I want to refactor the MainWindow to delegate its business and presentation logic to a new Presenter class so that the MainWindow becomes a pure View component, making the UI logic easier to test and maintain.

        Description: This user story involves introducing a MainPresenter class to mediate between the MainWindow (the View) and the application's backend services (the Model, represented by the parser, writer, etc.). An IMainView interface will be created and implemented by MainWindow, allowing the MainPresenter to communicate with the view without a direct dependency on its concrete implementation. All application logic, such as handling the "Open File" action, orchestrating the file parsing, and instructing the viewer to render data, will be moved from MainWindow to MainPresenter.

Actions to Undertake

To complete User Story 4, the following actions must be taken:

    Define IMainView Interface:

        Analyze the MainWindow class to identify all methods that update the UI in response to application events (e.g., displaying data, showing error messages, updating the status bar).

        Create a new header file, src/IMainView.h, to define the abstract interface for the main view.

        Declare pure virtual functions for all UI update operations, such as displayPointCloud(), showErrorMessage(), updateStatusMessage(), setViewerState(), and setProjectTitle().

    Create MainPresenter Class:

        Create a new class, MainPresenter, in src/MainPresenter.h and src/MainPresenter.cpp.

        The MainPresenter's constructor will accept pointers to the IMainView, IE57Parser, and IPointCloudViewer interfaces.

        Move all application logic from MainWindow.cpp into MainPresenter.cpp. This includes the logic within event handlers like onFileOpenClicked(). For example, the presenter will have a method like handleOpenFile(filePath) which will coordinate the parser and viewer.

    Refactor MainWindow to act as the View:

        Modify src/mainwindow.h to make MainWindow implement the IMainView interface.

        The MainWindow will create and own an instance of MainPresenter. In its constructor, it will pass this (as an IMainView*) and pointers to the services to the MainPresenter's constructor.

        All UI event handlers (e.g., onFileNewProject(), onImportScans()) will be simplified to delegate the call to the corresponding method in the MainPresenter.

        Remove all direct business logic and dependencies on services like the parser from MainWindow.

    Update Application Entry Point (main.cpp):

        Modify src/main.cpp to reflect the new architecture. It will still be responsible for creating the MainWindow, but the MainWindow itself will now manage the creation of the MainPresenter and the wiring of dependencies. This keeps the composition root clean and contained.

References between Files

    src/IMainView.h (New File):

        Will be included by src/mainwindow.h for implementation.

        Will be included by src/MainPresenter.h for dependency injection.

    src/MainPresenter.h and src/MainPresenter.cpp (New Files):

        Will include IMainView.h, IE57Parser.h, and IPointCloudViewer.h.

        Will be included by src/mainwindow.cpp so that MainWindow can instantiate it.

    src/mainwindow.h and src/mainwindow.cpp (Modified):

        Will include IMainView.h and MainPresenter.h.

        Will implement the IMainView interface.

        Will contain a std::unique_ptr<MainPresenter> member.

        Its methods will be refactored to be simple delegations to the presenter.

    tests/test_mainwindow.cpp (New or Modified):

        A new test file will be created (tests/test_mainpresenter.cpp) to unit test the presenter logic.

        Existing UI tests for MainWindow may need to be adapted.

List of Files being Created

    File 1: src/IMainView.h

        Purpose: To define an abstract contract for the main application window, allowing the presenter to update the UI without being coupled to QMainWindow or other Qt specifics.

        Contents:

            Declaration of the IMainView abstract class.

            Pure virtual functions for UI update operations, such as:

                virtual void displayErrorMessage(const QString& title, const QString& message) = 0;

                virtual void updateStatusBar(const QString& text) = 0;

                virtual void setWindowTitle(const QString& title) = 0;

                virtual IPointCloudViewer* getViewer() = 0;

        Relationships: Implemented by MainWindow, used by MainPresenter.
    File 2: src/MainPresenter.h

        Purpose: To contain the presentation and application logic, acting as the intermediary between the view (UI) and the model (services).

        Contents:

            The MainPresenter class declaration.

            Member variables for IMainView*, IE57Parser*, etc.

            Public methods to handle user actions, e.g., onOpenFileClicked(QString path).

        Relationships: Instantiated by MainWindow. Uses IMainView, IE57Parser, IE57Writer, and IPointCloudViewer interfaces.
    File 3: src/MainPresenter.cpp

        Purpose: To implement the logic of the MainPresenter class.

        Contents: The implementation of all methods declared in MainPresenter.h. This file will contain the core application workflow logic.

        Relationships: Implements the MainPresenter class.

Acceptance Criteria

    The MainWindow class has been significantly simplified, with its primary role being event handling and delegation to the MainPresenter.

    All business logic related to file operations and data processing has been successfully moved to the MainPresenter class.

    MainPresenter is completely decoupled from Qt UI libraries (QtWidgets, QtGui) and only interacts with the view through the IMainView interface.

    The application compiles and runs, and all user-facing functionality (opening files, importing scans, viewing point clouds) works exactly as it did before the refactoring.

    Unit tests for MainPresenter are created and pass, demonstrating that the application logic can be tested independently of the UI.

Testing Plan

    Test Case 1: MainPresenter Logic Unit Test

        Description: Create unit tests for the MainPresenter class. This will involve creating mock implementations of IMainView, IE57Parser, and IPointCloudViewer.

        Test Data: Use mock objects to simulate various scenarios, such as a successful file parse, a failed parse, and user cancellation.

        Expected Result: Verify that the presenter calls the correct methods on the view and service interfaces in response to simulated events. For instance, when handleOpenFile is called with a valid path, the presenter should call openFile on the parser, and then loadPointCloud on the view's viewer.

        Testing Tool: Google Test with Google Mock.
    Test Case 2: MainWindow (View) Interaction Test

        Description: Manually test the GUI to ensure all user actions are correctly wired to the MainPresenter.

        Test Data: Use sample E57 and LAS files.

        Expected Result: Clicking the "Open Project" or "Import Scans" buttons should trigger the corresponding logic in the MainPresenter, resulting in the file being loaded and displayed. The status bar and window title should update correctly.

        Testing Tool: Manual execution, visual inspection, and use of the debugger to trace call stacks from the view to the presenter.
    Test Case 3: Full Application Regression Test

        Description: Perform a complete, end-to-end test of the application's primary user workflows.

        Test Data: A curated set of valid, invalid, and edge-case point cloud files.

        Expected Result: The application must remain stable and functionally identical to the pre-refactoring version. All features, including project creation, scan import, point cloud viewing, and error handling, must perform correctly.

        Testing Tool: Manual testing.

Assumptions and Dependencies

    Assumptions:

        The MVP (Model-View-Presenter) pattern is a suitable choice for the application's architecture.

        The public APIs of the previously created interfaces (IE57Parser, IE57Writer, IPointCloudViewer) are stable and sufficient for the presenter's needs.

    Dependencies:

        Sprints 1, 2, 3: This sprint is highly dependent on the successful completion of the previous decoupling sprints, as the MainPresenter will rely on the IE57Parser, IE57Writer, and IPointCloudViewer interfaces.

        Qt Framework: MainWindow remains a QMainWindow and will continue to use Qt for its UI elements and event loop.

Non-Functional Requirements

    Responsiveness: The UI must remain responsive during file operations. The refactoring should not introduce any blocking calls on the main GUI thread. The delegation to the presenter and underlying services (which should be running asynchronously) will be key to this.

    Maintainability: The primary NFR is to drastically reduce the complexity of MainWindow, making it easier to modify UI elements in the future without affecting the core application logic. Code complexity metrics (e.g., cyclomatic complexity) for MainWindow should show a significant reduction.

Conclusion

Sprint 4 marks a major milestone in the decoupling effort by refactoring the application's central component, MainWindow. By applying the MVP pattern, we will achieve a clean separation between the user interface and the application's logic. This will result in a codebase that is not only easier to test and maintain but also more flexible and prepared for future feature development and architectural evolution.