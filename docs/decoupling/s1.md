Project Backlog: Sprint 1 - Decoupling e57parserlib
Introduction

This document outlines the detailed backlog for Sprint 1 of the component decoupling initiative, as defined in the project's Product Requirements Document (PRD). The primary objective of this sprint is to isolate the E57 file parsing logic by introducing an abstraction layer. This foundational step will break the direct, rigid connections between e57parserlib and other parts of the application, such as the MainWindow and testing modules. The successful completion of this sprint is critical for improving the system's modularity, testability, and overall maintainability.
User Stories

    User Story 1: Decouple the E57 Parser

        As a developer, I want to decouple the e57parserlib from the main application logic so that I can test the parsing functionality in isolation and easily substitute it with alternative implementations in the future.

        Description: This user story involves introducing an abstract interface for the E57 parser. The existing e57parserlib will be refactored to implement this interface. All other components that currently depend on the concrete e57parserlib class will be updated to depend on the new abstraction. This change is foundational for improving the system's modularity and testability. It will allow for the creation of mock parsers for unit testing UI components and will make the system more flexible to future changes in file parsing libraries.

Actions to Undertake

To complete User Story 1, the following actions must be taken:

    Define IE57Parser Interface:

        Analyze the existing src/e57parserlib.h to identify all public methods currently used by other parts of the application.

        Create a new header file, src/IE57Parser.h, to define the abstract base class (interface).

        Declare pure virtual functions in IE57Parser for all public functionalities. Key methods will include openFile, closeFile, isOpen, getGuid, getVersion, getScanCount, getPointCount, extractPointData, and getLastError.

        Ensure the interface includes a virtual destructor to allow for proper cleanup of derived classes through a base class pointer.

    Refactor e57parserlib:

        Modify the E57ParserLib class declaration in src/e57parserlib.h to inherit publicly from the new IE57Parser interface.

        Add the override specifier to the implementation of all the inherited virtual functions in src/e57parserlib.cpp to ensure correctness.

        Confirm that the existing method bodies correctly fulfill the contract defined by the interface.

    Update Consuming Components:

        Identify all classes that #include "e57parserlib.h" and create instances of E57ParserLib. This will primarily include src/mainwindow.cpp and tests/test_e57parserlib.cpp.

        Refactor these classes to hold a pointer or reference to IE57Parser (e.g., std::unique_ptr<IE57Parser> m_parser;).

        Implement a dependency injection mechanism. The main.cpp file will be modified to create a concrete E57ParserLib instance and pass it to the MainWindow's constructor.

        Replace all direct calls to E57ParserLib methods with calls to the corresponding methods on the IE57Parser interface.

References between Files

    src/IE57Parser.h (New File):

        Will be included by src/e57parserlib.h (for implementation).

        Will be included by src/mainwindow.h (for dependency injection).

        Will be included by tests/test_e57parserlib.cpp (for testing against the interface).

    src/e57parserlib.h (Modified):

        Will now #include "IE57Parser.h".

        The E57ParserLib class declaration will be changed to class E57ParserLib : public IE57Parser.

    src/mainwindow.h and src/mainwindow.cpp (Modified):

        Will no longer #include "e57parserlib.h".

        Will #include "IE57Parser.h" instead.

        The member variable for the parser will be changed to an IE57Parser*.

        The constructor will be updated to accept an IE57Parser*.

    src/main.cpp (Modified):

        Will #include "e57parserlib.h" and mainwindow.h.

        Will be responsible for creating the new E57ParserLib() instance and passing it to the MainWindow.

    tests/test_e57parserlib.cpp (Modified):

        Will #include "IE57Parser.h".

        Tests will be updated to use the IE57Parser interface where appropriate, in addition to testing the concrete class.

List of Files being Created

    File 1: src/IE57Parser.h

        Purpose: To define the abstract interface for all E57 parsers. This file will serve as the contract between the parsing logic and the rest of the application, enabling loose coupling.

        Contents:

            Declaration of the IE57Parser abstract class.

            Pure virtual functions for all public parsing operations, such as:

                virtual bool openFile(const std::string& path) = 0;

                virtual void closeFile() = 0;

                virtual bool isOpen() const = 0;

                virtual std::string getGuid() const = 0;

                virtual int getScanCount() const = 0;

                virtual std::vector<float> extractPointData(int scanIndex) = 0;

                virtual std::string getLastError() const = 0;

            A virtual destructor: virtual ~IE57Parser() {}.

        Relationships: This interface will be implemented by E57ParserLib and consumed by MainWindow and test classes.

Acceptance Criteria

    A new file, src/IE57Parser.h, exists and defines a pure abstract class for E57 parsing operations.

    The E57ParserLib class in src/e57parserlib.h publicly inherits from IE57Parser and correctly overrides all its virtual functions.

    The MainWindow class no longer includes or directly references E57ParserLib, depending only on the IE57Parser interface.

    The application compiles without errors and all existing functionality related to loading E57 files is preserved.

    The application entry point in src/main.cpp correctly instantiates E57ParserLib and injects it into the MainWindow.

    All existing unit tests in tests/test_e57parserlib.cpp continue to pass.

    A new test case is added to verify that E57ParserLib can be used polymorphically through an IE57Parser pointer.

Testing Plan

    Test Case 1: E57ParserLib Unit Test Regression

        Description: Verify that the refactored E57ParserLib class still functions correctly and passes all its existing unit tests.

        Test Data: All existing valid and invalid E57 files used in the current test suite.

        Expected Result: All tests in tests/test_e57parserlib.cpp should pass without modification to the test logic itself.

        Testing Tool: Google Test.
    Test Case 2: MainWindow Integration Test

        Description: Ensure that the MainWindow can still open and process E57 files correctly after being refactored to use the IE57Parser interface.

        Test Data: A sample E57 file (e.g., bunnyDouble.e57).

        Expected Result: The application loads the E57 file successfully upon user action, and the point cloud data is rendered correctly in the PointCloudViewerWidget.

        Testing Tool: Manual execution and visual verification.
    Test Case 3: Mock Parser Test for UI Validation

        Description: Create a simple mock implementation of the IE57Parser interface. This mock will return a predefined, hardcoded point cloud dataset. Inject this mock into MainWindow to verify that the UI components can be tested independently of the actual file parsing logic.

        Test Data: A hardcoded std::vector<float> representing a simple shape (e.g., a cube) within the mock parser class.

        Expected Result: MainWindow should launch and, upon a "file open" action, display the hardcoded data from the mock parser without any file I/O operations occurring.

        Testing Tool: Google Test with a manually created mock class.

Assumptions and Dependencies

    Assumptions:

        The public API of e57parserlib is stable and accurately reflects all necessary parsing functionalities required by the application.

        The existing logic within e57parserlib.cpp is functionally correct and will not require refactoring during this sprint.

    Dependencies:

        libE57Format: The third-party library for low-level E57 file handling.

        C++11: The project requires a C++11 (or newer) compliant compiler.

        Qt Framework: Used for the application's UI, signals/slots, and core utilities.

Non-Functional Requirements

    Performance: The introduction of the abstraction layer via virtual function calls is not expected to introduce any noticeable performance degradation. The overhead will be negligible compared to the file I/O and data processing times. Pre- and post-refactoring benchmarks will be executed on a sample file to confirm that loading times remain within a 5% tolerance.

    Maintainability: The primary NFR is to improve code maintainability. This will be qualitatively assessed through a peer code review, focusing on the clarity of the new interface, the reduced coupling in MainWindow, and the overall ease of understanding the system's data flow.

Conclusion

This sprint is a critical architectural improvement that lays the groundwork for a more robust and flexible application. By decoupling e57parserlib, we will not only improve the immediate testability and maintainability of the parsing logic but also establish a clear pattern for refactoring other key components in subsequent sprints. The expected outcome is a system where the core parsing functionality is completely isolated from the UI and other application logic, adhering to the Single Responsibility and Dependency Inversion principles.