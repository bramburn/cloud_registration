Project Backlog: Sprint 5 - Test Suite Decoupling and Validation
Introduction

This document outlines the detailed backlog for Sprint 5, the final phase of the component decoupling initiative as described in the project's Product Requirements Document (PRD). With the core application components now abstracted behind interfaces, this sprint focuses on refactoring the existing test suite. The primary objective is to leverage the new decoupled architecture to create more robust, isolated, and maintainable tests. This involves updating existing tests to use the new interfaces and introducing mock objects to test components in isolation, thereby validating the success of the entire refactoring effort and improving the overall quality of the codebase.
User Stories

    User Story 5: Refactor the Test Suite for Decoupled Components

        As a developer, I want to update the automated test suite to use the new abstract interfaces and mock objects so that I can write focused unit tests, improve test execution speed, and ensure the long-term maintainability of the testing framework.

        Description: This story involves a comprehensive overhaul of the existing test files. Tests that previously depended on concrete implementations (e.g., E57ParserLib, PointCloudViewerWidget) will be refactored to interact with these components through their new interfaces (IE57Parser, IPointCloudViewer). This sprint will also introduce mock implementations of these interfaces, enabling true unit testing of business logic classes (like the MainPresenter from Sprint 4) without dependencies on the UI or file system.

Actions to Undertake

To complete User Story 5, the following actions must be taken:

    Establish Mocking Framework:

        Integrate Google Test and Google Mock into the testing build process if not already present.

        Create a new directory, tests/mocks/, to house all mock object definitions.

    Create Mock Implementations:

        MockE57Parser: Create a mock class in tests/mocks/MockE57Parser.h that implements the IE57Parser interface. Use gmock's MOCK_METHOD to define mock implementations for all interface methods. This will allow tests to simulate file loading success, failure, and return predefined point cloud data.

        MockE57Writer: Create tests/mocks/MockE57Writer.h implementing the IE57Writer interface. This mock will verify that methods like createFile and writePoints are called with the correct parameters during export operations, without actually writing files to disk.

        MockPointCloudViewer: Create tests/mocks/MockPointCloudViewer.h implementing the IPointCloudViewer interface. This mock will allow tests to verify that the presenter correctly instructs the view to render data or change its state.

    Refactor Existing Tests:

        tests/test_e57parserlib.cpp: While continuing to test the concrete E57ParserLib class, add new tests that interact with it through the IE57Parser* interface to ensure the abstraction is complete.

        tests/test_e57writer_lib.cpp: Apply the same approach as the parser test, verifying functionality through the IE57Writer* interface.

    Create New Unit Tests for Logic Classes:

        tests/test_mainpresenter.cpp: Create a new test file dedicated to the MainPresenter. These tests will be pure unit tests, instantiating MainPresenter with the mock interfaces (MockE57Parser, MockPointCloudViewer, etc.).

        Write tests to cover all presenter logic. For example:

            Test that presenter->handleOpenFile() calls parser->openFile().

            Test that if parser->openFile() succeeds, viewer->loadPointCloud() is called with the correct data.

            Test that if parser->openFile() fails, view->showErrorMessage() is called.

References between Files

    tests/mocks/*.h (New Files): These mock headers will be included by the new unit test files (e.g., test_mainpresenter.cpp).

    tests/test_mainpresenter.cpp (New File): Will include MainPresenter.h and the new mock headers (MockE57Parser.h, MockPointCloudViewer.h, MockMainView.h).

    tests/test_e57writer_lib.cpp (Modified): Will be updated to #include "IE57Writer.h" and use the interface for some tests.

    tests/test_e5tparserlib.cpp (Modified): Will be updated to #include "IE57Parser.h".

List of Files being Created

    File 1: tests/mocks/MockE57Parser.h

        Purpose: To provide a mock implementation of the E57 parser for testing application logic without file dependencies.

        Contents: A C++ header file defining the MockE57Parser class, inheriting from IE57Parser and using Google Mock's MOCK_METHOD macro for each interface method.

        Relationships: Will be used by tests for MainPresenter and other components that rely on E57 parsing.
    File 2: tests/mocks/MockE57Writer.h

        Purpose: To provide a mock implementation of the E57 writer.

        Contents: A C++ header file defining the MockE57Writer class, inheriting from IE57Writer and using MOCK_METHOD.

        Relationships: Used in tests that verify file export and saving logic.
    File 3: tests/mocks/MockPointCloudViewer.h

        Purpose: To provide a mock implementation of the 3D viewer.

        Contents: A C++ header file defining the MockPointCloudViewer class, inheriting from IPointCloudViewer and using MOCK_METHOD.

        Relationships: Used by MainPresenter tests to verify that the view is updated correctly.
    File 4: tests/test_mainpresenter.cpp

        Purpose: To contain all unit tests for the MainPresenter class.

        Contents: A series of Google Test test cases that instantiate MainPresenter with mock dependencies and verify its behavior under various conditions.

        Relationships: This is the primary consumer of the new mock objects.

Acceptance Criteria

    All existing unit and integration tests pass successfully after the refactoring.

    New mock classes for IE57Parser, IE57Writer, and IPointCloudViewer are created and functional.

    A new test suite for MainPresenter exists and provides at least 80% code coverage for its logic.

    The MainPresenter tests run without requiring access to the file system or a live OpenGL context.

    The overall test suite execution time for unit tests is significantly faster than the full integration test suite.

Testing Plan

    Test Case 1: MainPresenter Logic Test with Mocks

        Description: Test the handleOpenFile logic in the MainPresenter.

        Test Data: Use MockE57Parser to simulate both a successful and a failed file opening. Use MockPointCloudViewer to verify interactions.

        Expected Result:

            On success, EXPECT_CALL should verify that viewer->loadPointCloud() is called.

            On failure, EXPECT_CALL should verify that view->showErrorMessage() is called.

        Testing Tool: Google Test / Google Mock.
    Test Case 2: Refactored E57WriterLib Test

        Description: Verify that the E57WriterLib can be successfully used through the IE57Writer interface.

        Test Data: A small, programmatically generated point cloud.

        Expected Result: Create a std::unique_ptr<IE57Writer> pointing to a new E57WriterLib(). Call its methods to create a valid E57 file. The resulting file should be correct and readable.

        Testing Tool: Google Test.
    Test Case 3: CI Pipeline Validation

        Description: Run the entire refactored test suite on a Continuous Integration server.

        Test Data: The full suite of test data files.

        Expected Result: All tests, including the new unit tests and the refactored integration tests, should pass in the CI environment.

        Testing Tool: Jenkins / GitHub Actions.

Assumptions and Dependencies

    Assumptions:

        The interfaces created in Sprints 1-4 (IE57Parser, IE57Writer, IPointCloudViewer, IMainView) are stable and complete.

        The development environment is configured with Google Test and Google Mock libraries.

    Dependencies:

        This sprint is critically dependent on the successful completion of Sprints 1, 2, 3, and 4. The abstract interfaces must be in place before the test suite can be refactored to use them.

Non-Functional Requirements

    Test Performance: The newly created unit tests for MainPresenter (using mocks) must execute quickly (target < 10ms per test case) to provide rapid feedback to developers.

    Test Readability: The refactored tests and new unit tests should be clear and self-documenting, following standard testing patterns like Arrange-Act-Assert.

    Maintainability: The test suite itself should be easy to maintain. Changes to one component's implementation should not require widespread changes to the tests of other components.

Conclusion

Sprint 5 concludes the decoupling refactoring project by aligning the test suite with the new, improved architecture. Upon completion, the project will have a multi-layered testing strategy, including fast unit tests for business logic and separate integration tests for verifying component interactions. This robust testing framework will increase developer confidence, reduce regression bugs, and serve as a solid foundation for future feature development.