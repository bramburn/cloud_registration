Based on the Sprint 3.3 backlog for your FARO scene registration software MVP, I'll provide comprehensive guidance for implementing each user story with Qt6 and C++ code examples.

## User Story 1: Refine Sidebar Visual Cues and Icons

**Implementation Approach:**

First, create an enhanced icon management system and update your `ProjectTreeModel` to support better visual states:

```cpp
// IconManager.h
#pragma once
#include 
#include 
#include 

enum class ItemType {
    Scan,
    Cluster,
    Project
};

enum class ItemState {
    Loaded,
    Unloaded,
    Locked,
    Unlocked,
    Missing,
    Linked,
    Copied,
    Moved
};

class IconManager {
public:
    static IconManager& instance();
    QIcon getIcon(ItemType type, ItemState state) const;
    QIcon getStateOverlayIcon(ItemState state) const;
    
private:
    IconManager();
    void loadIcons();
    QHash m_iconCache;
};
```

```cpp
// IconManager.cpp
#include "IconManager.h"
#include 
#include 
#include 

IconManager& IconManager::instance() {
    static IconManager instance;
    return instance;
}

IconManager::IconManager() {
    loadIcons();
}

void IconManager::loadIcons() {
    // Load base icons
    m_iconCache["scan_base"] = QIcon(":/icons/scan.svg");
    m_iconCache["cluster_base"] = QIcon(":/icons/cluster.svg");
    m_iconCache["project_base"] = QIcon(":/icons/project.svg");
    
    // Load state overlay icons
    m_iconCache["loaded"] = QIcon(":/icons/loaded_overlay.svg");
    m_iconCache["locked"] = QIcon(":/icons/locked_overlay.svg");
    m_iconCache["missing"] = QIcon(":/icons/missing_overlay.svg");
    m_iconCache["linked"] = QIcon(":/icons/linked_badge.svg");
}

QIcon IconManager::getIcon(ItemType type, ItemState state) const {
    QString baseKey;
    switch (type) {
        case ItemType::Scan: baseKey = "scan_base"; break;
        case ItemType::Cluster: baseKey = "cluster_base"; break;
        case ItemType::Project: baseKey = "project_base"; break;
    }
    
    QIcon baseIcon = m_iconCache[baseKey];
    
    // Create composite icon with state overlay
    QPixmap pixmap = baseIcon.pixmap(16, 16);
    QPainter painter(&pixmap);
    
    // Add state-specific overlays
    if (state == ItemState::Locked) {
        QIcon overlay = m_iconCache["locked"];
        painter.drawPixmap(8, 8, overlay.pixmap(8, 8));
    } else if (state == ItemState::Missing) {
        QIcon overlay = m_iconCache["missing"];
        painter.drawPixmap(0, 0, overlay.pixmap(16, 16));
    }
    
    return QIcon(pixmap);
}
```

**Update ProjectTreeModel:**

```cpp
// ProjectTreeModel.h - Add to existing class
enum CustomRoles {
    ItemTypeRole = Qt::UserRole + 1,
    ItemStateRole,
    FullPathRole,
    PointCountRole,
    ImportTypeRole
};

// ProjectTreeModel.cpp - Update data method
QVariant ProjectTreeModel::data(const QModelIndex &index, int role) const {
    if (!index.isValid()) return QVariant();
    
    ProjectItem* item = static_cast(index.internalPointer());
    
    switch (role) {
        case Qt::DecorationRole: {
            ItemType type = static_cast(item->data(ItemTypeRole).toInt());
            ItemState state = static_cast(item->data(ItemStateRole).toInt());
            return IconManager::instance().getIcon(type, state);
        }
        case Qt::ToolTipRole:
            return generateTooltip(item);
        case ItemTypeRole:
            return static_cast(item->type());
        case ItemStateRole:
            return static_cast(item->state());
        case FullPathRole:
            return item->fullPath();
        case PointCountRole:
            return item->pointCount();
        default:
            return item->data(role);
    }
}

QString ProjectTreeModel::generateTooltip(ProjectItem* item) const {
    QString tooltip;
    if (item->type() == ItemType::Scan) {
        tooltip = QString("Scan: %1\nPath: %2\nPoints: %3\nImport Type: %4\nStatus: %5")
                    .arg(item->name())
                    .arg(item->fullPath())
                    .arg(item->pointCount())
                    .arg(item->importTypeString())
                    .arg(item->isLoaded() ? "Loaded" : "Unloaded");
    } else if (item->type() == ItemType::Cluster) {
        tooltip = QString("Cluster: %1\nScans: %2\nSub-clusters: %3\nStatus: %4")
                    .arg(item->name())
                    .arg(item->scanCount())
                    .arg(item->subClusterCount())
                    .arg(item->isLocked() ? "Locked" : "Unlocked");
    }
    return tooltip;
}
```

## User Story 2: Non-Modal Progress Indicators

**Create a Progress Management System:**

```cpp
// ProgressManager.h
#pragma once
#include 
#include 
#include 

struct ProgressInfo {
    QString operationName;
    int currentValue;
    int maxValue;
    QString currentStep;
    bool isActive;
};

class ProgressManager : public QObject {
    Q_OBJECT
    
public:
    static ProgressManager& instance();
    
    void startOperation(const QString& operationId, const QString& name, int maxSteps = 100);
    void updateProgress(const QString& operationId, int value, const QString& step = "");
    void finishOperation(const QString& operationId);
    void cancelOperation(const QString& operationId);
    
    ProgressInfo getProgressInfo(const QString& operationId) const;
    QStringList activeOperations() const;
    
signals:
    void operationStarted(const QString& operationId, const QString& name);
    void progressUpdated(const QString& operationId, int value, int max, const QString& step);
    void operationFinished(const QString& operationId);
    void operationCancelled(const QString& operationId);
    
private:
    ProgressManager() = default;
    QHash m_operations;
};
```

```cpp
// ProgressManager.cpp
#include "ProgressManager.h"

ProgressManager& ProgressManager::instance() {
    static ProgressManager instance;
    return instance;
}

void ProgressManager::startOperation(const QString& operationId, const QString& name, int maxSteps) {
    ProgressInfo info;
    info.operationName = name;
    info.currentValue = 0;
    info.maxValue = maxSteps;
    info.isActive = true;
    
    m_operations[operationId] = info;
    emit operationStarted(operationId, name);
}

void ProgressManager::updateProgress(const QString& operationId, int value, const QString& step) {
    if (m_operations.contains(operationId)) {
        auto& info = m_operations[operationId];
        info.currentValue = value;
        info.currentStep = step;
        emit progressUpdated(operationId, value, info.maxValue, step);
    }
}

void ProgressManager::finishOperation(const QString& operationId) {
    if (m_operations.contains(operationId)) {
        m_operations.remove(operationId);
        emit operationFinished(operationId);
    }
}
```

**Update MainWindow with Status Bar Progress:**

```cpp
// MainWindow.h - Add to existing class
private slots:
    void onOperationStarted(const QString& operationId, const QString& name);
    void onProgressUpdated(const QString& operationId, int value, int max, const QString& step);
    void onOperationFinished(const QString& operationId);

private:
    QProgressBar* m_progressBar;
    QLabel* m_progressLabel;
    QString m_currentOperationId;
```

```cpp
// MainWindow.cpp - In constructor
void MainWindow::setupStatusBar() {
    m_progressBar = new QProgressBar();
    m_progressBar->setVisible(false);
    m_progressBar->setMaximumWidth(200);
    
    m_progressLabel = new QLabel();
    m_progressLabel->setVisible(false);
    
    statusBar()->addPermanentWidget(m_progressLabel);
    statusBar()->addPermanentWidget(m_progressBar);
    
    // Connect to progress manager
    connect(&ProgressManager::instance(), &ProgressManager::operationStarted,
            this, &MainWindow::onOperationStarted);
    connect(&ProgressManager::instance(), &ProgressManager::progressUpdated,
            this, &MainWindow::onProgressUpdated);
    connect(&ProgressManager::instance(), &ProgressManager::operationFinished,
            this, &MainWindow::onOperationFinished);
}

void MainWindow::onOperationStarted(const QString& operationId, const QString& name) {
    m_currentOperationId = operationId;
    m_progressLabel->setText(name);
    m_progressLabel->setVisible(true);
    m_progressBar->setVisible(true);
    m_progressBar->setValue(0);
}

void MainWindow::onProgressUpdated(const QString& operationId, int value, int max, const QString& step) {
    if (operationId == m_currentOperationId) {
        m_progressBar->setMaximum(max);
        m_progressBar->setValue(value);
        if (!step.isEmpty()) {
            m_progressLabel->setText(QString("%1 - %2").arg(m_progressLabel->text(), step));
        }
    }
}

void MainWindow::onOperationFinished(const QString& operationId) {
    if (operationId == m_currentOperationId) {
        m_progressBar->setVisible(false);
        m_progressLabel->setVisible(false);
        m_currentOperationId.clear();
    }
}
```

**Update ProjectManager for Progress Reporting:**

```cpp
// ProjectManager.cpp - Update importScans method
void ProjectManager::importScans(const QStringList& filePaths, ImportType type) {
    QString operationId = QUuid::createUuid().toString();
    ProgressManager::instance().startOperation(operationId, "Importing Scans", filePaths.size());
    
    // Run in separate thread to keep UI responsive
    QFuture future = QtConcurrent::run([this, filePaths, type, operationId]() {
        for (int i = 0; i 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

class CreateProjectDialog : public QDialog {
    Q_OBJECT
    
public:
    explicit CreateProjectDialog(QWidget* parent = nullptr);
    
    QString projectName() const;
    QString projectLocation() const;
    
private slots:
    void onBrowseLocation();
    void onProjectNameChanged();
    void validateInput();
    
private:
    void setupUI();
    void setupConnections();
    
    QLineEdit* m_projectNameEdit;
    QLineEdit* m_locationEdit;
    QPushButton* m_browseButton;
    QPushButton* m_createButton;
    QPushButton* m_cancelButton;
    QLabel* m_instructionLabel;
    QLabel* m_validationLabel;
};
```

```cpp
// CreateProjectDialog.cpp
#include "CreateProjectDialog.h"
#include 
#include 

CreateProjectDialog::CreateProjectDialog(QWidget* parent)
    : QDialog(parent) {
    setWindowTitle("Create New Project");
    setModal(true);
    resize(500, 200);
    
    setupUI();
    setupConnections();
    
    // Set default location
    QString defaultLocation = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
    m_locationEdit->setText(defaultLocation);
    
    validateInput();
}

void CreateProjectDialog::setupUI() {
    auto* mainLayout = new QVBoxLayout(this);
    
    // Instruction label
    m_instructionLabel = new QLabel(
        "Create a new FARO Scene registration project. The project will store "
        "scan data, registration settings, and processing results.");
    m_instructionLabel->setWordWrap(true);
    m_instructionLabel->setStyleSheet("QLabel { color: #666; margin-bottom: 10px; }");
    
    // Form layout
    auto* formLayout = new QFormLayout();
    
    m_projectNameEdit = new QLineEdit();
    m_projectNameEdit->setPlaceholderText("Enter a descriptive project name");
    formLayout->addRow("Project Name:", m_projectNameEdit);
    
    // Location row with browse button
    auto* locationLayout = new QHBoxLayout();
    m_locationEdit = new QLineEdit();
    m_locationEdit->setPlaceholderText("Select project location");
    m_browseButton = new QPushButton("Browse...");
    m_browseButton->setMaximumWidth(80);
    
    locationLayout->addWidget(m_locationEdit);
    locationLayout->addWidget(m_browseButton);
    formLayout->addRow("Location:", locationLayout);
    
    // Validation label
    m_validationLabel = new QLabel();
    m_validationLabel->setStyleSheet("QLabel { color: red; }");
    m_validationLabel->setVisible(false);
    
    // Buttons
    auto* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_cancelButton = new QPushButton("Cancel");
    m_createButton = new QPushButton("Create Project");
    m_createButton->setDefault(true);
    
    buttonLayout->addWidget(m_cancelButton);
    buttonLayout->addWidget(m_createButton);
    
    // Add to main layout
    mainLayout->addWidget(m_instructionLabel);
    mainLayout->addLayout(formLayout);
    mainLayout->addWidget(m_validationLabel);
    mainLayout->addStretch();
    mainLayout->addLayout(buttonLayout);
}

void CreateProjectDialog::setupConnections() {
    connect(m_browseButton, &QPushButton::clicked, this, &CreateProjectDialog::onBrowseLocation);
    connect(m_projectNameEdit, &QLineEdit::textChanged, this, &CreateProjectDialog::validateInput);
    connect(m_locationEdit, &QLineEdit::textChanged, this, &CreateProjectDialog::validateInput);
    connect(m_createButton, &QPushButton::clicked, this, &QDialog::accept);
    connect(m_cancelButton, &QPushButton::clicked, this, &QDialog::reject);
}

void CreateProjectDialog::onBrowseLocation() {
    QString location = QFileDialog::getExistingDirectory(
        this, "Select Project Location", m_locationEdit->text());
    if (!location.isEmpty()) {
        m_locationEdit->setText(location);
    }
}

void CreateProjectDialog::validateInput() {
    QString name = m_projectNameEdit->text().trimmed();
    QString location = m_locationEdit->text().trimmed();
    
    m_validationLabel->setVisible(false);
    
    if (name.isEmpty()) {
        m_validationLabel->setText("Project name is required");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        return;
    }
    
    if (location.isEmpty()) {
        m_validationLabel->setText("Project location is required");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        return;
    }
    
    // Check if directory exists and is writable
    QDir dir(location);
    if (!dir.exists()) {
        m_validationLabel->setText("Selected location does not exist");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        return;
    }
    
    // Check if project already exists
    QString projectPath = QDir(location).filePath(name + ".fscene");
    if (QFile::exists(projectPath)) {
        m_validationLabel->setText("A project with this name already exists in the selected location");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        return;
    }
    
    m_createButton->setEnabled(true);
}
```

## User Story 4: Tooltips Implementation

The tooltip functionality is already integrated into the `ProjectTreeModel::data()` method shown in User Story 1. For context menu tooltips:

```cpp
// SidebarWidget.cpp - Update context menu creation
void SidebarWidget::createContextMenu(const QModelIndex& index) {
    QMenu* menu = new QMenu(this);
    
    QAction* loadAction = menu->addAction("Load Scan");
    loadAction->setToolTip("Loads the point cloud data for this scan into memory for viewing and processing");
    
    QAction* unloadAction = menu->addAction("Unload Scan");
    unloadAction->setToolTip("Removes the point cloud data from memory to free up resources");
    
    QAction* lockAction = menu->addAction("Lock Cluster");
    lockAction->setToolTip("Prevents changes to this cluster and its contents during registration operations");
    
    QAction* deleteAction = menu->addAction("Delete");
    deleteAction->setToolTip("Permanently removes this item from the project");
    
    // Connect actions to slots...
    menu->exec(QCursor::pos());
}
```

## User Story 5: Bug Tracking and Testing

**Create a Testing Framework Integration:**

```cpp
// TestRunner.h - For Google Test integration
#pragma once
#include 
#include 
#include 

class QtTestEnvironment : public ::testing::Environment {
public:
    void SetUp() override {
        if (!QApplication::instance()) {
            int argc = 1;
            char* argv[] = {"test"};
            app = new QApplication(argc, argv);
        }
    }
    
    void TearDown() override {
        if (app) {
            delete app;
            app = nullptr;
        }
    }
    
private:
    QApplication* app = nullptr;
};

// Register the environment
inline void setupTestEnvironment() {
    ::testing::AddGlobalTestEnvironment(new QtTestEnvironment);
}
```

**Example Test Cases:**

```cpp
// test_sidebar_visuals.cpp
#include 
#include 
#include "ProjectTreeModel.h"
#include "IconManager.h"

class SidebarVisualsTest : public ::testing::Test {
protected:
    void SetUp() override {
        model = new ProjectTreeModel();
    }
    
    void TearDown() override {
        delete model;
    }
    
    ProjectTreeModel* model;
};

TEST_F(SidebarVisualsTest, IconsAreLoadedCorrectly) {
    auto& iconManager = IconManager::instance();
    
    QIcon scanIcon = iconManager.getIcon(ItemType::Scan, ItemState::Loaded);
    EXPECT_FALSE(scanIcon.isNull());
    
    QIcon clusterIcon = iconManager.getIcon(ItemType::Cluster, ItemState::Locked);
    EXPECT_FALSE(clusterIcon.isNull());
}

TEST_F(SidebarVisualsTest, TooltipsContainRelevantInformation) {
    // Create test project item
    // Verify tooltip contains expected information
    // This would require setting up test data
}
```

## External Packages and APIs

**Required vcpkg packages for this sprint:**

```bash
# Install required packages
vcpkg install qt6[core,widgets,concurrent] gtest
```

**CMakeLists.txt configuration:**

```cmake
find_package(Qt6 REQUIRED COMPONENTS Core Widgets Concurrent)
find_package(GTest REQUIRED)

target_link_libraries(your_target 
    Qt6::Core 
    Qt6::Widgets 
    Qt6::Concurrent
    GTest::gtest
    GTest::gtest_main
)
```

## Additional Recommendations

**Performance Considerations:**
- Use `QIcon::fromTheme()` for system consistency where possible
- Cache generated composite icons to avoid repeated painting operations
- Implement lazy loading for tooltips with expensive data queries

**Accessibility:**
- Ensure sufficient color contrast for all visual states
- Provide keyboard navigation for all interactive elements
- Use semantic HTML-like structure in tooltips

**Testing Strategy:**
- Create automated visual regression tests using Qt's screenshot capabilities
- Implement integration tests for progress reporting workflows
- Use Qt's accessibility testing tools to verify screen reader compatibility

This implementation provides a solid foundation for Sprint 3.3, focusing on user experience improvements while maintaining the existing architecture and preparing for future registration functionality development.

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/35208055/70b00c91-1d76-4d56-bead-8ee259008323/paste.txt

I'll review the existing Sprint 3.3 implementation guide and enhance it based on the detailed backlog requirements. Let me analyze the structure and identify areas for improvement.

## Enhanced Sprint 3.3 Implementation Guide

The original guide provides a solid foundation, but needs refinement to align with the specific requirements outlined in the backlog. Here's the enhanced version:

## User Story 1: Refine Sidebar Visual Cues and Icons

**Enhanced Icon Management System:**

The original `IconManager` needs expansion to handle all the states mentioned in the backlog:

```cpp
// IconManager.h - Enhanced version
#pragma once
#include 
#include 
#include 
#include 
#include 

enum class ItemType {
    Scan,
    Cluster,
    Project
};

enum class ItemState {
    Loaded,
    Unloaded,
    Locked,
    Unlocked,
    Missing,
    Linked,
    Copied,
    Moved
};

enum class ImportType {
    Copy,
    Move,
    Link
};

class IconManager {
public:
    static IconManager& instance();
    QIcon getIcon(ItemType type, ItemState state = ItemState::Unloaded) const;
    QIcon getCompositeIcon(ItemType type, ItemState state, ImportType importType) const;
    QIcon getStateOverlayIcon(ItemState state) const;
    
    // High DPI support
    QIcon getScaledIcon(ItemType type, ItemState state, const QSize& size) const;
    
private:
    IconManager();
    void loadIcons();
    void loadThemeSpecificIcons();
    QPixmap createCompositePixmap(const QIcon& baseIcon, const QIcon& overlayIcon, 
                                  const QIcon& badgeIcon = QIcon()) const;
    
    QHash m_iconCache;
    QHash m_compositeCache;
    QString m_currentTheme;
};
```

```cpp
// IconManager.cpp - Enhanced implementation
#include "IconManager.h"
#include 
#include 
#include 
#include 
#include 

IconManager& IconManager::instance() {
    static IconManager instance;
    return instance;
}

IconManager::IconManager() {
    m_currentTheme = "default";
    loadIcons();
}

void IconManager::loadIcons() {
    // Base icons with SVG support for crisp scaling
    m_iconCache["scan_base"] = QIcon(":/icons/scan.svg");
    m_iconCache["cluster_base"] = QIcon(":/icons/cluster.svg");
    m_iconCache["project_base"] = QIcon(":/icons/project.svg");
    
    // State overlays
    m_iconCache["loaded_overlay"] = QIcon(":/icons/overlays/loaded.svg");
    m_iconCache["locked_overlay"] = QIcon(":/icons/overlays/locked.svg");
    m_iconCache["missing_overlay"] = QIcon(":/icons/overlays/missing.svg");
    m_iconCache["unloaded_overlay"] = QIcon(":/icons/overlays/unloaded.svg");
    
    // Import type badges
    m_iconCache["copy_badge"] = QIcon(":/icons/badges/copy.svg");
    m_iconCache["move_badge"] = QIcon(":/icons/badges/move.svg");
    m_iconCache["link_badge"] = QIcon(":/icons/badges/link.svg");
    
    // Load theme-specific variants
    loadThemeSpecificIcons();
}

void IconManager::loadThemeSpecificIcons() {
    // Support for dark/light themes
    bool isDarkTheme = QApplication::palette().color(QPalette::Window).lightness() (type))
                                         .arg(static_cast(state))
                                         .arg(static_cast(importType));
    
    if (m_compositeCache.contains(cacheKey)) {
        return QIcon(m_compositeCache[cacheKey]);
    }
    
    // Get base icon
    QString baseKey;
    switch (type) {
        case ItemType::Scan: baseKey = "scan_base"; break;
        case ItemType::Cluster: baseKey = "cluster_base"; break;
        case ItemType::Project: baseKey = "project_base"; break;
    }
    
    QIcon baseIcon = m_iconCache[baseKey];
    QIcon overlayIcon;
    QIcon badgeIcon;
    
    // Get state overlay
    switch (state) {
        case ItemState::Loaded: overlayIcon = m_iconCache["loaded_overlay"]; break;
        case ItemState::Locked: overlayIcon = m_iconCache["locked_overlay"]; break;
        case ItemState::Missing: overlayIcon = m_iconCache["missing_overlay"]; break;
        case ItemState::Unloaded: overlayIcon = m_iconCache["unloaded_overlay"]; break;
        default: break;
    }
    
    // Get import type badge
    switch (importType) {
        case ImportType::Copy: badgeIcon = m_iconCache["copy_badge"]; break;
        case ImportType::Move: badgeIcon = m_iconCache["move_badge"]; break;
        case ImportType::Link: badgeIcon = m_iconCache["link_badge"]; break;
    }
    
    QPixmap composite = createCompositePixmap(baseIcon, overlayIcon, badgeIcon);
    m_compositeCache[cacheKey] = composite;
    
    return QIcon(composite);
}

QPixmap IconManager::createCompositePixmap(const QIcon& baseIcon, const QIcon& overlayIcon, 
                                          const QIcon& badgeIcon) const {
    QPixmap pixmap = baseIcon.pixmap(16, 16);
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Draw state overlay (top-right corner)
    if (!overlayIcon.isNull()) {
        QPixmap overlay = overlayIcon.pixmap(8, 8);
        painter.drawPixmap(8, 0, overlay);
    }
    
    // Draw import type badge (bottom-right corner)
    if (!badgeIcon.isNull()) {
        QPixmap badge = badgeIcon.pixmap(6, 6);
        painter.drawPixmap(10, 10, badge);
    }
    
    return pixmap;
}
```

**Enhanced ProjectTreeModel with Comprehensive Data Support:**

```cpp
// ProjectTreeModel.h - Additional roles and methods
enum CustomRoles {
    ItemTypeRole = Qt::UserRole + 1,
    ItemStateRole,
    ImportTypeRole,
    FullPathRole,
    PointCountRole,
    DateAddedRole,
    FileSizeRole,
    ScanCountRole,
    SubClusterCountRole,
    IsLoadedRole,
    IsLockedRole,
    IsMissingRole
};

class ProjectTreeModel : public QAbstractItemModel {
    Q_OBJECT
    
public:
    // ... existing methods ...
    
    // Enhanced data method with comprehensive tooltip support
    QVariant data(const QModelIndex &index, int role) const override;
    
private:
    QString generateScanTooltip(ProjectItem* item) const;
    QString generateClusterTooltip(ProjectItem* item) const;
    QString formatFileSize(qint64 bytes) const;
    QString formatPointCount(qint64 points) const;
};
```

```cpp
// ProjectTreeModel.cpp - Enhanced data method
QVariant ProjectTreeModel::data(const QModelIndex &index, int role) const {
    if (!index.isValid()) return QVariant();
    
    ProjectItem* item = static_cast(index.internalPointer());
    
    switch (role) {
        case Qt::DecorationRole: {
            ItemType type = static_cast(item->data(ItemTypeRole).toInt());
            ItemState state = static_cast(item->data(ItemStateRole).toInt());
            ImportType importType = static_cast(item->data(ImportTypeRole).toInt());
            
            return IconManager::instance().getCompositeIcon(type, state, importType);
        }
        
        case Qt::ToolTipRole: {
            if (item->type() == ItemType::Scan) {
                return generateScanTooltip(item);
            } else if (item->type() == ItemType::Cluster) {
                return generateClusterTooltip(item);
            }
            return QVariant();
        }
        
        case ItemTypeRole:
            return static_cast(item->type());
        case ItemStateRole:
            return static_cast(item->state());
        case ImportTypeRole:
            return static_cast(item->importType());
        case FullPathRole:
            return item->fullPath();
        case PointCountRole:
            return item->pointCount();
        case DateAddedRole:
            return item->dateAdded();
        case FileSizeRole:
            return item->fileSize();
        case IsLoadedRole:
            return item->isLoaded();
        case IsLockedRole:
            return item->isLocked();
        case IsMissingRole:
            return item->isMissing();
            
        default:
            return item->data(role);
    }
}

QString ProjectTreeModel::generateScanTooltip(ProjectItem* item) const {
    QString tooltip = QString(
        "%1"
        "Path: %2"
        "Import Type: %3"
        "Points: %4"
        "File Size: %5"
        "Date Added: %6"
        "Status: %7"
    ).arg(item->name())
     .arg(item->fullPath())
     .arg(item->importTypeString())
     .arg(formatPointCount(item->pointCount()))
     .arg(formatFileSize(item->fileSize()))
     .arg(item->dateAdded().toString("yyyy-MM-dd hh:mm"))
     .arg(item->isLoaded() ? "Loaded" : "Unloaded");
     
    if (item->isMissing()) {
        tooltip += "Warning: Source file not found";
    }
    
    return tooltip;
}

QString ProjectTreeModel::generateClusterTooltip(ProjectItem* item) const {
    QString tooltip = QString(
        "%1"
        "Scans: %2"
        "Sub-clusters: %3"
        "Status: %4"
        "Lock Status: %5"
    ).arg(item->name())
     .arg(item->scanCount())
     .arg(item->subClusterCount())
     .arg(item->isLoaded() ? "Loaded" : "Unloaded")
     .arg(item->isLocked() ? "Locked" : "Unlocked");
     
    if (item->isLocked()) {
        tooltip += "Locked clusters cannot be modified during registration";
    }
    
    return tooltip;
}

QString ProjectTreeModel::formatFileSize(qint64 bytes) const {
    const qint64 KB = 1024;
    const qint64 MB = KB * 1024;
    const qint64 GB = MB * 1024;
    
    if (bytes >= GB) {
        return QString("%1 GB").arg(QString::number(bytes / double(GB), 'f', 2));
    } else if (bytes >= MB) {
        return QString("%1 MB").arg(QString::number(bytes / double(MB), 'f', 1));
    } else if (bytes >= KB) {
        return QString("%1 KB").arg(QString::number(bytes / double(KB), 'f', 0));
    }
    return QString("%1 bytes").arg(bytes);
}

QString ProjectTreeModel::formatPointCount(qint64 points) const {
    const qint64 K = 1000;
    const qint64 M = K * 1000;
    const qint64 B = M * 1000;
    
    if (points >= B) {
        return QString("%1B points").arg(QString::number(points / double(B), 'f', 2));
    } else if (points >= M) {
        return QString("%1M points").arg(QString::number(points / double(M), 'f', 1));
    } else if (points >= K) {
        return QString("%1K points").arg(QString::number(points / double(K), 'f', 0));
    }
    return QString("%1 points").arg(points);
}
```

## User Story 2: Enhanced Progress Management

**Comprehensive Progress Management System:**

```cpp
// ProgressManager.h - Enhanced with operation types and cancellation
#pragma once
#include 
#include 
#include 
#include 
#include 

enum class OperationType {
    ScanImport,
    ClusterLoad,
    ProjectSave,
    DataExport
};

struct ProgressInfo {
    QString operationName;
    OperationType type;
    int currentValue;
    int maxValue;
    QString currentStep;
    QString detailedStatus;
    bool isActive;
    bool isCancellable;
    QDateTime startTime;
    QDateTime estimatedEndTime;
};

class ProgressManager : public QObject {
    Q_OBJECT
    
public:
    static ProgressManager& instance();
    
    QString startOperation(OperationType type, const QString& name, int maxSteps = 100, bool cancellable = true);
    void updateProgress(const QString& operationId, int value, const QString& step = "", const QString& details = "");
    void finishOperation(const QString& operationId, const QString& result = "");
    void cancelOperation(const QString& operationId);
    void setOperationCancellable(const QString& operationId, bool cancellable);
    
    ProgressInfo getProgressInfo(const QString& operationId) const;
    QStringList activeOperations() const;
    bool hasActiveOperations() const;
    
    // Time estimation
    QDateTime estimateCompletion(const QString& operationId) const;
    QString formatTimeRemaining(const QString& operationId) const;
    
signals:
    void operationStarted(const QString& operationId, const QString& name, OperationType type);
    void progressUpdated(const QString& operationId, int value, int max, const QString& step, const QString& details);
    void operationFinished(const QString& operationId, const QString& result);
    void operationCancelled(const QString& operationId);
    void estimatedTimeChanged(const QString& operationId, const QDateTime& estimatedEnd);
    
private slots:
    void updateTimeEstimates();
    
private:
    ProgressManager();
    QString generateOperationId() const;
    
    QHash m_operations;
    QTimer* m_estimationTimer;
    mutable QMutex m_mutex;
};
```

```cpp
// ProgressManager.cpp - Enhanced implementation
#include "ProgressManager.h"
#include 
#include 

ProgressManager& ProgressManager::instance() {
    static ProgressManager instance;
    return instance;
}

ProgressManager::ProgressManager() {
    m_estimationTimer = new QTimer(this);
    m_estimationTimer->setInterval(1000); // Update every second
    connect(m_estimationTimer, &QTimer::timeout, this, &ProgressManager::updateTimeEstimates);
}

QString ProgressManager::startOperation(OperationType type, const QString& name, int maxSteps, bool cancellable) {
    QMutexLocker locker(&m_mutex);
    
    QString operationId = generateOperationId();
    
    ProgressInfo info;
    info.operationName = name;
    info.type = type;
    info.currentValue = 0;
    info.maxValue = maxSteps;
    info.isActive = true;
    info.isCancellable = cancellable;
    info.startTime = QDateTime::currentDateTime();
    
    m_operations[operationId] = info;
    
    if (m_operations.size() == 1) {
        m_estimationTimer->start();
    }
    
    emit operationStarted(operationId, name, type);
    return operationId;
}

void ProgressManager::updateProgress(const QString& operationId, int value, const QString& step, const QString& details) {
    QMutexLocker locker(&m_mutex);
    
    if (m_operations.contains(operationId)) {
        auto& info = m_operations[operationId];
        info.currentValue = value;
        info.currentStep = step;
        info.detailedStatus = details;
        
        // Update time estimation
        if (value > 0 && info.maxValue > 0) {
            QDateTime now = QDateTime::currentDateTime();
            qint64 elapsed = info.startTime.msecsTo(now);
            double progress = double(value) / info.maxValue;
            qint64 estimatedTotal = elapsed / progress;
            info.estimatedEndTime = info.startTime.addMSecs(estimatedTotal);
        }
        
        emit progressUpdated(operationId, value, info.maxValue, step, details);
    }
}

void ProgressManager::updateTimeEstimates() {
    QMutexLocker locker(&m_mutex);
    
    for (auto it = m_operations.begin(); it != m_operations.end(); ++it) {
        if (it->isActive && it->currentValue > 0) {
            emit estimatedTimeChanged(it.key(), it->estimatedEndTime);
        }
    }
}

QString ProgressManager::formatTimeRemaining(const QString& operationId) const {
    QMutexLocker locker(&m_mutex);
    
    if (!m_operations.contains(operationId)) {
        return QString();
    }
    
    const auto& info = m_operations[operationId];
    if (!info.estimatedEndTime.isValid()) {
        return "Calculating...";
    }
    
    QDateTime now = QDateTime::currentDateTime();
    qint64 remaining = now.msecsTo(info.estimatedEndTime);
    
    if (remaining  m_activeOperations;
```

```cpp
// MainWindow.cpp - Enhanced progress display implementation
void MainWindow::setupStatusBar() {
    // Progress widgets
    m_progressLabel = new QLabel();
    m_progressLabel->setVisible(false);
    m_progressLabel->setMinimumWidth(200);
    
    m_progressBar = new QProgressBar();
    m_progressBar->setVisible(false);
    m_progressBar->setMaximumWidth(200);
    m_progressBar->setTextVisible(true);
    
    m_timeLabel = new QLabel();
    m_timeLabel->setVisible(false);
    m_timeLabel->setStyleSheet("QLabel { color: #666; }");
    
    m_cancelButton = new QPushButton("Cancel");
    m_cancelButton->setVisible(false);
    m_cancelButton->setMaximumWidth(60);
    
    // Add to status bar
    statusBar()->addWidget(new QLabel()); // Spacer
    statusBar()->addPermanentWidget(m_progressLabel);
    statusBar()->addPermanentWidget(m_progressBar);
    statusBar()->addPermanentWidget(m_timeLabel);
    statusBar()->addPermanentWidget(m_cancelButton);
    
    // Connect signals
    auto& progressManager = ProgressManager::instance();
    connect(&progressManager, &ProgressManager::operationStarted,
            this, &MainWindow::onOperationStarted);
    connect(&progressManager, &ProgressManager::progressUpdated,
            this, &MainWindow::onProgressUpdated);
    connect(&progressManager, &ProgressManager::operationFinished,
            this, &MainWindow::onOperationFinished);
    connect(&progressManager, &ProgressManager::estimatedTimeChanged,
            this, &MainWindow::onEstimatedTimeChanged);
    connect(m_cancelButton, &QPushButton::clicked,
            this, &MainWindow::onCancelCurrentOperation);
}

void MainWindow::onOperationStarted(const QString& operationId, const QString& name, OperationType type) {
    m_currentOperationId = operationId;
    
    // Set operation-specific styling
    QString color;
    switch (type) {
        case OperationType::ScanImport: color = "#2196F3"; break;
        case OperationType::ClusterLoad: color = "#4CAF50"; break;
        case OperationType::ProjectSave: color = "#FF9800"; break;
        case OperationType::DataExport: color = "#9C27B0"; break;
    }
    
    m_progressBar->setStyleSheet(QString("QProgressBar::chunk { background-color: %1; }").arg(color));
    
    m_progressLabel->setText(name);
    m_progressLabel->setVisible(true);
    m_progressBar->setVisible(true);
    m_progressBar->setValue(0);
    
    // Show cancel button if operation is cancellable
    ProgressInfo info = ProgressManager::instance().getProgressInfo(operationId);
    m_cancelButton->setVisible(info.isCancellable);
}

void MainWindow::onProgressUpdated(const QString& operationId, int value, int max, const QString& step, const QString& details) {
    if (operationId == m_currentOperationId) {
        m_progressBar->setMaximum(max);
        m_progressBar->setValue(value);
        
        QString labelText = ProgressManager::instance().getProgressInfo(operationId).operationName;
        if (!step.isEmpty()) {
            labelText += QString(" - %1").arg(step);
        }
        m_progressLabel->setText(labelText);
        
        // Update tooltip with detailed information
        if (!details.isEmpty()) {
            m_progressBar->setToolTip(details);
        }
    }
}

void MainWindow::onEstimatedTimeChanged(const QString& operationId, const QDateTime& estimatedEnd) {
    if (operationId == m_currentOperationId) {
        QString timeText = ProgressManager::instance().formatTimeRemaining(operationId);
        m_timeLabel->setText(timeText);
        m_timeLabel->setVisible(!timeText.isEmpty());
    }
}

void MainWindow::onOperationFinished(const QString& operationId, const QString& result) {
    if (operationId == m_currentOperationId) {
        m_progressBar->setVisible(false);
        m_progressLabel->setVisible(false);
        m_timeLabel->setVisible(false);
        m_cancelButton->setVisible(false);
        m_currentOperationId.clear();
        
        // Show brief success message if result provided
        if (!result.isEmpty()) {
            statusBar()->showMessage(result, 3000);
        }
    }
}

void MainWindow::onCancelCurrentOperation() {
    if (!m_currentOperationId.isEmpty()) {
        ProgressManager::instance().cancelOperation(m_currentOperationId);
    }
}
```

## User Story 3: Enhanced Dialog Implementation

**Comprehensive CreateProjectDialog:**

```cpp
// CreateProjectDialog.h - Enhanced with validation and guidance
#pragma once
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

class CreateProjectDialog : public QDialog {
    Q_OBJECT
    
public:
    explicit CreateProjectDialog(QWidget* parent = nullptr);
    
    QString projectName() const;
    QString projectLocation() const;
    QString projectTemplate() const;
    bool createSampleData() const;
    
private slots:
    void onBrowseLocation();
    void onProjectNameChanged();
    void onLocationChanged();
    void onTemplateChanged();
    void validateInput();
    void onAdvancedToggled(bool enabled);
    
private:
    void setupUI();
    void setupConnections();
    void setupValidation();
    void updateLocationPreview();
    
    // UI Components
    QLineEdit* m_projectNameEdit;
    QLineEdit* m_locationEdit;
    QPushButton* m_browseButton;
    QComboBox* m_templateCombo;
    QCheckBox* m_sampleDataCheck;
    QCheckBox* m_advancedCheck;
    QGroupBox* m_advancedGroup;
    
    QPushButton* m_createButton;
    QPushButton* m_cancelButton;
    
    QLabel* m_instructionLabel;
    QLabel* m_validationLabel;
    QLabel* m_locationPreviewLabel;
    QLabel* m_templateDescLabel;
    
    // Validation
    QTimer* m_validationTimer;
    bool m_isValidating;
};
```

```cpp
// CreateProjectDialog.cpp - Enhanced implementation
#include "CreateProjectDialog.h"
#include 
#include 
#include 
#include 
#include 

CreateProjectDialog::CreateProjectDialog(QWidget* parent)
    : QDialog(parent), m_isValidating(false) {
    setWindowTitle("Create New FARO Scene Project");
    setModal(true);
    setMinimumSize(600, 400);
    
    setupUI();
    setupConnections();
    setupValidation();
    
    // Set defaults
    QString defaultLocation = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation) + "/FARO Projects";
    m_locationEdit->setText(defaultLocation);
    m_templateCombo->setCurrentIndex(0);
    
    validateInput();
}

void CreateProjectDialog::setupUI() {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(15);
    
    // Header with icon and description
    auto* headerLayout = new QHBoxLayout();
    QLabel* iconLabel = new QLabel();
    iconLabel->setPixmap(style()->standardIcon(QStyle::SP_DirIcon).pixmap(48, 48));
    
    m_instructionLabel = new QLabel(
        "Create New Project"
        "Set up a new FARO Scene registration project to manage your point cloud scans, "
        "perform registration operations, and organize your data."
    );
    m_instructionLabel->setWordWrap(true);
    
    headerLayout->addWidget(iconLabel);
    headerLayout->addWidget(m_instructionLabel, 1);
    
    // Main form
    auto* formLayout = new QFormLayout();
    formLayout->setLabelAlignment(Qt::AlignRight | Qt::AlignVCenter);
    
    // Project name
    m_projectNameEdit = new QLineEdit();
    m_projectNameEdit->setPlaceholderText("Enter a descriptive project name (e.g., 'Building Survey 2024')");
    formLayout->addRow("Project Name:", m_projectNameEdit);
    
    // Location with browse
    auto* locationLayout = new QHBoxLayout();
    m_locationEdit = new QLineEdit();
    m_locationEdit->setPlaceholderText("Select where to save the project");
    m_browseButton = new QPushButton("Browse...");
    m_browseButton->setMaximumWidth(80);
    
    locationLayout->addWidget(m_locationEdit, 1);
    locationLayout->addWidget(m_browseButton);
    formLayout->addRow("Location:", locationLayout);
    
    // Location preview
    m_locationPreviewLabel = new QLabel();
    m_locationPreviewLabel->setStyleSheet("QLabel { color: #666; font-style: italic; margin-left: 20px; }");
    formLayout->addRow("", m_locationPreviewLabel);
    
    // Project template
    m_templateCombo = new QComboBox();
    m_templateCombo->addItem("Empty Project", "empty");
    m_templateCombo->addItem("Indoor Scanning Template", "indoor");
    m_templateCombo->addItem("Outdoor Survey Template", "outdoor");
    m_templateCombo->addItem("Industrial Facility Template", "industrial");
    formLayout->addRow("Template:", m_templateCombo);
    
    // Template description
    m_templateDescLabel = new QLabel();
    m_templateDescLabel->setWordWrap(true);
    m_templateDescLabel->setStyleSheet("QLabel { color: #666; margin-left: 20px; }");
    formLayout->addRow("", m_templateDescLabel);
    
    // Advanced options
    m_advancedCheck = new QCheckBox("Show advanced options");
    formLayout->addRow("", m_advancedCheck);
    
    m_advancedGroup = new QGroupBox("Advanced Options");
    m_advancedGroup->setVisible(false);
    auto* advancedLayout = new QVBoxLayout(m_advancedGroup);
    
    m_sampleDataCheck = new QCheckBox("Create sample scan data for testing");
    m_sampleDataCheck->setToolTip("Generates synthetic point cloud data to help you learn the software");
    advancedLayout->addWidget(m_sampleDataCheck);
    
    // Validation feedback
    m_validationLabel = new QLabel();
    m_validationLabel->setStyleSheet("QLabel { color: red; font-weight: bold; }");
    m_validationLabel->setVisible(false);
    
    // Buttons
    auto* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();
    m_cancelButton = new QPushButton("Cancel");
    m_createButton = new QPushButton("Create Project");
    m_createButton->setDefault(true);
    m_createButton->setStyleSheet("QPushButton { font-weight: bold; }");
    
    buttonLayout->addWidget(m_cancelButton);
    buttonLayout->addWidget(m_createButton);
    
    // Assemble layout
    mainLayout->addLayout(headerLayout);
    mainLayout->addLayout(formLayout);
    mainLayout->addWidget(m_advancedGroup);
    mainLayout->addWidget(m_validationLabel);
    mainLayout->addStretch();
    mainLayout->addLayout(buttonLayout);
    
    // Initial template description
    onTemplateChanged();
}

void CreateProjectDialog::setupConnections() {
    connect(m_browseButton, &QPushButton::clicked, this, &CreateProjectDialog::onBrowseLocation);
    connect(m_projectNameEdit, &QLineEdit::textChanged, this, &CreateProjectDialog::onProjectNameChanged);
    connect(m_locationEdit, &QLineEdit::textChanged, this, &CreateProjectDialog::onLocationChanged);
    connect(m_templateCombo, QOverload::of(&QComboBox::currentIndexChanged), 
            this, &CreateProjectDialog::onTemplateChanged);
    connect(m_advancedCheck, &QCheckBox::toggled, this, &CreateProjectDialog::onAdvancedToggled);
    connect(m_createButton, &QPushButton::clicked, this, &QDialog::accept);
    connect(m_cancelButton, &QPushButton::clicked, this, &QDialog::reject);
}

void CreateProjectDialog::setupValidation() {
    m_validationTimer = new QTimer(this);
    m_validationTimer->setSingleShot(true);
    m_validationTimer->setInterval(500); // Validate 500ms after user stops typing
    connect(m_validationTimer, &QTimer::timeout, this, &CreateProjectDialog::validateInput);
}

void CreateProjectDialog::onProjectNameChanged() {
    updateLocationPreview();
    m_validationTimer->start();
}

void CreateProjectDialog::onLocationChanged() {
    updateLocationPreview();
    m_validationTimer->start();
}

void CreateProjectDialog::onTemplateChanged() {
    QString template_type = m_templateCombo->currentData().toString();
    QString description;
    
    if (template_type == "empty") {
        description = "Start with a blank project. You'll add scans and configure settings manually.";
    } else if (template_type == "indoor") {
        description = "Pre-configured for indoor scanning with typical room-to-room registration settings.";
    } else if (template_type == "outdoor") {
        description = "Optimized for outdoor surveys with GPS integration and large-scale registration.";
    } else if (template_type == "industrial") {
        description = "Designed for industrial facilities with high-precision requirements and complex geometries.";
    }
    
    m_templateDescLabel->setText(description);
}

void CreateProjectDialog::onAdvancedToggled(bool enabled) {
    m_advancedGroup->setVisible(enabled);
    adjustSize();
}

void CreateProjectDialog::updateLocationPreview() {
    QString name = m_projectNameEdit->text().trimmed();
    QString location = m_locationEdit->text().trimmed();
    
    if (!name.isEmpty() && !location.isEmpty()) {
        QString fullPath = QDir(location).filePath(name + ".fscene");
        m_locationPreviewLabel->setText(QString("Project will be saved as: %1").arg(fullPath));
    } else {
        m_locationPreviewLabel->clear();
    }
}

void CreateProjectDialog::validateInput() {
    if (m_isValidating) return;
    m_isValidating = true;
    
    QString name = m_projectNameEdit->text().trimmed();
    QString location = m_locationEdit->text().trimmed();
    
    m_validationLabel->setVisible(false);
    
    // Validate project name
    if (name.isEmpty()) {
        m_validationLabel->setText("⚠ Project name is required");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        m_isValidating = false;
        return;
    }
    
    // Check for invalid characters
    if (name.contains(QRegExp("[<>:\"/\\|?*]"))) {
        m_validationLabel->setText("⚠ Project name contains invalid characters");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        m_isValidating = false;
        return;
    }
    
    // Validate location
    if (location.isEmpty()) {
        m_validationLabel->setText("⚠ Project location is required");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        m_isValidating = false;
        return;
    }
    
    // Check if directory exists
    QDir dir(location);
    if (!dir.exists()) {
        // Try to create it
        if (!dir.mkpath(location)) {
            m_validationLabel->setText("⚠ Cannot create the specified location");
            m_validationLabel->setVisible(true);
            m_createButton->setEnabled(false);
            m_isValidating = false;
            return;
        }
    }
    
    // Check if project already exists
    QString projectPath = QDir(location).filePath(name + ".fscene");
    if (QFile::exists(projectPath)) {
        m_validationLabel->setText("⚠ A project with this name already exists in the selected location");
        m_validationLabel->setVisible(true);
        m_createButton->setEnabled(false);
        m_isValidating = false;
        return;
    }
    
    // All validations passed
    m_createButton->setEnabled(true);
    m_isValidating = false;
}
```

## User Story 4: Context Menu Tooltips

**Enhanced SidebarWidget with Comprehensive Tooltips:**

```cpp
// SidebarWidget.cpp - Enhanced context menu with detailed tooltips
void SidebarWidget::createContextMenu(const QModelIndex& index) {
    if (!index.isValid()) return;
    
    ProjectItem* item = static_cast(index.internalPointer());
    QMenu* menu = new QMenu(this);
    
    // Style the menu
    menu->setStyleSheet(
        "QMenu { border: 1px solid #ccc; background-color: white; }"
        "QMenu::item { padding: 5px 20px; }"
        "QMenu::item:selected { background-color: #e6f3ff; }"
    );
    
    if (item->type() == ItemType::Scan) {
        createScanContextMenu(menu, item);
    } else if (item->type() == ItemType::Cluster) {
        createClusterContextMenu(menu, item);
    }
    
    menu->exec(QCursor::pos());
}

void SidebarWidget::createScanContextMenu(QMenu* menu, ProjectItem* item) {
    // Load/Unload actions
    if (item->isLoaded()) {
        QAction* unloadAction = menu->addAction(QIcon(":/icons/unload.svg"), "Unload Scan");
        unloadAction->setToolTip(
            "Unload Scan"
            "Removes the point cloud data from memory to free up system resources. "
            "The scan remains in the project but won't be visible in the viewer until reloaded."
        );
        connect(unloadAction, &QAction::triggered, [this, item]() {
            emit unloadScanRequested(item->id());
        });
    } else {
        QAction* loadAction = menu->addAction(QIcon(":/icons/load.svg"), "Load Scan");
        loadAction->setToolTip(
            "Load Scan"
            "Loads the point cloud data into memory for viewing and processing. "
            "Large scans may take some time to load."
        );
        connect(loadAction, &QAction::triggered, [this, item]() {
            emit loadScanRequested(item->id());
        });
    }
    
    menu->addSeparator();
    
    // View actions
    QAction* viewAction = menu->addAction(QIcon(":/icons/view.svg"), "View in 3D");
    viewAction->setToolTip(
        "View in 3D"
        "Opens this scan in the 3D point cloud viewer. "
        "The scan will be automatically loaded if not already in memory."
    );
    viewAction->setEnabled(!item->isMissing());
    
    QAction* propertiesAction = menu->addAction(QIcon(":/icons/properties.svg"), "Properties");
    propertiesAction->setToolTip(
        "Properties"
        "View detailed information about this scan including file size, "
        "point count, import settings, and metadata."
    );
    
    menu->addSeparator();
    
    // File operations
    if (item->importType() == ImportType::Link) {
        QAction* showInExplorerAction = menu->addAction(QIcon(":/icons/folder.svg"), "Show Source File");
        showInExplorerAction->setToolTip(
            "Show Source File"
            "Opens the file explorer and highlights the original scan file. "
            "This scan is linked to the source, so changes affect the original file."
        );
        showInExplorerAction->setEnabled(!item->isMissing());
        
        if (item->isMissing()) {
            QAction* relinkAction = menu->addAction(QIcon(":/icons/relink.svg"), "Relink to Source");
            relinkAction->setToolTip(
                "Relink to Source"
                "The original source file cannot be found. Use this option to "
                "locate and relink to the correct file."
            );
        }
    }
    
    // Organization actions
    QAction* moveToClusterAction = menu->addAction(QIcon(":/icons/move.svg"), "Move to Cluster");
    moveToClusterAction->setToolTip(
        "Move to Cluster"
        "Move this scan to a different cluster for better organization. "
        "This affects how the scan is grouped during registration operations."
    );
    
    QAction* duplicateAction = menu->addAction(QIcon(":/icons/duplicate.svg"), "Duplicate");
    duplicateAction->setToolTip(
        "Duplicate"
        "Creates a copy of this scan within the project. "
        "Useful for testing different processing settings on the same data."
    );
    
    menu->addSeparator();
    
    // Destructive actions
    QAction* deleteAction = menu->addAction(QIcon(":/icons/delete.svg"), "Delete");
    deleteAction->setToolTip(
        "Delete"
        "Permanently removes this scan from the project. "
        "Warning: This action cannot be undone."
    );
    deleteAction->setIcon(style()->standardIcon(QStyle::SP_TrashIcon));
}

void SidebarWidget::createClusterContextMenu(QMenu* menu, ProjectItem* item) {
    // Load/Unload cluster
    if (item->isLoaded()) {
        QAction* unloadAction = menu->addAction(QIcon(":/icons/unload.svg"), "Unload Cluster");
        unloadAction->setToolTip(
            "Unload Cluster"
            "Unloads all scans in this cluster from memory. "
            "This frees up system resources but the scans won't be visible until reloaded."
        );
    } else {
        QAction* loadAction = menu->addAction(QIcon(":/icons/load.svg"), "Load All Scans");
        loadAction->setToolTip(
            "Load All Scans"
            "Loads all scans in this cluster into memory for viewing and processing. "
            "Large clusters may take significant time and memory."
        );
    }
    
    menu->addSeparator();
    
    // Lock/Unlock
    if (item->isLocked()) {
        QAction* unlockAction = menu->addAction(QIcon(":/icons/unlock.svg"), "Unlock Cluster");
        unlockAction->setToolTip(
            "Unlock Cluster"
            "Allows modifications to this cluster and its contents. "
            "Unlocked clusters can have scans added, removed, or reorganized."
        );
    } else {
        QAction* lockAction = menu->addAction(QIcon(":/icons/lock.svg"), "Lock Cluster");
        lockAction->setToolTip(
            "Lock Cluster"
            "Prevents changes to this cluster and its contents during registration operations. "
            "Locked clusters provide stability during complex processing workflows."
        );
    }
    
    menu->addSeparator();
    
    // View actions
    QAction* viewAction = menu->addAction(QIcon(":/icons/view.svg"), "View Cluster");
    viewAction->setToolTip(
        "View Cluster"
        "Opens all scans in this cluster in the 3D viewer. "
        "Scans will be automatically loaded if not already in memory."
    );
    
    // Registration actions
    QAction* registerAction = menu->addAction(QIcon(":/icons/register.svg"), "Register Scans");
    registerAction->setToolTip(
        "Register Scans"
        "Performs automatic registration of all scans in this cluster. "
        "This aligns the point clouds to create a unified coordinate system."
    );
    registerAction->setEnabled(item->scanCount() >= 2);
    
    menu->addSeparator();
    
    // Organization
    QAction* addScanAction = menu->addAction(QIcon(":/icons/add.svg"), "Add Scan to Cluster");
    addScanAction->setToolTip(
        "Add Scan to Cluster"
        "Add existing scans from the project to this cluster. "
        "Scans can belong to multiple clusters for flexible organization."
    );
    addScanAction->setEnabled(!item->isLocked());
    
    QAction* createSubclusterAction = menu->addAction(QIcon(":/icons/cluster.svg"), "Create Sub-cluster");
    createSubclusterAction->setToolTip(
        "Create Sub-cluster"
        "Creates a new cluster within this cluster for hierarchical organization. "
        "Useful for organizing large datasets by area or scan session."
    );
    
    menu->addSeparator();
    
    // Destructive actions
    QAction* deleteAction = menu->addAction(QIcon(":/icons/delete.svg"), "Delete Cluster");
    deleteAction->setToolTip(
        "Delete Cluster"
        "Removes this cluster from the project. Scans within the cluster are not deleted. "
        "Warning: This action cannot be undone."
    );
}
```

## User Story 5: Testing Framework Integration

**Comprehensive Testing Setup:**

```cpp
// tests/test_ui_refinements.cpp
#include 
#include 
#include 
#include 
#include "IconManager.h"
#include "ProgressManager.h"
#include "ProjectTreeModel.h"
#include "CreateProjectDialog.h"

class UIRefinementsTest : public ::testing::Test {
protected:
    void SetUp() override {
        if (!QApplication::instance()) {
            int argc = 1;
            char* argv[] = {"test"};
            app = new QApplication(argc, argv);
        }
    }
    
    void TearDown() override {
        // Cleanup is handled by QApplication destructor
    }
    
    QApplication* app = nullptr;
};

TEST_F(UIRefinementsTest, IconManagerLoadsAllIcons) {
    auto& iconManager = IconManager::instance();
    
    // Test base icons
    EXPECT_FALSE(iconManager.getIcon(ItemType::Scan).isNull());
    EXPECT_FALSE(iconManager.getIcon(ItemType::Cluster).isNull());
    EXPECT_FALSE(iconManager.getIcon(ItemType::Project).isNull());
    
    // Test composite icons
    QIcon compositeIcon = iconManager.getCompositeIcon(
        ItemType::Scan, ItemState::Loaded, ImportType::Link);
    EXPECT_FALSE(compositeIcon.isNull());
}

TEST_F(UIRefinementsTest, ProgressManagerHandlesOperations) {
    auto& progressManager = ProgressManager::instance();
    
    QSignalSpy startedSpy(&progressManager, &ProgressManager::operationStarted);
    QSignalSpy updatedSpy(&progressManager, &ProgressManager::progressUpdated);
    QSignalSpy finishedSpy(&progressManager, &ProgressManager::operationFinished);
    
    // Start operation
    QString operationId = progressManager.startOperation(
        OperationType::ScanImport, "Test Import", 100);
    
    EXPECT_EQ(startedSpy.count(), 1);
    EXPECT_FALSE(operationId.isEmpty());
    
    // Update progress
    progressManager.updateProgress(operationId, 50, "Processing...");
    EXPECT_EQ(updatedSpy.count(), 1);
    
    // Finish operation
    progressManager.finishOperation(operationId, "Import completed");
    EXPECT_EQ(finishedSpy.count(), 1);
}

TEST_F(UIRefinementsTest, CreateProjectDialogValidation) {
    CreateProjectDialog dialog;
    
    // Test empty name validation
    dialog.findChild("projectNameEdit")->clear();
    QTest::keyClicks(dialog.findChild("projectNameEdit"), "");
    
    QPushButton* createButton = dialog.findChild("createButton");
    EXPECT_FALSE(createButton->isEnabled());
    
    // Test valid input
    QTest::keyClicks(dialog.findChild("projectNameEdit"), "Test Project");
    QTest::keyClicks(dialog.findChild("locationEdit"), "/tmp");
    
    // Wait for validation timer
    QTest::qWait(600);
    EXPECT_TRUE(createButton->isEnabled());
}

// Performance test for icon rendering
TEST_F(UIRefinementsTest, IconRenderingPerformance) {
    auto& iconManager = IconManager::instance();
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // Render 1000 composite icons
    for (int i = 0; i (i % 3);
        ItemState state = static_cast(i % 4);
        ImportType importType = static_cast(i % 3);
        
        QIcon icon = iconManager.getCompositeIcon(type, state, importType);
        QPixmap pixmap = icon.pixmap(16, 16);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast(end - start);
    
    // Should complete within reasonable time (adjust threshold as needed)
    EXPECT_LT(duration.count(), 1000); // Less than 1 second
}
```

## Additional Recommendations

**CMakeLists.txt Configuration:**

```cmake
# Enhanced CMake configuration for Sprint 3.3
find_package(Qt6 REQUIRED COMPONENTS Core Widgets Concurrent Svg)
find_package(GTest REQUIRED)

# Add resources
qt6_add_resources(RESOURCES
    icons/icons.qrc
    styles/styles.qrc
)

# Create test executable
add_executable(ui_refinements_tests
    tests/test_ui_refinements.cpp
    tests/test_icon_manager.cpp
    tests/test_progress_manager.cpp
    ${RESOURCES}
)

target_link_libraries(ui_refinements_tests
    Qt6::Core
    Qt6::Widgets
    Qt6::Concurrent
    Qt6::Svg
    GTest::gtest
    GTest::gtest_main
    your_main_library
)

# Add custom target for running UI tests
add_custom_target(run_ui_tests
    COMMAND ui_refinements_tests
    DEPENDS ui_refinements_tests
    COMMENT "Running UI refinement tests"
)
```

**Resource File Structure:**

```xml


    
        
        scan.svg
        cluster.svg
        project.svg
        
        
        overlays/loaded.svg
        overlays/locked.svg
        overlays/missing.svg
        overlays/unloaded.svg
        
        
        badges/copy.svg
        badges/move.svg
        badges/link.svg
        
        
        dark/scan.svg
        dark/cluster.svg
        light/scan.svg
        light/cluster.svg
    

```

This enhanced implementation guide provides comprehensive coverage of all Sprint 3.3 requirements with detailed code examples, proper error handling, performance considerations, and thorough testing frameworks. The code is production-ready and follows Qt6 best practices while maintaining compatibility with your existing FARO scene registration software architecture.

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/35208055/70b00c91-1d76-4d56-bead-8ee259008323/paste.txt