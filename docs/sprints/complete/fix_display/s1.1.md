Sprint 1.1 Backlog: E57 Core Structure & Uncompressed Data

Sprint Goal: To enable the application to correctly parse the header and XML structure of simple E57 files, locate uncompressed point data, extract XYZ coordinates, and display them, while removing the erroneous fallback to mock data.
1. Introduction

This document details the backlog items for Sprint 1.1 of the "Robust Point Cloud Loading (.e57 & .las)" project. The focus of this sprint is to lay the foundational improvements for the E57Parser to correctly interpret E57 file structures and extract basic, uncompressed point cloud data. This sprint directly addresses requirements FR1, FR2, FR3, and FR5 from the main PRD.
2. User Stories
User Story 1: E57 Header and XML Parsing for Data Location

    As a developer,

    I want to refactor the E57Parser to accurately read an E57 file's header and parse its XML section,

    So that I can correctly identify the structure, metadata, and precise location (offset, count) of uncompressed point data within the binary sections of the file.

        Description: Currently, the E57Parser has a very simplistic understanding of the E57 format and relies on hardcoded assumptions or falls back to mock data. This user story focuses on implementing the logic to read the E57 header according to the ASTM E57 standard and then parse the XML section (typically using QDomDocument as per existing code) to find crucial elements like data3D, points, prototype, and codecs. This information is vital for locating where the actual point data resides and how it's structured.

        Actions to Undertake:

            Task 1.1.1: Enhance E57Parser::parseHeader to robustly read all standard E57 header fields (file signature, version, file length, XML offset, XML length, page size). Store xmlOffset and xmlLength accurately.

            Task 1.1.2: Refactor E57Parser::parseXmlSection to:

                Correctly load the XML content from the file using the xmlOffset and xmlLength obtained from the header.

                Use QDomDocument to parse the XML string.

                Navigate the DOM to find the /e57Root/data3D/0/points element (assuming the first point cloud for now).

                Extract attributes from the points element, such as fileOffset (if present and uncompressed) and recordCount.

                Parse the prototype element within points to confirm the presence of cartesianX, cartesianY, cartesianZ and their data types (assume Float precision="single" for this sprint).

                Parse the codecs section to identify if the data is uncompressed. For this sprint, we assume it will indicate uncompressed or a structure that directly leads to uncompressed data.

            Task 1.1.3: Store the extracted metadata (e.g., binary data offset for points, number of points, point field types) in E57Parser member variables for later use by the data extraction logic.

            Task 1.1.4: Implement error handling for scenarios like missing XML section, malformed XML, or missing critical E57 elements/attributes. Errors should be logged and propagated.

        References between Files:

            src/e57parser.h: Declaration of E57Parser class, member variables for storing parsed metadata.

            src/e57parser.cpp: Implementation of parseHeader, parseXmlSection, and helper XML parsing logic.

            test_e57_parsing.cpp / tests/test_e57parser.cpp: Will need to be updated or new tests created to verify correct XML interpretation using a known simple E57 file.

        Acceptance Criteria:

            Given a valid simple E57 file (e.g., similar to test_real.e57 generated by test_e57_parsing.cpp but processed with new logic):

                The E57Parser correctly reads and validates the E57 header.

                The E57Parser successfully parses the XML section.

                The parser correctly identifies the file offset and record count for the point data from the XML.

                The parser identifies that the point data prototype contains single-precision float cartesianX, cartesianY, cartesianZ.

                Errors during header or XML parsing are logged and result in a parsing failure (no fallback to mock data).

        Testing Plan:

            Unit Tests:

                Test Case 1.1.1: Parse a valid E57 header.

                    Test Data: Byte array representing a valid E57 header.

                    Expected Result: Header fields (XML offset, XML length, etc.) are correctly extracted.

                    Testing Tool: Google Test framework (gtest).

                Test Case 1.1.2: Parse a valid E57 XML section (uncompressed points).

                    Test Data: A minimal valid E57 XML string defining one uncompressed point cloud with XYZ float fields.

                    Expected Result: fileOffset, recordCount, and point field types are correctly extracted.

                    Testing Tool: gtest.

                Test Case 1.1.3: Attempt to parse an E57 file with malformed XML.

                    Test Data: E57 file with an invalid XML structure.

                    Expected Result: Parser reports an XML parsing error and parse() returns failure.

                    Testing Tool: gtest.

                Test Case 1.1.4: Attempt to parse an E57 file missing the /e57Root/data3D/points element.

                    Test Data: E57 file with valid XML but no point data definition.

                    Expected Result: Parser reports a "point data definition missing" error and parse() returns failure.

                    Testing Tool: gtest.

            Integration Test:

                Test Case 1.1.5: Load a complete minimal E57 file (header + XML + dummy binary section).

                    Test Data: A file like test_real.e57 (created by test_e57_parsing.cpp).

                    Expected Result: The parser successfully completes header and XML parsing, and the internal state correctly reflects the binary data offset and point count. No data extraction is tested here, just metadata retrieval.

                    Testing Tool: Manual execution or gtest with file I/O.

User Story 2: Extract Uncompressed XYZ Data from E57

    As a developer,

    I want to implement logic in E57Parser to read uncompressed XYZ floating-point data from the binary section of an E57 file, using the metadata obtained from the XML,

    So that the application can load the actual geometric data for visualization.

        Description: Once the XML parsing (User Story 1) provides the location (fileOffset) and structure (recordCount, field types) of the point data, this story focuses on modifying E57Parser::extractPointsFromBinarySection to read this data. For this sprint, the assumption is that the data is stored as contiguous single-precision floats (X, Y, Z).

        Actions to Undertake:

            Task 1.2.1: Modify the signature and implementation of E57Parser::extractPointsFromBinarySection to accept parameters derived from XML parsing (e.g., fileOffset, recordCount, information about point structure/stride if needed).

            Task 1.2.2: Inside extractPointsFromBinarySection, use the fileOffset to seek to the correct position in the E57 file.

            Task 1.2.3: Read recordCount number of points. For each point, read three single-precision float values for X, Y, and Z.

            Task 1.2.4: Populate the std::vector<float> with the extracted XYZ coordinates.

            Task 1.2.5: Implement robust I/O error handling during binary data reading (e.g., unexpected end-of-file, read errors).

            Task 1.2.6: Ensure E57Parser::parse() calls this updated extractPointsFromBinarySection with the correct parameters after successful XML parsing.

        References between Files:

            src/e57parser.h: Declaration of E57Parser and extractPointsFromBinarySection.

            src/e57parser.cpp: Implementation of extractPointsFromBinarySection and its invocation within parse.

            src/mainwindow.cpp: The onParsingFinished slot will receive the points vector.

            src/pointcloudviewerwidget.cpp: The loadPointCloud method will visualize the points.

            test_e57_parsing.cpp / tests/test_e57parser.cpp: Tests to verify correct data extraction.

        Acceptance Criteria:

            Given a simple E57 file with uncompressed XYZ float data (e.g., test_real.e57):

                The E57Parser correctly extracts all XYZ coordinates from the binary section.

                The returned std::vector<float> contains the correct number of floats (3 * recordCount).

                The coordinate values in the vector match the values in the E57 file.

                The application successfully displays these points in the PointCloudViewerWidget.

                If an I/O error occurs during binary reading, it's reported, and parsing fails.

        Testing Plan:

            Unit Tests:

                Test Case 1.2.1: Extract points from a mock binary stream.

                    Test Data: A QByteArray or QDataStream containing a few known XYZ float triplets. Known fileOffset (0 for this stream) and recordCount.

                    Expected Result: extractPointsFromBinarySection returns a vector with the correct XYZ values.

                    Testing Tool: gtest.

                Test Case 1.2.2: Attempt to extract points with recordCount exceeding available data.

                    Test Data: A binary stream shorter than recordCount * 3 * sizeof(float).

                    Expected Result: The method handles the short read gracefully (e.g., returns fewer points or reports an error, TBD by error handling strategy). Parsing should ultimately fail or report partial success.

                    Testing Tool: gtest.

            Integration Test:

                Test Case 1.2.3: Load the test_real.e57 file (generated by test_e57_parsing.cpp, which writes 3 specific points).

                    Test Data: test_real.e57.

                    Expected Result: The application loads and displays the 3 points: (1.0, 2.0, 3.0), (4.0, 5.0, 6.0), (7.0, 8.0, 9.0).

                    Testing Tool: Manual execution of the application, visual verification in PointCloudViewerWidget, and debug log checks for coordinate values.

User Story 3: Remove Erroneous Mock Data Fallback for E57

    As a user,

    I want the application to attempt to load my E57 file and show me the actual data or a clear error message if it fails,

    So that I am not confused by mock data appearing when I expect my own data.

        Description: The current E57Parser::parse method has a tendency to fall back to generateMockPointCloud() if any step of the parsing fails. This is misleading for the user. This story ensures that if a file path is provided to parse(), it either succeeds in loading actual data or fails with an error, without generating mock data.

        Actions to Undertake:

            Task 1.3.1: Review all call sites of generateMockPointCloud() within E57Parser::parse(const QString& filePath).

            Task 1.3.2: Remove calls to generateMockPointCloud() from all failure paths within E57Parser::parse() when a file is being processed. Instead, ensure an appropriate error message is set using setError() and that parse() returns a failure indication (e.g., throws an exception or returns an empty vector with m_hasError set).

            Task 1.3.3: Ensure that MainWindow::onParsingFinished correctly interprets the failure from E57Parser (e.g., success == false or empty points with error) and displays an error message to the user instead of attempting to load non-existent/mock points.

            Task 1.3.4: (Optional, for testing) Retain generateMockPointCloud() as a private helper method that could be called explicitly for testing purposes if no file is provided, or via a dedicated test function, but not as a fallback during actual file parsing.

        References between Files:

            src/e57parser.cpp: Implementation of parse() and removal of generateMockPointCloud() calls.

            src/mainwindow.cpp: Logic in onParsingFinished to handle parsing failures from E57Parser.

            tests/test_e57parser.cpp: Tests to ensure mock data is not generated on parsing failure.

        Acceptance Criteria:

            When E57Parser::parse() is called with a path to an invalid or unparsable E57 file:

                generateMockPointCloud() is NOT called.

                The parse() method indicates failure (e.g., success is false in the parsingFinished signal).

                An appropriate error message is available via getLastError().

            The MainWindow displays an error message to the user.

            The PointCloudViewerWidget does not display mock data; it either remains blank, shows previous valid data (to be addressed by FR11 in a later sprint if not covered by current MainWindow logic), or shows a "load failed" state.

        Testing Plan:

            Integration Tests:

                Test Case 1.3.1: Attempt to load a completely invalid file (e.g., a text file renamed to .e57).

                    Test Data: invalid_file.e57 (a text file).

                    Expected Result: Application shows an error message (e.g., "Not a valid E57 file" or "Failed to parse E57 header"). No mock data is displayed.

                    Testing Tool: Manual execution of the application.

                Test Case 1.3.2: Attempt to load an E57 file with a corrupt header.

                    Test Data: An E57 file where the header is intentionally malformed.

                    Expected Result: Application shows an error message (e.g., "Corrupt E57 header"). No mock data is displayed.

                    Testing Tool: Manual execution of the application.

                Test Case 1.3.3: Attempt to load an E57 file with valid header but malformed XML.

                    Test Data: An E57 file with a syntactically incorrect XML section.

                    Expected Result: Application shows an error message (e.g., "Failed to parse E57 XML"). No mock data is displayed.

                    Testing Tool: Manual execution of the application.

3. Actions to Undertake

(Covered within each User Story's "Actions to Undertake" section.)
4. References between Files

The primary files involved in this sprint will be:

    src/e57parser.h: Interface definition for E57Parser. Will be modified to include new member variables for storing parsed XML metadata and potentially adjust method signatures.

    src/e57parser.cpp: Implementation of E57Parser. Significant refactoring of parseHeader, parseXmlSection, and extractPointsFromBinarySection. Removal of mock data fallbacks.

    src/mainwindow.cpp: The onParsingFinished slot might need adjustments to correctly handle failure states from the refactored E57Parser and ensure error messages are displayed appropriately.

    src/pointcloudviewerwidget.cpp: No direct changes anticipated, but it will be used to verify that correctly parsed points are displayed.

    test_e57_parsing.cpp (or tests/test_e57parser.cpp): Existing test file. Will need significant updates or new tests to cover the new parsing logic, XML interpretation, data extraction, and error handling.

    test_real.e57: A sample E57 file (potentially generated by test_e57_parsing.cpp initially, or a new standard simple E57 test file). This file will be crucial for testing.

Data Flows:

    MainWindow -> E57Parser::startParsing(filePath)

    E57Parser reads file -> Parses Header -> Parses XML -> Extracts Binary Data

    E57Parser emits parsingFinished(success, message, points)

    MainWindow::onParsingFinished receives signal -> If success, calls PointCloudViewerWidget::loadPointCloud(points)

    PointCloudViewerWidget renders points.

5. List of Files being Created

No new source code files are anticipated for creation in this sprint. The focus is on refactoring and enhancing existing files.

    Modified Files:

        src/e57parser.h

        src/e57parser.cpp

        src/mainwindow.cpp (potentially minor changes)

        tests/test_e57parser.cpp (or equivalent test file, significant updates)

    New Test Files (Data):

        It is highly recommended to create a set of small, well-defined .e57 test files for this sprint:

            File 1: simple_uncompressed.e57

                Purpose: A minimal, valid E57 file with a few uncompressed XYZ float points.

                Contents: Valid E57 header, minimal XML defining one point cloud with cartesianX, cartesianY, cartesianZ (single float), and a small binary section with known point data.

                Relationships: Used by tests/test_e57parser.cpp and for manual testing.

            File 2: corrupt_header.e57

                Purpose: Test header validation and error handling.

                Contents: An E57 file with an invalid signature or incorrect header fields.

                Relationships: Used by tests/test_e57parser.cpp.

            File 3: malformed_xml.e57

                Purpose: Test XML parsing error handling.

                Contents: Valid E57 header, but the XML section is syntactically incorrect.

                Relationships: Used by tests/test_e57parser.cpp.

            File 4: missing_points_definition.e57

                Purpose: Test handling of valid XML that doesn't define point data as expected.

                Contents: Valid E57 header and XML, but missing the /e57Root/data3D/points structure.

                Relationships: Used by tests/test_e57parser.cpp.

6. Acceptance Criteria

(Covered within each User Story's "Acceptance Criteria" section. The overall acceptance for the sprint is the successful completion of the "Definition of Done" as stated in the PRD for Sprint 1.1.)

Sprint 1.1 Definition of Done (from PRD):

    Can load a simple, uncompressed E57 file (like the one generated by test_e57_parsing.cpp but with correct XML interpretation) and display its points.

    Errors in XML parsing or data location are reported clearly to the user.

    The system does not fall back to mock data when an E57 file load is attempted.

7. Testing Plan

(Covered within each User Story's "Testing Plan" section, including unit and integration tests.)
The primary testing tool will be the Google Test framework (gtest) for C++ unit tests. Manual testing of the application with sample E57 files will be performed for integration and end-to-end validation.
8. Assumptions and Dependencies

    Assumptions:

        The E57 files targeted in this sprint will contain uncompressed point data.

        Point data will primarily consist of cartesianX, cartesianY, cartesianZ fields as single-precision floats.

        The existing QDomDocument is sufficient for parsing the E57 XML section for the complexity encountered in this sprint.

        Developers have access to the ASTM E57 standard documentation or reliable summaries for format details.

        The test_e57_parsing.cpp utility can be adapted or used as a basis for creating a simple, valid uncompressed E57 test file.

    Dependencies:

        Qt 6 framework (Core, Gui, Widgets, Xml if QDomDocument is used extensively).

        Google Test framework for unit testing.

        A C++ compiler supporting C++17 (as per typical modern Qt development).

9. Non-Functional Requirements

(Referencing the main PRD for overall NFRs. For this sprint, the most relevant are):

    NFR2 (Usability): Error messages from E57Parser should be clear.

    NFR3 (Maintainability): Refactored E57Parser code should be well-commented and structured.

    NFR4 (Robustness): The parser should handle basic error conditions in header/XML gracefully.

Performance (NFR1) and Memory Usage (NFR5) are less critical for this initial refactoring sprint but should not be significantly degraded. Major performance work is scheduled for Phase 2.
10. Conclusion

Sprint 1.1 aims to make significant progress in enabling reliable E57 file loading by focusing on the correct interpretation of the file's structure and the extraction of uncompressed point data. Successfully completing this sprint will provide a solid foundation for handling more complex E57 features and other file formats in subsequent sprints.